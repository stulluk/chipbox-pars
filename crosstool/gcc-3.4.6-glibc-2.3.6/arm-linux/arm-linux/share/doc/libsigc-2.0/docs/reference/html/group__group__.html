<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>group()</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head>
<body bgcolor="#ffffff">
<table border="0" width="100%">
<tr>
    <td width="10%" height="40"><img src="../../images/libsigc_logo.gif" alt="logo" border="0" width="100%" height="100%"/></td>
    <td width="90%" height="40"><img src="../../images/top.gif" alt="top" width="100%" height="40"/></td>
</tr>
</table>
<center>
  <a class="qindex" href="../../index.html">Main Page</a> &nbsp;
  <a class="qindex" href="modules.html">Groups</a> &nbsp;
  <a class="qindex" href="namespaces.html"> Namespaces</a> &nbsp;
</center>
<hr width="100%"/>

<!-- Generated by Doxygen 1.3.3 -->
<h1>group()<br>
<small>
[<a class="el" href="group__adaptors.html">Adaptors</a>]</small>
</h1><a class="el" href="namespacesigc.html#a37">sigc::group()</a> alters an arbitrary functor by rebuilding its arguments from one or more lambda expressions.  
<a href="#_details">More...</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
</table>
For each parameter that should be passed to the wrapped functor one lambda expression has to be passed into group(). Lambda selectors can be used as placeholders for the arguments passed into the new functor. Arguments that don't have a placeholder in one of the lambda expressions are dropped.<p>
<dl compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre>   <span class="keywordtype">void</span> foo(<span class="keywordtype">int</span>, <span class="keywordtype">int</span>);
   <span class="keywordtype">int</span> bar(<span class="keywordtype">int</span>);
   <span class="comment">// argument binding ...</span>
   <a class="code" href="namespacesigc.html#a37">sigc::group</a>(&amp;foo,10,sigc::_1)(20); <span class="comment">//fixes the first argument and calls foo(10,20)</span>
   <a class="code" href="namespacesigc.html#a37">sigc::group</a>(&amp;foo,sigc::_1,30)(40); <span class="comment">//fixes the second argument and calls foo(40,30)</span>
   <span class="comment">// argument reordering ...</span>
   <a class="code" href="namespacesigc.html#a37">sigc::group</a>(&amp;foo,sigc::_2,sigc::_1)(1,2); <span class="comment">//calls foo(2,1)</span>
   <span class="comment">// argument hiding ...</span>
   <a class="code" href="namespacesigc.html#a37">sigc::group</a>(&amp;foo,sigc::_1,sigc::_2)(1,2,3); <span class="comment">//calls foo(1,2)</span>
   <span class="comment">// functor composition ...</span>
   <a class="code" href="namespacesigc.html#a37">sigc::group</a>(&amp;foo,sigc::_1,sigc::group(&amp;bar,sigc::_2))(1,2); <span class="comment">//calls foo(1,bar(2))</span>
   <span class="comment">// algebraic expressions ...</span>
   <a class="code" href="namespacesigc.html#a37">sigc::group</a>(&amp;foo,sigc::_1*sigc::_2,sigc::_1/sigc::_2)(6,3); <span class="comment">//calls foo(6*3,6/3)</span>
</pre></div></dd></dl>
The functor <a class="el" href="namespacesigc.html#a37">sigc::group()</a> returns can be passed into <a class="el" href="classsigc_1_1signal7.html#a0">sigc::signal::connect()</a> directly.<p>
<dl compact><dt><b>Example:</b></dt><dd><div class="fragment"><pre>   <a class="code" href="classsigc_1_1signal.html">sigc::signal&lt;void,int,int&gt;</a> some_signal;
   <span class="keywordtype">void</span> foo(<span class="keywordtype">int</span>);
   some_signal.<a class="code" href="classsigc_1_1signal7.html#a0">connect</a>(sigc::group(&amp;foo,sigc::_2));
</pre></div></dd></dl>
Like in <a class="el" href="group__bind.html#a8">sigc::bind()</a> you can bind references to functors by passing the objects through the <a class="el" href="namespacesigc.html#a390">sigc::ref()</a> helper function.<p>
<dl compact><dt><b>Example:</b></dt><dd><div class="fragment"><pre>   <span class="keywordtype">int</span> some_int;
   <a class="code" href="classsigc_1_1signal.html">sigc::signal&lt;void&gt;</a> some_signal;
   <span class="keywordtype">void</span> foo(<span class="keywordtype">int</span>&amp;);
   some_signal.<a class="code" href="classsigc_1_1signal7.html#a0">connect</a>(sigc::group(&amp;foo,sigc::ref(some_int)));
</pre></div></dd></dl>
If you bind an object of a <a class="el" href="structsigc_1_1trackable.html">sigc::trackable</a> derived type to a functor by reference, a slot assigned to the group adaptor is cleared automatically when the object goes out of scope.<p>
<dl compact><dt><b>Example:</b></dt><dd><div class="fragment"><pre>   <span class="keyword">struct </span>bar : <span class="keyword">public</span> sigc::trackable {} some_bar;
   <a class="code" href="classsigc_1_1signal.html">sigc::signal&lt;void&gt;</a> some_signal;
   <span class="keywordtype">void</span> foo(bar&amp;);
   some_signal.<a class="code" href="classsigc_1_1signal7.html#a0">connect</a>(sigc::group(&amp;foo,sigc::ref(some_bar)));
     <span class="comment">// disconnected automatically if some_bar goes out of scope</span>
</pre></div></dd></dl>
<hr><address><small>
Generated for libsigc++ 2.0 by <a href="http://www.doxygen.org/index.html">
Doxygen</a> 1.3.3 &copy;&nbsp;1997-2001</small></address>
</body>
</html>

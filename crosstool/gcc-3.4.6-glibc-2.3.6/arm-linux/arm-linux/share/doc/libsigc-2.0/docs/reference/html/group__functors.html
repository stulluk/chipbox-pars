<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Functors</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head>
<body bgcolor="#ffffff">
<table border="0" width="100%">
<tr>
    <td width="10%" height="40"><img src="../../images/libsigc_logo.gif" alt="logo" border="0" width="100%" height="100%"/></td>
    <td width="90%" height="40"><img src="../../images/top.gif" alt="top" width="100%" height="40"/></td>
</tr>
</table>
<center>
  <a class="qindex" href="../../index.html">Main Page</a> &nbsp;
  <a class="qindex" href="modules.html">Groups</a> &nbsp;
  <a class="qindex" href="namespaces.html"> Namespaces</a> &nbsp;
</center>
<hr width="100%"/>

<!-- Generated by Doxygen 1.3.3 -->
<h1>Functors</h1>Functors are copyable types that define operator()().  
<a href="#_details">More...</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Modules</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="group__mem__fun.html">mem_fun()</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="group__mem__fun.html#a159">mem_fun()</a> is used to convert a pointer to a method to a functor. <br><br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="group__ptr__fun.html">ptr_fun()</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="group__ptr__fun.html#a15">ptr_fun()</a> is used to convert a pointer to a function to a functor. <br><br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="group__slot.html">Slots</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Slots are type-safe representations of callback methods and functions. <br><br></td></tr>

<p>
<tr><td colspan=2><br><h2>Compounds</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1functor__base.html">functor_base</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A hint to the compiler. </em> <a href="structsigc_1_1functor__base.html#_details">More...</a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__functors.html#a2">SIGC_FUNCTORS_HAVE_RESULT_TYPE</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If you want to mix functors from a different library with libsigc++ and these functors define <code>result_type</code> simply use this macro inside namespace sigc like so: <div class="fragment"><pre> <span class="keyword">namespace </span>sigc { <a class="code" href="group__functors.html#a2">SIGC_FUNCTORS_HAVE_RESULT_TYPE</a> }
</pre></div>. </em> <a href="#a2"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__functors.html#a3">SIGC_FUNCTOR_TRAIT</a>(T_functor, T_return)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If you want to mix functors from a different library with libsigc++ and these functors don't define <code>result_type</code> use this macro inside namespace sigc to expose the return type of the functors like so: <div class="fragment"><pre> <span class="keyword">namespace </span>sigc {
   <a class="code" href="group__functors.html#a3">SIGC_FUNCTOR_TRAIT</a>(first_functor_type, return_type_of_first_functor_type)
   <a class="code" href="group__functors.html#a3">SIGC_FUNCTOR_TRAIT</a>(second_functor_type, return_type_of_second_functor_type)
   ...
 }
</pre></div>. </em> <a href="#a3"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_functor&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__functors.html#a0">sigc::visit_each</a> (const T_action&amp; _A_action, const T_functor&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function performs a functor on each of the targets of a functor. </em> <a href="#a0"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_type, class T_action, class T_functor&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__functors.html#a1">sigc::visit_each_type</a> (const T_action&amp; _A_action, const T_functor&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function performs a functor on each of the targets of a functor limited to a restricted type. </em> <a href="#a1"></a><em><br><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Functors are copyable types that define operator()(). 
<p>
Types that define operator()() overloads with different return types are referred to as multi-type functors. Multi-type functors are only partly supported in libsigc++.<p>
Closures are functors that store all information needed to invoke a callback from operator()().<p>
Adaptors are functors that alter the signature of a functor's operator()().<p>
libsigc++ defines numerous functors, closures and adaptors. Since libsigc++ is a callback libaray, most functors are also closures. The documentation doesn't distinguish between functors and closures.<p>
The basic functor types libsigc++ provides are created with <a class="el" href="group__ptr__fun.html#a15">ptr_fun()</a> and <a class="el" href="group__mem__fun.html#a159">mem_fun()</a> and can be converted into slots implicitly. The set of adaptors that ships with libsigc++ is documented in the equally named module. <hr><h2>Define Documentation</h2>
<a name="a3" doxytag="functor_trait.h::SIGC_FUNCTOR_TRAIT"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SIGC_FUNCTOR_TRAIT</td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_functor,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre><span class="keyword">template</span> &lt;&gt;                                    \
<span class="keyword">struct </span>functor_trait&lt;T_functor,false&gt;          \
{                                              \
  <span class="keyword">typedef</span> T_return result_type;                \
  <span class="keyword">typedef</span> T_functor functor_type;              \
};
</pre></div>If you want to mix functors from a different library with libsigc++ and these functors don't define <code>result_type</code> use this macro inside namespace sigc to expose the return type of the functors like so: <div class="fragment"><pre> <span class="keyword">namespace </span>sigc {
   <a class="code" href="group__functors.html#a3">SIGC_FUNCTOR_TRAIT</a>(first_functor_type, return_type_of_first_functor_type)
   <a class="code" href="group__functors.html#a3">SIGC_FUNCTOR_TRAIT</a>(second_functor_type, return_type_of_second_functor_type)
   ...
 }
</pre></div>. 
<p>
    </td>
  </tr>
</table>
<a name="a2" doxytag="functor_trait.h::SIGC_FUNCTORS_HAVE_RESULT_TYPE"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SIGC_FUNCTORS_HAVE_RESULT_TYPE
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre><span class="keyword">template</span> &lt;<span class="keyword">class</span> T_functor&gt;                             \
<span class="keyword">struct </span>functor_trait&lt;T_functor,false&gt;                  \
{                                                      \
  <span class="keyword">typedef</span> <span class="keyword">typename</span> T_functor::result_type result_type; \
  <span class="keyword">typedef</span> T_functor functor_type;                      \
};
</pre></div>If you want to mix functors from a different library with libsigc++ and these functors define <code>result_type</code> simply use this macro inside namespace sigc like so: <div class="fragment"><pre> <span class="keyword">namespace </span>sigc { <a class="code" href="group__functors.html#a2">SIGC_FUNCTORS_HAVE_RESULT_TYPE</a> }
</pre></div>. 
<p>
    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a name="a0" doxytag="sigc::visit_each"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_action, class T_functor&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void visit_each </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_action&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const T_functor&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_functor</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function performs a functor on each of the targets of a functor. 
<p>
All unknown types just call <em>_A_action</em> on them. Add overloads that specialize the <em>T_functor</em> argument for your own functor types, so that subobjects get visited. This is needed to enable auto-disconnection support for your functor types.<p>
<dl compact><dt><b>Example:</b></dt><dd><div class="fragment"><pre>   <span class="keyword">struct </span>some_functor
   {
     <span class="keywordtype">void</span> operator()() {}
     some_possibly_sigc_trackable_derived_type some_data_member;
     some_other_functor_type some_other_functor;
   }

   <span class="keyword">namespace </span>sigc
   {
     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T_action&gt;
     <span class="keywordtype">void</span> <a class="code" href="group__adaptors.html#a0">visit_each</a>(<span class="keyword">const</span> T_action&amp; _A_action,
                     <span class="keyword">const</span> some_functor&amp; _A_target)
     {
       <a class="code" href="group__adaptors.html#a0">visit_each</a>(_A_action, _A_target.some_data_member);
       <a class="code" href="group__adaptors.html#a0">visit_each</a>(_A_action, _A_target.some_other_functor);
     }
   }
</pre></div></dd></dl>
    </td>
  </tr>
</table>
<a name="a1" doxytag="sigc::visit_each_type"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_type, class T_action, class T_functor&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void visit_each_type </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_action&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const T_functor&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_functor</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function performs a functor on each of the targets of a functor limited to a restricted type. 
<p>
    </td>
  </tr>
</table>
<hr><address><small>
Generated for libsigc++ 2.0 by <a href="http://www.doxygen.org/index.html">
Doxygen</a> 1.3.3 &copy;&nbsp;1997-2001</small></address>
</body>
</html>

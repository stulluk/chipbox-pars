<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title> Templatesigc::signal2&lt; T_return, T_arg1, T_arg2, T_accumulator &gt; class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head>
<body bgcolor="#ffffff">
<table border="0" width="100%">
<tr>
    <td width="10%" height="40"><img src="../../images/libsigc_logo.gif" alt="logo" border="0" width="100%" height="100%"/></td>
    <td width="90%" height="40"><img src="../../images/top.gif" alt="top" width="100%" height="40"/></td>
</tr>
</table>
<center>
  <a class="qindex" href="../../index.html">Main Page</a> &nbsp;
  <a class="qindex" href="modules.html">Groups</a> &nbsp;
  <a class="qindex" href="namespaces.html"> Namespaces</a> &nbsp;
</center>
<hr width="100%"/>

<!-- Generated by Doxygen 1.3.3 -->
<h1>sigc::signal2&lt; T_return, T_arg1, T_arg2, T_accumulator &gt; Class Template Reference<br>
<small>
[<a class="el" href="group__signal.html">Signals</a>]</small>
</h1>Signal declaration.  
<a href="#_details">More...</a>
<p>
Inheritance diagram for sigc::signal2&lt; T_return, T_arg1, T_arg2, T_accumulator &gt;:<p><center><img src="classsigc_1_1signal2__inherit__graph.png" border="0" usemap="#sigc_1_1signal2_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__accumulator_01_4__inherit__map" alt="Inheritance graph"></center>
<map name="sigc_1_1signal2_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__accumulator_01_4__inherit__map">
<area href="classSigC_1_1Signal2.html" shape="rect" coords="7,224,353,246" alt="">
<area href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_01_4_1_1accumulated.html" shape="rect" coords="377,224,700,246" alt="">
<area href="structsigc_1_1signal__base.html" shape="rect" coords="303,86,415,107" alt="">
<area href="structsigc_1_1trackable.html" shape="rect" coords="311,16,407,38" alt="">
</map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center><a href="classsigc_1_1signal2-members.html">List of all members.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef <a class="el" href="structsigc_1_1internal_1_1signal__emit2.html">internal::signal_emit2</a>&lt;<br>
 T_return, T_arg1, T_arg2,<br>
 T_accumulator &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1signal2.html#w0">emitter_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>typedef emitter_type::result_type&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1signal2.html#w1">result_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>typedef <a class="el" href="classsigc_1_1slot.html">slot</a>&lt; T_return, T_arg1,<br>
 T_arg2 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1signal2.html#w2">slot_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>typedef <a class="el" href="classsigc_1_1signal2.html#w3">slot_list</a>&lt;<a class="el" href="classsigc_1_1signal2.html#w2">slot_type</a>&gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1signal2.html#w3">slot_list</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>typedef <a class="el" href="structsigc_1_1slot__list.html#w3">slot_list::iterator</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1signal2.html#w4">iterator</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>typedef <a class="el" href="structsigc_1_1slot__list.html#w4">slot_list::const_iterator</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1signal2.html#w5">const_iterator</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>typedef <a class="el" href="structsigc_1_1slot__list.html#w5">slot_list::reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1signal2.html#w6">reverse_iterator</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>typedef <a class="el" href="structsigc_1_1slot__list.html#w6">slot_list::const_reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1signal2.html#w7">const_reverse_iterator</a></td></tr>

<tr><td colspan=2><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classsigc_1_1signal2.html#w4">iterator</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1signal2.html#a0">connect</a> (const <a class="el" href="classsigc_1_1signal2.html#w2">slot_type</a>&amp; slot_)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a slot to the list of slots. </em> <a href="#a0"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classsigc_1_1signal2.html#w1">result_type</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1signal2.html#a1">emit</a> (typename <a class="el" href="structsigc_1_1type__trait.html">type_trait</a>&lt;T_arg1&gt;::take _A_a1, typename <a class="el" href="structsigc_1_1type__trait.html">type_trait</a>&lt;T_arg2&gt;::take _A_a2) const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Triggers the emission of the signal. </em> <a href="#a1"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classsigc_1_1signal2.html#w1">result_type</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1signal2.html#a2">operator()</a> (typename <a class="el" href="structsigc_1_1type__trait.html">type_trait</a>&lt;T_arg1&gt;::take _A_a1, typename <a class="el" href="structsigc_1_1type__trait.html">type_trait</a>&lt;T_arg2&gt;::take _A_a2) const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Triggers the emission of the signal (see <a class="el" href="classsigc_1_1signal2.html#a1">emit()</a>). </em> <a href="#a2"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classsigc_1_1bound__const__mem__functor2.html">bound_const_mem_functor2</a>&lt;<br>
 <a class="el" href="classsigc_1_1signal2.html#w1">result_type</a>, <a class="el" href="classsigc_1_1signal2.html">signal2</a>, typename <br>
<a class="el" href="structsigc_1_1type__trait.html">type_trait</a>&lt;T_arg1&gt;::take,<br>
 typename <a class="el" href="structsigc_1_1type__trait.html">type_trait</a>&lt; T_arg2 <br>
&gt;::take &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1signal2.html#a3">make_slot</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor that calls <a class="el" href="classsigc_1_1signal2.html#a1">emit()</a> on this signal. </em> <a href="#a3"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classsigc_1_1signal2.html#w3">slot_list</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1signal2.html#a4">slots</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an STL-style interface for the signal's list of slots. </em> <a href="#a4"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>const <a class="el" href="classsigc_1_1signal2.html#w3">slot_list</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1signal2.html#a5">slots</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an STL-style interface for the signal's list of slots. </em> <a href="#a5"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1signal2.html#a6">signal2</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1signal2.html#a7">signal2</a> (const <a class="el" href="classsigc_1_1signal2.html">signal2</a>&amp; src)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template &lt;class T_return, class T_arg1, class T_arg2, class T_accumulator = nil&gt;<br>
 class sigc::signal2&lt; T_return, T_arg1, T_arg2, T_accumulator &gt;</h3>

Signal declaration. 
<p>
<a class="el" href="classsigc_1_1signal2.html">signal2</a> can be used to <a class="el" href="classsigc_1_1signal2.html#a0">connect()</a> slots that are invoked during subsequent calls to <a class="el" href="classsigc_1_1signal2.html#a1">emit()</a>. Any functor or slot can be passed into <a class="el" href="classsigc_1_1signal2.html#a0">connect()</a>. It is converted into a slot implicitely.<p>
If you want to connect one signal to another, use <a class="el" href="classsigc_1_1signal2.html#a3">make_slot()</a> to retrieve a functor that emits the signal when invoked.<p>
Be careful if you directly pass one signal into the <a class="el" href="classsigc_1_1signal2.html#a0">connect()</a> method of another: a shallow copy of the signal is made and the signal's slots are not disconnected until both the signal and its clone are destroyed which is probably not what you want!<p>
An STL-style list interface for the signal's list of slots can be retrieved with <a class="el" href="classsigc_1_1signal2.html#a4">slots()</a>. This interface supports iteration, insertion and removal of slots.<p>
The following template arguments are used:<ul>
<li><em>T_return</em> The desired return type for the <a class="el" href="classsigc_1_1signal2.html#a1">emit()</a> function (may be overridden by the accumulator).</li><li><em>T_arg1</em> Argument type used in the definition of <a class="el" href="classsigc_1_1signal2.html#a1">emit()</a>.</li><li><em>T_arg2</em> Argument type used in the definition of <a class="el" href="classsigc_1_1signal2.html#a1">emit()</a>.</li><li><em>T_accumulator</em> The accumulator type used for emission. The default <code>nil</code> means that no accumulator should be used, i.e. signal emission returns the return value of the last slot invoked.</li></ul>
<p>
You should use the more convenient unnumbered <a class="el" href="classsigc_1_1signal.html">sigc::signal</a> template. 
<p>
<hr><h2>Member Typedef Documentation</h2>
<a name="w5" doxytag="sigc::signal2::const_iterator"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_accumulator = nil&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> typedef <a class="el" href="structsigc_1_1slot__list.html#w4">slot_list::const_iterator</a> <a class="el" href="classsigc_1_1signal2.html">sigc::signal2</a>&lt;T_return, T_arg1, T_arg2, T_accumulator&gt;::<a class="el" href="classsigc_1_1signal2.html#w5">const_iterator</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="w7" doxytag="sigc::signal2::const_reverse_iterator"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_accumulator = nil&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> typedef <a class="el" href="structsigc_1_1slot__list.html#w6">slot_list::const_reverse_iterator</a> <a class="el" href="classsigc_1_1signal2.html">sigc::signal2</a>&lt;T_return, T_arg1, T_arg2, T_accumulator&gt;::<a class="el" href="classsigc_1_1signal2.html#w7">const_reverse_iterator</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="w0" doxytag="sigc::signal2::emitter_type"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_accumulator = nil&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> typedef <a class="el" href="structsigc_1_1internal_1_1signal__emit2.html">internal::signal_emit2</a>&lt;T_return, T_arg1,T_arg2, T_accumulator&gt; <a class="el" href="classsigc_1_1signal2.html">sigc::signal2</a>&lt;T_return, T_arg1, T_arg2, T_accumulator&gt;::<a class="el" href="classsigc_1_1signal2.html#w0">emitter_type</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="w4" doxytag="sigc::signal2::iterator"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_accumulator = nil&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> typedef <a class="el" href="structsigc_1_1slot__list.html#w3">slot_list::iterator</a> <a class="el" href="classsigc_1_1signal2.html">sigc::signal2</a>&lt;T_return, T_arg1, T_arg2, T_accumulator&gt;::<a class="el" href="classsigc_1_1signal2.html#w4">iterator</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="w1" doxytag="sigc::signal2::result_type"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_accumulator = nil&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> typedef emitter_type::result_type <a class="el" href="classsigc_1_1signal2.html">sigc::signal2</a>&lt;T_return, T_arg1, T_arg2, T_accumulator&gt;::<a class="el" href="classsigc_1_1signal2.html#w1">result_type</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Reimplemented in <a class="el" href="classSigC_1_1Signal2.html#w1">SigC::Signal2&lt;T_return, T_arg1, T_arg2, T_accumulator&gt;</a>.    </td>
  </tr>
</table>
<a name="w6" doxytag="sigc::signal2::reverse_iterator"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_accumulator = nil&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> typedef <a class="el" href="structsigc_1_1slot__list.html#w5">slot_list::reverse_iterator</a> <a class="el" href="classsigc_1_1signal2.html">sigc::signal2</a>&lt;T_return, T_arg1, T_arg2, T_accumulator&gt;::<a class="el" href="classsigc_1_1signal2.html#w6">reverse_iterator</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="w3" doxytag="sigc::signal2::slot_list"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_accumulator = nil&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> typedef <a class="el" href="classsigc_1_1signal2.html#w3">slot_list</a>&lt;<a class="el" href="classsigc_1_1signal2.html#w2">slot_type</a>&gt; <a class="el" href="classsigc_1_1signal2.html">sigc::signal2</a>&lt;T_return, T_arg1, T_arg2, T_accumulator&gt;::<a class="el" href="classsigc_1_1signal2.html#w3">slot_list</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="w2" doxytag="sigc::signal2::slot_type"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_accumulator = nil&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> typedef <a class="el" href="classsigc_1_1slot.html">slot</a>&lt;T_return, T_arg1,T_arg2&gt; <a class="el" href="classsigc_1_1signal2.html">sigc::signal2</a>&lt;T_return, T_arg1, T_arg2, T_accumulator&gt;::<a class="el" href="classsigc_1_1signal2.html#w2">slot_type</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Reimplemented in <a class="el" href="classSigC_1_1Signal2.html#w2">SigC::Signal2&lt;T_return, T_arg1, T_arg2, T_accumulator&gt;</a>.    </td>
  </tr>
</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a name="a6" doxytag="sigc::signal2::signal2"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_accumulator = nil&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classsigc_1_1signal2.html">sigc::signal2</a>&lt;T_return, T_arg1, T_arg2, T_accumulator&gt;::<a class="el" href="classsigc_1_1signal2.html">signal2</a> </td>
          <td class="md" valign="top">(</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a7" doxytag="sigc::signal2::signal2"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_accumulator = nil&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classsigc_1_1signal2.html">sigc::signal2</a>&lt;T_return, T_arg1, T_arg2, T_accumulator&gt;::<a class="el" href="classsigc_1_1signal2.html">signal2</a> </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classsigc_1_1signal2.html">signal2</a>&lt;T_return, T_arg1, T_arg2, T_accumulator&gt;&amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>src</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a name="a0" doxytag="sigc::signal2::connect"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_accumulator = nil&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classsigc_1_1signal2.html#w4">iterator</a> <a class="el" href="classsigc_1_1signal2.html">sigc::signal2</a>&lt;T_return, T_arg1, T_arg2, T_accumulator&gt;::connect </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classsigc_1_1signal2.html#w2">slot_type</a>&amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>slot_</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Add a slot to the list of slots. 
<p>
Any functor or slot may be passed into <a class="el" href="classsigc_1_1signal2.html#a0">connect()</a>. It will be converted into a slot implicitely. The returned iterator may be stored for disconnection of the slot at some later point. It stays valid until the slot is removed from the list of slots. The iterator can also be implicitely converted into a <a class="el" href="structsigc_1_1connection.html">sigc::connection</a> object that may be used safely beyond the life time of the slot. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>slot_</em>&nbsp;</td><td>The slot to add to the list of slots. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>An iterator pointing to the new slot in the list. </dd></dl>
    </td>
  </tr>
</table>
<a name="a1" doxytag="sigc::signal2::emit"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_accumulator = nil&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classsigc_1_1signal2.html#w1">result_type</a> <a class="el" href="classsigc_1_1signal2.html">sigc::signal2</a>&lt;T_return, T_arg1, T_arg2, T_accumulator&gt;::emit </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">typename <a class="el" href="structsigc_1_1type__trait.html">type_trait</a>&lt;T_arg1&gt;::take&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>typename <a class="el" href="structsigc_1_1type__trait.html">type_trait</a>&lt;T_arg2&gt;::take&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Triggers the emission of the signal. 
<p>
During signal emission all slots that have been connected to the signal are invoked unless they are manually set into a blocking state. The parameters are passed on to the slots. If <em>T_accumulated</em> is not <code>nil</code>, an accumulator of this type is used to process the return values of the slot invocations. Otherwise, the return value of the last slot invoked is returned. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_a1</em>&nbsp;</td><td>Argument to be passed on to the slots. </td></tr>
    <tr><td valign=top><em>_A_a2</em>&nbsp;</td><td>Argument to be passed on to the slots. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The accumulated return values of the slot invocations. </dd></dl>
    </td>
  </tr>
</table>
<a name="a3" doxytag="sigc::signal2::make_slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_accumulator = nil&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classsigc_1_1bound__const__mem__functor2.html">bound_const_mem_functor2</a>&lt;<a class="el" href="classsigc_1_1signal2.html#w1">result_type</a>, <a class="el" href="classsigc_1_1signal2.html">signal2</a>, typename <a class="el" href="structsigc_1_1type__trait.html">type_trait</a>&lt;T_arg1&gt;::take,typename <a class="el" href="structsigc_1_1type__trait.html">type_trait</a>&lt;T_arg2&gt;::take&gt; <a class="el" href="classsigc_1_1signal2.html">sigc::signal2</a>&lt;T_return, T_arg1, T_arg2, T_accumulator&gt;::make_slot </td>
          <td class="md" valign="top">(</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor that calls <a class="el" href="classsigc_1_1signal2.html#a1">emit()</a> on this signal. 
<p>
<div class="fragment"><pre> <a class="code" href="group__mem__fun.html#a96">sigc::mem_fun</a>(mysignal, &amp;sigc::signal2::emit)
</pre></div>yields the same result. <dl compact><dt><b>Returns:</b></dt><dd>A functor that calls <a class="el" href="classsigc_1_1signal2.html#a1">emit()</a> on this signal. </dd></dl>
    </td>
  </tr>
</table>
<a name="a2" doxytag="sigc::signal2::operator()"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_accumulator = nil&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classsigc_1_1signal2.html#w1">result_type</a> <a class="el" href="classsigc_1_1signal2.html">sigc::signal2</a>&lt;T_return, T_arg1, T_arg2, T_accumulator&gt;::operator() </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">typename <a class="el" href="structsigc_1_1type__trait.html">type_trait</a>&lt;T_arg1&gt;::take&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>typename <a class="el" href="structsigc_1_1type__trait.html">type_trait</a>&lt;T_arg2&gt;::take&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Triggers the emission of the signal (see <a class="el" href="classsigc_1_1signal2.html#a1">emit()</a>). 
<p>
    </td>
  </tr>
</table>
<a name="a5" doxytag="sigc::signal2::slots"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_accumulator = nil&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> const <a class="el" href="classsigc_1_1signal2.html#w3">slot_list</a> <a class="el" href="classsigc_1_1signal2.html">sigc::signal2</a>&lt;T_return, T_arg1, T_arg2, T_accumulator&gt;::slots </td>
          <td class="md" valign="top">(</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates an STL-style interface for the signal's list of slots. 
<p>
This interface supports iteration, insertion and removal of slots. <dl compact><dt><b>Returns:</b></dt><dd>An STL-style interface for the signal's list of slots. </dd></dl>
    </td>
  </tr>
</table>
<a name="a4" doxytag="sigc::signal2::slots"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_accumulator = nil&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classsigc_1_1signal2.html#w3">slot_list</a> <a class="el" href="classsigc_1_1signal2.html">sigc::signal2</a>&lt;T_return, T_arg1, T_arg2, T_accumulator&gt;::slots </td>
          <td class="md" valign="top">(</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates an STL-style interface for the signal's list of slots. 
<p>
This interface supports iteration, insertion and removal of slots. <dl compact><dt><b>Returns:</b></dt><dd>An STL-style interface for the signal's list of slots. </dd></dl>
    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="signal_8h.html">signal.h</a></ul>
<hr><address><small>
Generated for libsigc++ 2.0 by <a href="http://www.doxygen.org/index.html">
Doxygen</a> 1.3.3 &copy;&nbsp;1997-2001</small></address>
</body>
</html>

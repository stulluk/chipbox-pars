<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>mem_fun()</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head>
<body bgcolor="#ffffff">
<table border="0" width="100%">
<tr>
    <td width="10%" height="40"><img src="../../images/libsigc_logo.gif" alt="logo" border="0" width="100%" height="100%"/></td>
    <td width="90%" height="40"><img src="../../images/top.gif" alt="top" width="100%" height="40"/></td>
</tr>
</table>
<center>
  <a class="qindex" href="../../index.html">Main Page</a> &nbsp;
  <a class="qindex" href="modules.html">Groups</a> &nbsp;
  <a class="qindex" href="namespaces.html"> Namespaces</a> &nbsp;
</center>
<hr width="100%"/>

<!-- Generated by Doxygen 1.3.3 -->
<h1>mem_fun()<br>
<small>
[<a class="el" href="group__functors.html">Functors</a>]</small>
</h1><a class="el" href="group__mem__fun.html#a159">mem_fun()</a> is used to convert a pointer to a method to a functor.  
<a href="#_details">More...</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Compounds</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__const__mem__functor0.html">bound_const_mem_functor0</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor0.html">bound_const_mem_functor0</a> encapsulates a const method with 0 arguments and an object instance. </em> <a href="classsigc_1_1bound__const__mem__functor0.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__const__mem__functor1.html">bound_const_mem_functor1</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor1.html">bound_const_mem_functor1</a> encapsulates a const method with 1 arguments and an object instance. </em> <a href="classsigc_1_1bound__const__mem__functor1.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__const__mem__functor2.html">bound_const_mem_functor2</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor2.html">bound_const_mem_functor2</a> encapsulates a const method with 2 arguments and an object instance. </em> <a href="classsigc_1_1bound__const__mem__functor2.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__const__mem__functor3.html">bound_const_mem_functor3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor3.html">bound_const_mem_functor3</a> encapsulates a const method with 3 arguments and an object instance. </em> <a href="classsigc_1_1bound__const__mem__functor3.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__const__mem__functor4.html">bound_const_mem_functor4</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor4.html">bound_const_mem_functor4</a> encapsulates a const method with 4 arguments and an object instance. </em> <a href="classsigc_1_1bound__const__mem__functor4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__const__mem__functor5.html">bound_const_mem_functor5</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor5.html">bound_const_mem_functor5</a> encapsulates a const method with 5 arguments and an object instance. </em> <a href="classsigc_1_1bound__const__mem__functor5.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__const__mem__functor6.html">bound_const_mem_functor6</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor6.html">bound_const_mem_functor6</a> encapsulates a const method with 6 arguments and an object instance. </em> <a href="classsigc_1_1bound__const__mem__functor6.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__const__mem__functor7.html">bound_const_mem_functor7</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor7.html">bound_const_mem_functor7</a> encapsulates a const method with 7 arguments and an object instance. </em> <a href="classsigc_1_1bound__const__mem__functor7.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">bound_const_volatile_mem_functor0</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">bound_const_volatile_mem_functor0</a> encapsulates a const volatile method with 0 arguments and an object instance. </em> <a href="classsigc_1_1bound__const__volatile__mem__functor0.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">bound_const_volatile_mem_functor1</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">bound_const_volatile_mem_functor1</a> encapsulates a const volatile method with 1 arguments and an object instance. </em> <a href="classsigc_1_1bound__const__volatile__mem__functor1.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">bound_const_volatile_mem_functor2</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">bound_const_volatile_mem_functor2</a> encapsulates a const volatile method with 2 arguments and an object instance. </em> <a href="classsigc_1_1bound__const__volatile__mem__functor2.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">bound_const_volatile_mem_functor3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">bound_const_volatile_mem_functor3</a> encapsulates a const volatile method with 3 arguments and an object instance. </em> <a href="classsigc_1_1bound__const__volatile__mem__functor3.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">bound_const_volatile_mem_functor4</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">bound_const_volatile_mem_functor4</a> encapsulates a const volatile method with 4 arguments and an object instance. </em> <a href="classsigc_1_1bound__const__volatile__mem__functor4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">bound_const_volatile_mem_functor5</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">bound_const_volatile_mem_functor5</a> encapsulates a const volatile method with 5 arguments and an object instance. </em> <a href="classsigc_1_1bound__const__volatile__mem__functor5.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">bound_const_volatile_mem_functor6</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">bound_const_volatile_mem_functor6</a> encapsulates a const volatile method with 6 arguments and an object instance. </em> <a href="classsigc_1_1bound__const__volatile__mem__functor6.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">bound_const_volatile_mem_functor7</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">bound_const_volatile_mem_functor7</a> encapsulates a const volatile method with 7 arguments and an object instance. </em> <a href="classsigc_1_1bound__const__volatile__mem__functor7.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__mem__functor0.html">bound_mem_functor0</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor0.html">bound_mem_functor0</a> encapsulates a method with 0 arguments and an object instance. </em> <a href="classsigc_1_1bound__mem__functor0.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__mem__functor1.html">bound_mem_functor1</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor1.html">bound_mem_functor1</a> encapsulates a method with 1 arguments and an object instance. </em> <a href="classsigc_1_1bound__mem__functor1.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__mem__functor2.html">bound_mem_functor2</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor2.html">bound_mem_functor2</a> encapsulates a method with 2 arguments and an object instance. </em> <a href="classsigc_1_1bound__mem__functor2.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__mem__functor3.html">bound_mem_functor3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor3.html">bound_mem_functor3</a> encapsulates a method with 3 arguments and an object instance. </em> <a href="classsigc_1_1bound__mem__functor3.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__mem__functor4.html">bound_mem_functor4</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor4.html">bound_mem_functor4</a> encapsulates a method with 4 arguments and an object instance. </em> <a href="classsigc_1_1bound__mem__functor4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__mem__functor5.html">bound_mem_functor5</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor5.html">bound_mem_functor5</a> encapsulates a method with 5 arguments and an object instance. </em> <a href="classsigc_1_1bound__mem__functor5.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__mem__functor6.html">bound_mem_functor6</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor6.html">bound_mem_functor6</a> encapsulates a method with 6 arguments and an object instance. </em> <a href="classsigc_1_1bound__mem__functor6.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__mem__functor7.html">bound_mem_functor7</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor7.html">bound_mem_functor7</a> encapsulates a method with 7 arguments and an object instance. </em> <a href="classsigc_1_1bound__mem__functor7.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html">bound_volatile_mem_functor0</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html">bound_volatile_mem_functor0</a> encapsulates a volatile method with 0 arguments and an object instance. </em> <a href="classsigc_1_1bound__volatile__mem__functor0.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html">bound_volatile_mem_functor1</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html">bound_volatile_mem_functor1</a> encapsulates a volatile method with 1 arguments and an object instance. </em> <a href="classsigc_1_1bound__volatile__mem__functor1.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html">bound_volatile_mem_functor2</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html">bound_volatile_mem_functor2</a> encapsulates a volatile method with 2 arguments and an object instance. </em> <a href="classsigc_1_1bound__volatile__mem__functor2.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html">bound_volatile_mem_functor3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html">bound_volatile_mem_functor3</a> encapsulates a volatile method with 3 arguments and an object instance. </em> <a href="classsigc_1_1bound__volatile__mem__functor3.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html">bound_volatile_mem_functor4</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html">bound_volatile_mem_functor4</a> encapsulates a volatile method with 4 arguments and an object instance. </em> <a href="classsigc_1_1bound__volatile__mem__functor4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html">bound_volatile_mem_functor5</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html">bound_volatile_mem_functor5</a> encapsulates a volatile method with 5 arguments and an object instance. </em> <a href="classsigc_1_1bound__volatile__mem__functor5.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html">bound_volatile_mem_functor6</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html">bound_volatile_mem_functor6</a> encapsulates a volatile method with 6 arguments and an object instance. </em> <a href="classsigc_1_1bound__volatile__mem__functor6.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html">bound_volatile_mem_functor7</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html">bound_volatile_mem_functor7</a> encapsulates a volatile method with 7 arguments and an object instance. </em> <a href="classsigc_1_1bound__volatile__mem__functor7.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1const__mem__functor0.html">const_mem_functor0</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor0.html">const_mem_functor0</a> wraps const methods with 0 argument(s). </em> <a href="classsigc_1_1const__mem__functor0.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1const__mem__functor1.html">const_mem_functor1</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor1.html">const_mem_functor1</a> wraps const methods with 1 argument(s). </em> <a href="classsigc_1_1const__mem__functor1.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1const__mem__functor2.html">const_mem_functor2</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor2.html">const_mem_functor2</a> wraps const methods with 2 argument(s). </em> <a href="classsigc_1_1const__mem__functor2.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1const__mem__functor3.html">const_mem_functor3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor3.html">const_mem_functor3</a> wraps const methods with 3 argument(s). </em> <a href="classsigc_1_1const__mem__functor3.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1const__mem__functor4.html">const_mem_functor4</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor4.html">const_mem_functor4</a> wraps const methods with 4 argument(s). </em> <a href="classsigc_1_1const__mem__functor4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1const__mem__functor5.html">const_mem_functor5</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor5.html">const_mem_functor5</a> wraps const methods with 5 argument(s). </em> <a href="classsigc_1_1const__mem__functor5.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1const__mem__functor6.html">const_mem_functor6</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor6.html">const_mem_functor6</a> wraps const methods with 6 argument(s). </em> <a href="classsigc_1_1const__mem__functor6.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1const__mem__functor7.html">const_mem_functor7</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor7.html">const_mem_functor7</a> wraps const methods with 7 argument(s). </em> <a href="classsigc_1_1const__mem__functor7.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1const__volatile__mem__functor0.html">const_volatile_mem_functor0</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor0.html">const_volatile_mem_functor0</a> wraps const volatile methods with 0 argument(s). </em> <a href="classsigc_1_1const__volatile__mem__functor0.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1const__volatile__mem__functor1.html">const_volatile_mem_functor1</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor1.html">const_volatile_mem_functor1</a> wraps const volatile methods with 1 argument(s). </em> <a href="classsigc_1_1const__volatile__mem__functor1.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1const__volatile__mem__functor2.html">const_volatile_mem_functor2</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor2.html">const_volatile_mem_functor2</a> wraps const volatile methods with 2 argument(s). </em> <a href="classsigc_1_1const__volatile__mem__functor2.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1const__volatile__mem__functor3.html">const_volatile_mem_functor3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor3.html">const_volatile_mem_functor3</a> wraps const volatile methods with 3 argument(s). </em> <a href="classsigc_1_1const__volatile__mem__functor3.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1const__volatile__mem__functor4.html">const_volatile_mem_functor4</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor4.html">const_volatile_mem_functor4</a> wraps const volatile methods with 4 argument(s). </em> <a href="classsigc_1_1const__volatile__mem__functor4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1const__volatile__mem__functor5.html">const_volatile_mem_functor5</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor5.html">const_volatile_mem_functor5</a> wraps const volatile methods with 5 argument(s). </em> <a href="classsigc_1_1const__volatile__mem__functor5.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1const__volatile__mem__functor6.html">const_volatile_mem_functor6</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor6.html">const_volatile_mem_functor6</a> wraps const volatile methods with 6 argument(s). </em> <a href="classsigc_1_1const__volatile__mem__functor6.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1const__volatile__mem__functor7.html">const_volatile_mem_functor7</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor7.html">const_volatile_mem_functor7</a> wraps const volatile methods with 7 argument(s). </em> <a href="classsigc_1_1const__volatile__mem__functor7.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1mem__functor0.html">mem_functor0</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor0.html">mem_functor0</a> wraps methods with 0 argument(s). </em> <a href="classsigc_1_1mem__functor0.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1mem__functor1.html">mem_functor1</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor1.html">mem_functor1</a> wraps methods with 1 argument(s). </em> <a href="classsigc_1_1mem__functor1.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1mem__functor2.html">mem_functor2</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor2.html">mem_functor2</a> wraps methods with 2 argument(s). </em> <a href="classsigc_1_1mem__functor2.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1mem__functor3.html">mem_functor3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor3.html">mem_functor3</a> wraps methods with 3 argument(s). </em> <a href="classsigc_1_1mem__functor3.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1mem__functor4.html">mem_functor4</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor4.html">mem_functor4</a> wraps methods with 4 argument(s). </em> <a href="classsigc_1_1mem__functor4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1mem__functor5.html">mem_functor5</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor5.html">mem_functor5</a> wraps methods with 5 argument(s). </em> <a href="classsigc_1_1mem__functor5.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1mem__functor6.html">mem_functor6</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor6.html">mem_functor6</a> wraps methods with 6 argument(s). </em> <a href="classsigc_1_1mem__functor6.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1mem__functor7.html">mem_functor7</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor7.html">mem_functor7</a> wraps methods with 7 argument(s). </em> <a href="classsigc_1_1mem__functor7.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1volatile__mem__functor0.html">volatile_mem_functor0</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor0.html">volatile_mem_functor0</a> wraps volatile methods with 0 argument(s). </em> <a href="classsigc_1_1volatile__mem__functor0.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1volatile__mem__functor1.html">volatile_mem_functor1</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor1.html">volatile_mem_functor1</a> wraps volatile methods with 1 argument(s). </em> <a href="classsigc_1_1volatile__mem__functor1.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1volatile__mem__functor2.html">volatile_mem_functor2</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor2.html">volatile_mem_functor2</a> wraps volatile methods with 2 argument(s). </em> <a href="classsigc_1_1volatile__mem__functor2.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1volatile__mem__functor3.html">volatile_mem_functor3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor3.html">volatile_mem_functor3</a> wraps volatile methods with 3 argument(s). </em> <a href="classsigc_1_1volatile__mem__functor3.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1volatile__mem__functor4.html">volatile_mem_functor4</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor4.html">volatile_mem_functor4</a> wraps volatile methods with 4 argument(s). </em> <a href="classsigc_1_1volatile__mem__functor4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1volatile__mem__functor5.html">volatile_mem_functor5</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor5.html">volatile_mem_functor5</a> wraps volatile methods with 5 argument(s). </em> <a href="classsigc_1_1volatile__mem__functor5.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1volatile__mem__functor6.html">volatile_mem_functor6</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor6.html">volatile_mem_functor6</a> wraps volatile methods with 6 argument(s). </em> <a href="classsigc_1_1volatile__mem__functor6.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1volatile__mem__functor7.html">volatile_mem_functor7</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor7.html">volatile_mem_functor7</a> wraps volatile methods with 7 argument(s). </em> <a href="classsigc_1_1volatile__mem__functor7.html#_details">More...</a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a0">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_mem_functor0&lt;T_return, T_obj&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="#a0"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a1">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_mem_functor1&lt;T_return, T_obj, T_arg1&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="#a1"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a2">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_mem_functor2&lt;T_return, T_obj, T_arg1, T_arg2&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="#a2"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a3">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_mem_functor3&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="#a3"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a4">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_mem_functor4&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="#a4"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a5">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_mem_functor5&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="#a5"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a6">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_mem_functor6&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="#a6"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a7">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_mem_functor7&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="#a7"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a8">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_mem_functor0&lt;T_return, T_obj&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="#a8"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a9">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_mem_functor1&lt;T_return, T_obj, T_arg1&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="#a9"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a10">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_mem_functor2&lt;T_return, T_obj, T_arg1, T_arg2&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="#a10"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a11">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_mem_functor3&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="#a11"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a12">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_mem_functor4&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="#a12"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a13">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_mem_functor5&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="#a13"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a14">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_mem_functor6&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="#a14"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a15">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_mem_functor7&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="#a15"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a16">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_volatile_mem_functor0&lt;T_return, T_obj&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="#a16"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a17">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_volatile_mem_functor1&lt;T_return, T_obj, T_arg1&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="#a17"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a18">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_volatile_mem_functor2&lt;T_return, T_obj, T_arg1, T_arg2&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="#a18"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a19">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_volatile_mem_functor3&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="#a19"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a20">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_volatile_mem_functor4&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="#a20"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a21">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_volatile_mem_functor5&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="#a21"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a22">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_volatile_mem_functor6&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="#a22"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a23">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_volatile_mem_functor7&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="#a23"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a24">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_volatile_mem_functor0&lt;T_return, T_obj&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="#a24"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a25">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_volatile_mem_functor1&lt;T_return, T_obj, T_arg1&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="#a25"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a26">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_volatile_mem_functor2&lt;T_return, T_obj, T_arg1, T_arg2&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="#a26"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a27">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_volatile_mem_functor3&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="#a27"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a28">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_volatile_mem_functor4&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="#a28"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a29">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_volatile_mem_functor5&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="#a29"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a30">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_volatile_mem_functor6&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="#a30"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a31">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_volatile_mem_functor7&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="#a31"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj&gt; mem_functor0&lt;T_return, T_obj&gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a32">sigc::mem_fun0</a> (T_return(T_obj::* _A_func)())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor0.html">sigc::mem_functor0</a> which wraps a method. </em> <a href="#a32"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_return, class T_obj&gt; mem_functor1&lt; T_return, T_obj,<br>
 T_arg1 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a33">sigc::mem_fun1</a> (T_return(T_obj::* _A_func)(T_arg1))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor1.html">sigc::mem_functor1</a> which wraps a method. </em> <a href="#a33"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_return, class T_obj&gt; mem_functor2&lt; T_return, T_obj,<br>
 T_arg1, T_arg2 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a34">sigc::mem_fun2</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor2.html">sigc::mem_functor2</a> which wraps a method. </em> <a href="#a34"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj&gt; mem_functor3&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a35">sigc::mem_fun3</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor3.html">sigc::mem_functor3</a> which wraps a method. </em> <a href="#a35"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj&gt; mem_functor4&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a36">sigc::mem_fun4</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor4.html">sigc::mem_functor4</a> which wraps a method. </em> <a href="#a36"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj&gt; mem_functor5&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a37">sigc::mem_fun5</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor5.html">sigc::mem_functor5</a> which wraps a method. </em> <a href="#a37"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj&gt; mem_functor6&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5, T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a38">sigc::mem_fun6</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor6.html">sigc::mem_functor6</a> which wraps a method. </em> <a href="#a38"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj&gt; mem_functor7&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5, T_arg6, T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a39">sigc::mem_fun7</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor7.html">sigc::mem_functor7</a> which wraps a method. </em> <a href="#a39"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_obj&gt; const_mem_functor0&lt; T_return,<br>
 T_obj &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a40">sigc::mem_fun0</a> (T_return(T_obj::* _A_func)() const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor0.html">sigc::const_mem_functor0</a> which wraps a const method. </em> <a href="#a40"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_return, class T_obj&gt; const_mem_functor1&lt; T_return,<br>
 T_obj, T_arg1 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a41">sigc::mem_fun1</a> (T_return(T_obj::* _A_func)(T_arg1) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor1.html">sigc::const_mem_functor1</a> which wraps a const method. </em> <a href="#a41"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_return, class T_obj&gt; const_mem_functor2&lt; T_return,<br>
 T_obj, T_arg1, T_arg2 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a42">sigc::mem_fun2</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor2.html">sigc::const_mem_functor2</a> which wraps a const method. </em> <a href="#a42"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj&gt; const_mem_functor3&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a43">sigc::mem_fun3</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor3.html">sigc::const_mem_functor3</a> which wraps a const method. </em> <a href="#a43"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj&gt; const_mem_functor4&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a44">sigc::mem_fun4</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor4.html">sigc::const_mem_functor4</a> which wraps a const method. </em> <a href="#a44"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj&gt; const_mem_functor5&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a45">sigc::mem_fun5</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor5.html">sigc::const_mem_functor5</a> which wraps a const method. </em> <a href="#a45"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj&gt; const_mem_functor6&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5, T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a46">sigc::mem_fun6</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor6.html">sigc::const_mem_functor6</a> which wraps a const method. </em> <a href="#a46"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj&gt; const_mem_functor7&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5, T_arg6, T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a47">sigc::mem_fun7</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor7.html">sigc::const_mem_functor7</a> which wraps a const method. </em> <a href="#a47"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_obj&gt; volatile_mem_functor0&lt; T_return,<br>
 T_obj &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a48">sigc::mem_fun0</a> (T_return(T_obj::* _A_func)() volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor0.html">sigc::const_volatile_mem_functor0</a> which wraps a const volatile method. </em> <a href="#a48"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_return, class T_obj&gt; volatile_mem_functor1&lt; T_return,<br>
 T_obj, T_arg1 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a49">sigc::mem_fun1</a> (T_return(T_obj::* _A_func)(T_arg1) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor1.html">sigc::const_volatile_mem_functor1</a> which wraps a const volatile method. </em> <a href="#a49"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_return, class T_obj&gt; volatile_mem_functor2&lt; T_return,<br>
 T_obj, T_arg1, T_arg2 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a50">sigc::mem_fun2</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor2.html">sigc::const_volatile_mem_functor2</a> which wraps a const volatile method. </em> <a href="#a50"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj&gt; volatile_mem_functor3&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a51">sigc::mem_fun3</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor3.html">sigc::const_volatile_mem_functor3</a> which wraps a const volatile method. </em> <a href="#a51"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj&gt; volatile_mem_functor4&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a52">sigc::mem_fun4</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor4.html">sigc::const_volatile_mem_functor4</a> which wraps a const volatile method. </em> <a href="#a52"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj&gt; volatile_mem_functor5&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a53">sigc::mem_fun5</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor5.html">sigc::const_volatile_mem_functor5</a> which wraps a const volatile method. </em> <a href="#a53"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj&gt; volatile_mem_functor6&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5, T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a54">sigc::mem_fun6</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor6.html">sigc::const_volatile_mem_functor6</a> which wraps a const volatile method. </em> <a href="#a54"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj&gt; volatile_mem_functor7&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5, T_arg6, T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a55">sigc::mem_fun7</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor7.html">sigc::const_volatile_mem_functor7</a> which wraps a const volatile method. </em> <a href="#a55"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_obj, class T_obj2&gt; bound_mem_functor0&lt; T_return,<br>
 T_obj &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a56">sigc::mem_fun0</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor0.html">sigc::bound_mem_functor0</a> which encapsulates a method and an object instance. </em> <a href="#a56"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; bound_mem_functor1&lt; T_return,<br>
 T_obj, T_arg1 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a57">sigc::mem_fun1</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor1.html">sigc::bound_mem_functor1</a> which encapsulates a method and an object instance. </em> <a href="#a57"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2&gt; bound_mem_functor2&lt; T_return,<br>
 T_obj, T_arg1, T_arg2 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a58">sigc::mem_fun2</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor2.html">sigc::bound_mem_functor2</a> which encapsulates a method and an object instance. </em> <a href="#a58"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2&gt; bound_mem_functor3&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a59">sigc::mem_fun3</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor3.html">sigc::bound_mem_functor3</a> which encapsulates a method and an object instance. </em> <a href="#a59"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2&gt; bound_mem_functor4&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a60">sigc::mem_fun4</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor4.html">sigc::bound_mem_functor4</a> which encapsulates a method and an object instance. </em> <a href="#a60"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2&gt; bound_mem_functor5&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a61">sigc::mem_fun5</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor5.html">sigc::bound_mem_functor5</a> which encapsulates a method and an object instance. </em> <a href="#a61"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2&gt; bound_mem_functor6&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5, T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a62">sigc::mem_fun6</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor6.html">sigc::bound_mem_functor6</a> which encapsulates a method and an object instance. </em> <a href="#a62"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2&gt; bound_mem_functor7&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5, T_arg6, T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a63">sigc::mem_fun7</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor7.html">sigc::bound_mem_functor7</a> which encapsulates a method and an object instance. </em> <a href="#a63"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_obj, class T_obj2&gt; bound_const_mem_functor0&lt;<br>
 T_return, T_obj &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a64">sigc::mem_fun0</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)() const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor0.html">sigc::bound_const_mem_functor0</a> which encapsulates a method and an object instance. </em> <a href="#a64"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_obj, class T_obj2&gt; bound_const_mem_functor0&lt;<br>
 T_return, T_obj &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a65">sigc::mem_fun0</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)() const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor0.html">sigc::bound_const_mem_functor0</a> which encapsulates a method and an object instance. </em> <a href="#a65"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; bound_const_mem_functor1&lt;<br>
 T_return, T_obj, T_arg1 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a66">sigc::mem_fun1</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor1.html">sigc::bound_const_mem_functor1</a> which encapsulates a method and an object instance. </em> <a href="#a66"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; bound_const_mem_functor1&lt;<br>
 T_return, T_obj, T_arg1 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a67">sigc::mem_fun1</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor1.html">sigc::bound_const_mem_functor1</a> which encapsulates a method and an object instance. </em> <a href="#a67"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2&gt; bound_const_mem_functor2&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a68">sigc::mem_fun2</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor2.html">sigc::bound_const_mem_functor2</a> which encapsulates a method and an object instance. </em> <a href="#a68"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2&gt; bound_const_mem_functor2&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a69">sigc::mem_fun2</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor2.html">sigc::bound_const_mem_functor2</a> which encapsulates a method and an object instance. </em> <a href="#a69"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2&gt; bound_const_mem_functor3&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a70">sigc::mem_fun3</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor3.html">sigc::bound_const_mem_functor3</a> which encapsulates a method and an object instance. </em> <a href="#a70"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2&gt; bound_const_mem_functor3&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a71">sigc::mem_fun3</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor3.html">sigc::bound_const_mem_functor3</a> which encapsulates a method and an object instance. </em> <a href="#a71"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2&gt; bound_const_mem_functor4&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a72">sigc::mem_fun4</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor4.html">sigc::bound_const_mem_functor4</a> which encapsulates a method and an object instance. </em> <a href="#a72"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2&gt; bound_const_mem_functor4&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a73">sigc::mem_fun4</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor4.html">sigc::bound_const_mem_functor4</a> which encapsulates a method and an object instance. </em> <a href="#a73"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2&gt; bound_const_mem_functor5&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a74">sigc::mem_fun5</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor5.html">sigc::bound_const_mem_functor5</a> which encapsulates a method and an object instance. </em> <a href="#a74"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2&gt; bound_const_mem_functor5&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a75">sigc::mem_fun5</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor5.html">sigc::bound_const_mem_functor5</a> which encapsulates a method and an object instance. </em> <a href="#a75"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2&gt; bound_const_mem_functor6&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a76">sigc::mem_fun6</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor6.html">sigc::bound_const_mem_functor6</a> which encapsulates a method and an object instance. </em> <a href="#a76"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2&gt; bound_const_mem_functor6&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a77">sigc::mem_fun6</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor6.html">sigc::bound_const_mem_functor6</a> which encapsulates a method and an object instance. </em> <a href="#a77"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2&gt; bound_const_mem_functor7&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a78">sigc::mem_fun7</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor7.html">sigc::bound_const_mem_functor7</a> which encapsulates a method and an object instance. </em> <a href="#a78"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2&gt; bound_const_mem_functor7&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a79">sigc::mem_fun7</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor7.html">sigc::bound_const_mem_functor7</a> which encapsulates a method and an object instance. </em> <a href="#a79"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_obj, class T_obj2&gt; bound_volatile_mem_functor0&lt;<br>
 T_return, T_obj &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a80">sigc::mem_fun0</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)() volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">sigc::bound_const_volatile_mem_functor0</a> which encapsulates a method and an object instance. </em> <a href="#a80"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; bound_volatile_mem_functor1&lt;<br>
 T_return, T_obj, T_arg1 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a81">sigc::mem_fun1</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">sigc::bound_const_volatile_mem_functor1</a> which encapsulates a method and an object instance. </em> <a href="#a81"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2&gt; bound_volatile_mem_functor2&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a82">sigc::mem_fun2</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">sigc::bound_const_volatile_mem_functor2</a> which encapsulates a method and an object instance. </em> <a href="#a82"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2&gt; bound_volatile_mem_functor3&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a83">sigc::mem_fun3</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">sigc::bound_const_volatile_mem_functor3</a> which encapsulates a method and an object instance. </em> <a href="#a83"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2&gt; bound_volatile_mem_functor4&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a84">sigc::mem_fun4</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">sigc::bound_const_volatile_mem_functor4</a> which encapsulates a method and an object instance. </em> <a href="#a84"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2&gt; bound_volatile_mem_functor5&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a85">sigc::mem_fun5</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">sigc::bound_const_volatile_mem_functor5</a> which encapsulates a method and an object instance. </em> <a href="#a85"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2&gt; bound_volatile_mem_functor6&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a86">sigc::mem_fun6</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">sigc::bound_const_volatile_mem_functor6</a> which encapsulates a method and an object instance. </em> <a href="#a86"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2&gt; bound_volatile_mem_functor7&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a87">sigc::mem_fun7</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">sigc::bound_const_volatile_mem_functor7</a> which encapsulates a method and an object instance. </em> <a href="#a87"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_obj, class T_obj2&gt; bound_const_volatile_mem_functor0&lt;<br>
 T_return, T_obj &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a88">sigc::mem_fun0</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)() const volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">sigc::bound_const_volatile_mem_functor0</a> which encapsulates a method and an object instance. </em> <a href="#a88"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; bound_const_volatile_mem_functor1&lt;<br>
 T_return, T_obj, T_arg1 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a89">sigc::mem_fun1</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1) const volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">sigc::bound_const_volatile_mem_functor1</a> which encapsulates a method and an object instance. </em> <a href="#a89"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2&gt; bound_const_volatile_mem_functor2&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a90">sigc::mem_fun2</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2) const volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">sigc::bound_const_volatile_mem_functor2</a> which encapsulates a method and an object instance. </em> <a href="#a90"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2&gt; bound_const_volatile_mem_functor3&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a91">sigc::mem_fun3</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3) const volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">sigc::bound_const_volatile_mem_functor3</a> which encapsulates a method and an object instance. </em> <a href="#a91"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2&gt; bound_const_volatile_mem_functor4&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a92">sigc::mem_fun4</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">sigc::bound_const_volatile_mem_functor4</a> which encapsulates a method and an object instance. </em> <a href="#a92"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2&gt; bound_const_volatile_mem_functor5&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a93">sigc::mem_fun5</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">sigc::bound_const_volatile_mem_functor5</a> which encapsulates a method and an object instance. </em> <a href="#a93"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2&gt; bound_const_volatile_mem_functor6&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a94">sigc::mem_fun6</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">sigc::bound_const_volatile_mem_functor6</a> which encapsulates a method and an object instance. </em> <a href="#a94"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2&gt; bound_const_volatile_mem_functor7&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a95">sigc::mem_fun7</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">sigc::bound_const_volatile_mem_functor7</a> which encapsulates a method and an object instance. </em> <a href="#a95"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj&gt; mem_functor0&lt;T_return, T_obj&gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a96">sigc::mem_fun</a> (T_return(T_obj::* _A_func)())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor0.html">sigc::mem_functor0</a> which wraps a method. </em> <a href="#a96"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_return, class T_obj&gt; mem_functor1&lt; T_return, T_obj,<br>
 T_arg1 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a97">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor1.html">sigc::mem_functor1</a> which wraps a method. </em> <a href="#a97"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_return, class T_obj&gt; mem_functor2&lt; T_return, T_obj,<br>
 T_arg1, T_arg2 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a98">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor2.html">sigc::mem_functor2</a> which wraps a method. </em> <a href="#a98"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj&gt; mem_functor3&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a99">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor3.html">sigc::mem_functor3</a> which wraps a method. </em> <a href="#a99"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj&gt; mem_functor4&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a100">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor4.html">sigc::mem_functor4</a> which wraps a method. </em> <a href="#a100"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj&gt; mem_functor5&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a101">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor5.html">sigc::mem_functor5</a> which wraps a method. </em> <a href="#a101"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj&gt; mem_functor6&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5, T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a102">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor6.html">sigc::mem_functor6</a> which wraps a method. </em> <a href="#a102"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj&gt; mem_functor7&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5, T_arg6, T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a103">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor7.html">sigc::mem_functor7</a> which wraps a method. </em> <a href="#a103"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_obj&gt; const_mem_functor0&lt; T_return,<br>
 T_obj &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a104">sigc::mem_fun</a> (T_return(T_obj::* _A_func)() const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor0.html">sigc::const_mem_functor0</a> which wraps a const method. </em> <a href="#a104"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_return, class T_obj&gt; const_mem_functor1&lt; T_return,<br>
 T_obj, T_arg1 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a105">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor1.html">sigc::const_mem_functor1</a> which wraps a const method. </em> <a href="#a105"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_return, class T_obj&gt; const_mem_functor2&lt; T_return,<br>
 T_obj, T_arg1, T_arg2 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a106">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor2.html">sigc::const_mem_functor2</a> which wraps a const method. </em> <a href="#a106"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj&gt; const_mem_functor3&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a107">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor3.html">sigc::const_mem_functor3</a> which wraps a const method. </em> <a href="#a107"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj&gt; const_mem_functor4&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a108">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor4.html">sigc::const_mem_functor4</a> which wraps a const method. </em> <a href="#a108"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj&gt; const_mem_functor5&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a109">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor5.html">sigc::const_mem_functor5</a> which wraps a const method. </em> <a href="#a109"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj&gt; const_mem_functor6&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5, T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a110">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor6.html">sigc::const_mem_functor6</a> which wraps a const method. </em> <a href="#a110"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj&gt; const_mem_functor7&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5, T_arg6, T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a111">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor7.html">sigc::const_mem_functor7</a> which wraps a const method. </em> <a href="#a111"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_obj&gt; volatile_mem_functor0&lt; T_return,<br>
 T_obj &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a112">sigc::mem_fun</a> (T_return(T_obj::* _A_func)() volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor0.html">sigc::const_volatile_mem_functor0</a> which wraps a const volatile method. </em> <a href="#a112"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_return, class T_obj&gt; volatile_mem_functor1&lt; T_return,<br>
 T_obj, T_arg1 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a113">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor1.html">sigc::const_volatile_mem_functor1</a> which wraps a const volatile method. </em> <a href="#a113"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_return, class T_obj&gt; volatile_mem_functor2&lt; T_return,<br>
 T_obj, T_arg1, T_arg2 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a114">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor2.html">sigc::const_volatile_mem_functor2</a> which wraps a const volatile method. </em> <a href="#a114"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj&gt; volatile_mem_functor3&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a115">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor3.html">sigc::const_volatile_mem_functor3</a> which wraps a const volatile method. </em> <a href="#a115"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj&gt; volatile_mem_functor4&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a116">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor4.html">sigc::const_volatile_mem_functor4</a> which wraps a const volatile method. </em> <a href="#a116"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj&gt; volatile_mem_functor5&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a117">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor5.html">sigc::const_volatile_mem_functor5</a> which wraps a const volatile method. </em> <a href="#a117"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj&gt; volatile_mem_functor6&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5, T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a118">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor6.html">sigc::const_volatile_mem_functor6</a> which wraps a const volatile method. </em> <a href="#a118"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj&gt; volatile_mem_functor7&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5, T_arg6, T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a119">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor7.html">sigc::const_volatile_mem_functor7</a> which wraps a const volatile method. </em> <a href="#a119"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_obj, class T_obj2&gt; bound_mem_functor0&lt; T_return,<br>
 T_obj &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a120">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor0.html">sigc::bound_mem_functor0</a> which encapsulates a method and an object instance. </em> <a href="#a120"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; bound_mem_functor1&lt; T_return,<br>
 T_obj, T_arg1 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a121">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor1.html">sigc::bound_mem_functor1</a> which encapsulates a method and an object instance. </em> <a href="#a121"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2&gt; bound_mem_functor2&lt; T_return,<br>
 T_obj, T_arg1, T_arg2 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a122">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor2.html">sigc::bound_mem_functor2</a> which encapsulates a method and an object instance. </em> <a href="#a122"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2&gt; bound_mem_functor3&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a123">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor3.html">sigc::bound_mem_functor3</a> which encapsulates a method and an object instance. </em> <a href="#a123"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2&gt; bound_mem_functor4&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a124">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor4.html">sigc::bound_mem_functor4</a> which encapsulates a method and an object instance. </em> <a href="#a124"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2&gt; bound_mem_functor5&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a125">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor5.html">sigc::bound_mem_functor5</a> which encapsulates a method and an object instance. </em> <a href="#a125"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2&gt; bound_mem_functor6&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5, T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a126">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor6.html">sigc::bound_mem_functor6</a> which encapsulates a method and an object instance. </em> <a href="#a126"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2&gt; bound_mem_functor7&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5, T_arg6, T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a127">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor7.html">sigc::bound_mem_functor7</a> which encapsulates a method and an object instance. </em> <a href="#a127"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_obj, class T_obj2&gt; bound_const_mem_functor0&lt;<br>
 T_return, T_obj &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a128">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)() const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor0.html">sigc::bound_const_mem_functor0</a> which encapsulates a method and an object instance. </em> <a href="#a128"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_obj, class T_obj2&gt; bound_const_mem_functor0&lt;<br>
 T_return, T_obj &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a129">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)() const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor0.html">sigc::bound_const_mem_functor0</a> which encapsulates a method and an object instance. </em> <a href="#a129"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; bound_const_mem_functor1&lt;<br>
 T_return, T_obj, T_arg1 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a130">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor1.html">sigc::bound_const_mem_functor1</a> which encapsulates a method and an object instance. </em> <a href="#a130"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; bound_const_mem_functor1&lt;<br>
 T_return, T_obj, T_arg1 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a131">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor1.html">sigc::bound_const_mem_functor1</a> which encapsulates a method and an object instance. </em> <a href="#a131"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2&gt; bound_const_mem_functor2&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a132">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor2.html">sigc::bound_const_mem_functor2</a> which encapsulates a method and an object instance. </em> <a href="#a132"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2&gt; bound_const_mem_functor2&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a133">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor2.html">sigc::bound_const_mem_functor2</a> which encapsulates a method and an object instance. </em> <a href="#a133"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2&gt; bound_const_mem_functor3&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a134">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor3.html">sigc::bound_const_mem_functor3</a> which encapsulates a method and an object instance. </em> <a href="#a134"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2&gt; bound_const_mem_functor3&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a135">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor3.html">sigc::bound_const_mem_functor3</a> which encapsulates a method and an object instance. </em> <a href="#a135"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2&gt; bound_const_mem_functor4&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a136">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor4.html">sigc::bound_const_mem_functor4</a> which encapsulates a method and an object instance. </em> <a href="#a136"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2&gt; bound_const_mem_functor4&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a137">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor4.html">sigc::bound_const_mem_functor4</a> which encapsulates a method and an object instance. </em> <a href="#a137"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2&gt; bound_const_mem_functor5&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a138">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor5.html">sigc::bound_const_mem_functor5</a> which encapsulates a method and an object instance. </em> <a href="#a138"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2&gt; bound_const_mem_functor5&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a139">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor5.html">sigc::bound_const_mem_functor5</a> which encapsulates a method and an object instance. </em> <a href="#a139"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2&gt; bound_const_mem_functor6&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a140">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor6.html">sigc::bound_const_mem_functor6</a> which encapsulates a method and an object instance. </em> <a href="#a140"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2&gt; bound_const_mem_functor6&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a141">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor6.html">sigc::bound_const_mem_functor6</a> which encapsulates a method and an object instance. </em> <a href="#a141"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2&gt; bound_const_mem_functor7&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a142">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor7.html">sigc::bound_const_mem_functor7</a> which encapsulates a method and an object instance. </em> <a href="#a142"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2&gt; bound_const_mem_functor7&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a143">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor7.html">sigc::bound_const_mem_functor7</a> which encapsulates a method and an object instance. </em> <a href="#a143"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_obj, class T_obj2&gt; bound_volatile_mem_functor0&lt;<br>
 T_return, T_obj &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a144">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)() volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">sigc::bound_const_volatile_mem_functor0</a> which encapsulates a method and an object instance. </em> <a href="#a144"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; bound_volatile_mem_functor1&lt;<br>
 T_return, T_obj, T_arg1 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a145">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">sigc::bound_const_volatile_mem_functor1</a> which encapsulates a method and an object instance. </em> <a href="#a145"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2&gt; bound_volatile_mem_functor2&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a146">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">sigc::bound_const_volatile_mem_functor2</a> which encapsulates a method and an object instance. </em> <a href="#a146"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2&gt; bound_volatile_mem_functor3&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a147">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">sigc::bound_const_volatile_mem_functor3</a> which encapsulates a method and an object instance. </em> <a href="#a147"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2&gt; bound_volatile_mem_functor4&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a148">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">sigc::bound_const_volatile_mem_functor4</a> which encapsulates a method and an object instance. </em> <a href="#a148"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2&gt; bound_volatile_mem_functor5&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a149">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">sigc::bound_const_volatile_mem_functor5</a> which encapsulates a method and an object instance. </em> <a href="#a149"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2&gt; bound_volatile_mem_functor6&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a150">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">sigc::bound_const_volatile_mem_functor6</a> which encapsulates a method and an object instance. </em> <a href="#a150"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2&gt; bound_volatile_mem_functor7&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a151">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">sigc::bound_const_volatile_mem_functor7</a> which encapsulates a method and an object instance. </em> <a href="#a151"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_obj, class T_obj2&gt; bound_const_volatile_mem_functor0&lt;<br>
 T_return, T_obj &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a152">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)() const volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">sigc::bound_const_volatile_mem_functor0</a> which encapsulates a method and an object instance. </em> <a href="#a152"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; bound_const_volatile_mem_functor1&lt;<br>
 T_return, T_obj, T_arg1 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a153">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1) const volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">sigc::bound_const_volatile_mem_functor1</a> which encapsulates a method and an object instance. </em> <a href="#a153"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2&gt; bound_const_volatile_mem_functor2&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a154">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2) const volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">sigc::bound_const_volatile_mem_functor2</a> which encapsulates a method and an object instance. </em> <a href="#a154"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2&gt; bound_const_volatile_mem_functor3&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a155">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3) const volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">sigc::bound_const_volatile_mem_functor3</a> which encapsulates a method and an object instance. </em> <a href="#a155"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2&gt; bound_const_volatile_mem_functor4&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a156">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">sigc::bound_const_volatile_mem_functor4</a> which encapsulates a method and an object instance. </em> <a href="#a156"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2&gt; bound_const_volatile_mem_functor5&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a157">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">sigc::bound_const_volatile_mem_functor5</a> which encapsulates a method and an object instance. </em> <a href="#a157"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2&gt; bound_const_volatile_mem_functor6&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a158">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">sigc::bound_const_volatile_mem_functor6</a> which encapsulates a method and an object instance. </em> <a href="#a158"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2&gt; bound_const_volatile_mem_functor7&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a159">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">sigc::bound_const_volatile_mem_functor7</a> which encapsulates a method and an object instance. </em> <a href="#a159"></a><em><br><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<a class="el" href="group__mem__fun.html#a159">mem_fun()</a> is used to convert a pointer to a method to a functor. 
<p>
Optionally a reference or pointer to an object can be bound to the functor. Note that only if the object type inherits from <a class="el" href="structsigc_1_1trackable.html">sigc::trackable</a> the slot is cleared automatically when the object goes out of scope!<p>
If the member function pointer is to an overloaded type, you must specify the types using template arguments starting with the first argument. It is not necessary to supply the return type.<p>
<dl compact><dt><b>Example:</b></dt><dd><div class="fragment"><pre>   <span class="keyword">struct </span>foo : <span class="keyword">public</span> sigc::trackable
   {
     <span class="keywordtype">void</span> bar(<span class="keywordtype">int</span>) {}
   };
   foo my_foo;
   <a class="code" href="classsigc_1_1slot.html">sigc::slot&lt;void, int&gt;</a> sl = <a class="code" href="group__mem__fun.html#a96">sigc::mem_fun</a>(my_foo, &amp;foo::bar);
</pre></div></dd></dl>
For const methods <a class="el" href="group__mem__fun.html#a159">mem_fun()</a> takes a const reference or pointer to an object.<p>
<dl compact><dt><b>Example:</b></dt><dd><div class="fragment"><pre>   <span class="keyword">struct </span>foo : <span class="keyword">public</span> sigc::trackable
   {
     <span class="keywordtype">void</span> bar(<span class="keywordtype">int</span>)<span class="keyword"> const </span>{}
   };
   <span class="keyword">const</span> foo my_foo;
   <a class="code" href="classsigc_1_1slot.html">sigc::slot&lt;void, int&gt;</a> sl = <a class="code" href="group__mem__fun.html#a96">sigc::mem_fun</a>(my_foo, &amp;foo::bar);
</pre></div></dd></dl>
Use mem_fun#() if there is an abiguity as to the number of arguments.<p>
<dl compact><dt><b>Example:</b></dt><dd><div class="fragment"><pre>   <span class="keyword">struct </span>foo : <span class="keyword">public</span> sigc::trackable
   {
     <span class="keywordtype">void</span> bar(<span class="keywordtype">int</span>) {}
     <span class="keywordtype">void</span> bar(<span class="keywordtype">float</span>) {}
     <span class="keywordtype">void</span> bar(<span class="keywordtype">int</span>, <span class="keywordtype">int</span>) {}
   };
   foo my_foo;
   <a class="code" href="classsigc_1_1slot.html">sigc::slot&lt;void, int&gt;</a> sl = sigc::mem_fun1&lt;int&gt;(my_foo, &amp;foo::bar);
</pre></div></dd></dl>
<hr><h2>Function Documentation</h2>
<a name="a159" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_volatile_mem_functor7&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7&gt; mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">sigc::bound_const_volatile_mem_functor7</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a158" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_volatile_mem_functor6&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6&gt; mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">sigc::bound_const_volatile_mem_functor6</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a157" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_volatile_mem_functor5&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5&gt; mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">sigc::bound_const_volatile_mem_functor5</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a156" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_volatile_mem_functor4&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4&gt; mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4) const volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">sigc::bound_const_volatile_mem_functor4</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a155" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_volatile_mem_functor3&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3&gt; mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3) const volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">sigc::bound_const_volatile_mem_functor3</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a154" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_volatile_mem_functor2&lt;T_return, T_obj, T_arg1,T_arg2&gt; mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2) const volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">sigc::bound_const_volatile_mem_functor2</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a153" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_volatile_mem_functor1&lt;T_return, T_obj, T_arg1&gt; mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1) const volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">sigc::bound_const_volatile_mem_functor1</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a152" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_volatile_mem_functor0&lt;T_return, T_obj&gt; mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)() const volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">sigc::bound_const_volatile_mem_functor0</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a151" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_volatile_mem_functor7&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt; sigc::mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">sigc::bound_const_volatile_mem_functor7</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>
/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) volatile) { return bound_volatile_mem_functor7&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7&gt;(_A_obj, _A_func); }<p>
template &lt;class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj, class T_obj2&gt; inline bound_volatile_mem_functor7&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7&gt; mem_fun(/* </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a150" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_volatile_mem_functor6&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt; sigc::mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">sigc::bound_const_volatile_mem_functor6</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>
/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) volatile) { return bound_volatile_mem_functor6&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6&gt;(_A_obj, _A_func); }<p>
template &lt;class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj, class T_obj2&gt; inline bound_volatile_mem_functor6&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6&gt; mem_fun(/* </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a149" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_volatile_mem_functor5&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt; sigc::mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">sigc::bound_const_volatile_mem_functor5</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>
/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) volatile) { return bound_volatile_mem_functor5&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5&gt;(_A_obj, _A_func); }<p>
template &lt;class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj, class T_obj2&gt; inline bound_volatile_mem_functor5&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5&gt; mem_fun(/* </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a148" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_volatile_mem_functor4&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt; sigc::mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4) volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">sigc::bound_const_volatile_mem_functor4</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>
/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) volatile) { return bound_volatile_mem_functor4&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4&gt;(_A_obj, _A_func); }<p>
template &lt;class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj, class T_obj2&gt; inline bound_volatile_mem_functor4&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4&gt; mem_fun(/* </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a147" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_volatile_mem_functor3&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt; sigc::mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3) volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">sigc::bound_const_volatile_mem_functor3</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>
/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3) volatile) { return bound_volatile_mem_functor3&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3&gt;(_A_obj, _A_func); }<p>
template &lt;class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj, class T_obj2&gt; inline bound_volatile_mem_functor3&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3&gt; mem_fun(/* </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a146" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_volatile_mem_functor2&lt;T_return, T_obj, T_arg1, T_arg2&gt; sigc::mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2) volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">sigc::bound_const_volatile_mem_functor2</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>
/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2) volatile) { return bound_volatile_mem_functor2&lt;T_return, T_obj, T_arg1,T_arg2&gt;(_A_obj, _A_func); }<p>
template &lt;class T_arg1,class T_arg2, class T_return, class T_obj, class T_obj2&gt; inline bound_volatile_mem_functor2&lt;T_return, T_obj, T_arg1,T_arg2&gt; mem_fun(/* </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a145" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_volatile_mem_functor1&lt;T_return, T_obj, T_arg1&gt; sigc::mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1) volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">sigc::bound_const_volatile_mem_functor1</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>
/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1) volatile) { return bound_volatile_mem_functor1&lt;T_return, T_obj, T_arg1&gt;(_A_obj, _A_func); }<p>
template &lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; inline bound_volatile_mem_functor1&lt;T_return, T_obj, T_arg1&gt; mem_fun(/* </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a144" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_volatile_mem_functor0&lt;T_return, T_obj&gt; sigc::mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)() volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">sigc::bound_const_volatile_mem_functor0</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>
/ T_obj* _A_obj, T_return (T_obj2::*_A_func)() volatile) { return bound_volatile_mem_functor0&lt;T_return, T_obj&gt;(_A_obj, _A_func); }<p>
template &lt;class T_return, class T_obj, class T_obj2&gt; inline bound_volatile_mem_functor0&lt;T_return, T_obj&gt; mem_fun(/* </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a143" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_mem_functor7&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7&gt; mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor7.html">sigc::bound_const_mem_functor7</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a142" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_mem_functor7&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7&gt; mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor7.html">sigc::bound_const_mem_functor7</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a141" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_mem_functor6&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6&gt; mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor6.html">sigc::bound_const_mem_functor6</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a140" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_mem_functor6&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6&gt; mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor6.html">sigc::bound_const_mem_functor6</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a139" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_mem_functor5&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5&gt; mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor5.html">sigc::bound_const_mem_functor5</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a138" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_mem_functor5&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5&gt; mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor5.html">sigc::bound_const_mem_functor5</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a137" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_mem_functor4&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4&gt; mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4) const</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor4.html">sigc::bound_const_mem_functor4</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a136" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_mem_functor4&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4&gt; mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4) const</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor4.html">sigc::bound_const_mem_functor4</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a135" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_mem_functor3&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3&gt; mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3) const</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor3.html">sigc::bound_const_mem_functor3</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a134" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_mem_functor3&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3&gt; mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3) const</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor3.html">sigc::bound_const_mem_functor3</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a133" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_mem_functor2&lt;T_return, T_obj, T_arg1,T_arg2&gt; mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2) const</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor2.html">sigc::bound_const_mem_functor2</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a132" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_mem_functor2&lt;T_return, T_obj, T_arg1,T_arg2&gt; mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2) const</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor2.html">sigc::bound_const_mem_functor2</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a131" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_mem_functor1&lt;T_return, T_obj, T_arg1&gt; mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1) const</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor1.html">sigc::bound_const_mem_functor1</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a130" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_mem_functor1&lt;T_return, T_obj, T_arg1&gt; mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1) const</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor1.html">sigc::bound_const_mem_functor1</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a129" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_mem_functor0&lt;T_return, T_obj&gt; mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)() const</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor0.html">sigc::bound_const_mem_functor0</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a128" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_mem_functor0&lt;T_return, T_obj&gt; mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)() const</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor0.html">sigc::bound_const_mem_functor0</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a127" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_mem_functor7&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7&gt; mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7)</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor7.html">sigc::bound_mem_functor7</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>
/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) ) { return bound_mem_functor7&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7&gt;(_A_obj, _A_func); }<p>
template &lt;class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj, class T_obj2&gt; inline bound_mem_functor7&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7&gt; mem_fun(/* </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a126" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_mem_functor6&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6&gt; mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6)</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor6.html">sigc::bound_mem_functor6</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>
/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) ) { return bound_mem_functor6&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6&gt;(_A_obj, _A_func); }<p>
template &lt;class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj, class T_obj2&gt; inline bound_mem_functor6&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6&gt; mem_fun(/* </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a125" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_mem_functor5&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5&gt; mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5)</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor5.html">sigc::bound_mem_functor5</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>
/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) ) { return bound_mem_functor5&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5&gt;(_A_obj, _A_func); }<p>
template &lt;class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj, class T_obj2&gt; inline bound_mem_functor5&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5&gt; mem_fun(/* </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a124" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_mem_functor4&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4&gt; mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4)</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor4.html">sigc::bound_mem_functor4</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>
/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) ) { return bound_mem_functor4&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4&gt;(_A_obj, _A_func); }<p>
template &lt;class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj, class T_obj2&gt; inline bound_mem_functor4&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4&gt; mem_fun(/* </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a123" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_mem_functor3&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3&gt; mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3)</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor3.html">sigc::bound_mem_functor3</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>
/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3) ) { return bound_mem_functor3&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3&gt;(_A_obj, _A_func); }<p>
template &lt;class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj, class T_obj2&gt; inline bound_mem_functor3&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3&gt; mem_fun(/* </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a122" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_mem_functor2&lt;T_return, T_obj, T_arg1,T_arg2&gt; mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2)</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor2.html">sigc::bound_mem_functor2</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>
/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2) ) { return bound_mem_functor2&lt;T_return, T_obj, T_arg1,T_arg2&gt;(_A_obj, _A_func); }<p>
template &lt;class T_arg1,class T_arg2, class T_return, class T_obj, class T_obj2&gt; inline bound_mem_functor2&lt;T_return, T_obj, T_arg1,T_arg2&gt; mem_fun(/* </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a121" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_mem_functor1&lt;T_return, T_obj, T_arg1&gt; mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1)</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor1.html">sigc::bound_mem_functor1</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>
/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1) ) { return bound_mem_functor1&lt;T_return, T_obj, T_arg1&gt;(_A_obj, _A_func); }<p>
template &lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; inline bound_mem_functor1&lt;T_return, T_obj, T_arg1&gt; mem_fun(/* </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a120" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_mem_functor0&lt;T_return, T_obj&gt; mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)()</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor0.html">sigc::bound_mem_functor0</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>
/ T_obj* _A_obj, T_return (T_obj2::*_A_func)() ) { return bound_mem_functor0&lt;T_return, T_obj&gt;(_A_obj, _A_func); }<p>
template &lt;class T_return, class T_obj, class T_obj2&gt; inline bound_mem_functor0&lt;T_return, T_obj&gt; mem_fun(/* </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a119" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> const_volatile_mem_functor7&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt; sigc::mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) volatile          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor7.html">sigc::const_volatile_mem_functor7</a> which wraps a const volatile method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a118" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> const_volatile_mem_functor6&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt; sigc::mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) volatile          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor6.html">sigc::const_volatile_mem_functor6</a> which wraps a const volatile method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a117" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> const_volatile_mem_functor5&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt; sigc::mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) volatile          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor5.html">sigc::const_volatile_mem_functor5</a> which wraps a const volatile method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a116" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> const_volatile_mem_functor4&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt; sigc::mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4) volatile          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor4.html">sigc::const_volatile_mem_functor4</a> which wraps a const volatile method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a115" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> const_volatile_mem_functor3&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt; sigc::mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3) volatile          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor3.html">sigc::const_volatile_mem_functor3</a> which wraps a const volatile method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a114" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> const_volatile_mem_functor2&lt;T_return, T_obj, T_arg1, T_arg2&gt; sigc::mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2) volatile          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor2.html">sigc::const_volatile_mem_functor2</a> which wraps a const volatile method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a113" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> const_volatile_mem_functor1&lt;T_return, T_obj, T_arg1&gt; sigc::mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1) volatile          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor1.html">sigc::const_volatile_mem_functor1</a> which wraps a const volatile method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a112" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> const_volatile_mem_functor0&lt;T_return, T_obj&gt; sigc::mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)() volatile          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor0.html">sigc::const_volatile_mem_functor0</a> which wraps a const volatile method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a111" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> const_mem_functor7&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7&gt; mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor7.html">sigc::const_mem_functor7</a> which wraps a const method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a110" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> const_mem_functor6&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6&gt; mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor6.html">sigc::const_mem_functor6</a> which wraps a const method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a109" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> const_mem_functor5&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5&gt; mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor5.html">sigc::const_mem_functor5</a> which wraps a const method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a108" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> const_mem_functor4&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4&gt; mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4) const          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor4.html">sigc::const_mem_functor4</a> which wraps a const method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a107" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> const_mem_functor3&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3&gt; mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3) const          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor3.html">sigc::const_mem_functor3</a> which wraps a const method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a106" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> const_mem_functor2&lt;T_return, T_obj, T_arg1,T_arg2&gt; mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2) const          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor2.html">sigc::const_mem_functor2</a> which wraps a const method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a105" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> const_mem_functor1&lt;T_return, T_obj, T_arg1&gt; mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1) const          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor1.html">sigc::const_mem_functor1</a> which wraps a const method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a104" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> const_mem_functor0&lt;T_return, T_obj&gt; mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)() const          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor0.html">sigc::const_mem_functor0</a> which wraps a const method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a103" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> mem_functor7&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7&gt; mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7)          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1mem__functor7.html">sigc::mem_functor7</a> which wraps a method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a102" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> mem_functor6&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6&gt; mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6)          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1mem__functor6.html">sigc::mem_functor6</a> which wraps a method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a101" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> mem_functor5&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5&gt; mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5)          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1mem__functor5.html">sigc::mem_functor5</a> which wraps a method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a100" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> mem_functor4&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4&gt; mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4)          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1mem__functor4.html">sigc::mem_functor4</a> which wraps a method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a99" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> mem_functor3&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3&gt; mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3)          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1mem__functor3.html">sigc::mem_functor3</a> which wraps a method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a98" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> mem_functor2&lt;T_return, T_obj, T_arg1,T_arg2&gt; mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2)          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1mem__functor2.html">sigc::mem_functor2</a> which wraps a method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a97" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> mem_functor1&lt;T_return, T_obj, T_arg1&gt; mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1)          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1mem__functor1.html">sigc::mem_functor1</a> which wraps a method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a96" doxytag="sigc::mem_fun"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> mem_functor0&lt;T_return, T_obj&gt; mem_fun </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)()          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1mem__functor0.html">sigc::mem_functor0</a> which wraps a method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a88" doxytag="sigc::mem_fun0"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_volatile_mem_functor0&lt;T_return, T_obj&gt; mem_fun0 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)() const volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">sigc::bound_const_volatile_mem_functor0</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a80" doxytag="sigc::mem_fun0"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_volatile_mem_functor0&lt;T_return, T_obj&gt; sigc::mem_fun0 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)() volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">sigc::bound_const_volatile_mem_functor0</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>
/ T_obj* _A_obj, T_return (T_obj2::*_A_func)() volatile) { return bound_volatile_mem_functor0&lt;T_return, T_obj&gt;(_A_obj, _A_func); }<p>
template &lt;class T_return, class T_obj, class T_obj2&gt; inline bound_volatile_mem_functor0&lt;T_return, T_obj&gt; mem_fun0(/* </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a65" doxytag="sigc::mem_fun0"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_mem_functor0&lt;T_return, T_obj&gt; mem_fun0 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)() const</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor0.html">sigc::bound_const_mem_functor0</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a64" doxytag="sigc::mem_fun0"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_mem_functor0&lt;T_return, T_obj&gt; mem_fun0 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)() const</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor0.html">sigc::bound_const_mem_functor0</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a56" doxytag="sigc::mem_fun0"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_mem_functor0&lt;T_return, T_obj&gt; mem_fun0 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)()</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor0.html">sigc::bound_mem_functor0</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>
/ T_obj* _A_obj, T_return (T_obj2::*_A_func)() ) { return bound_mem_functor0&lt;T_return, T_obj&gt;(_A_obj, _A_func); }<p>
template &lt;class T_return, class T_obj, class T_obj2&gt; inline bound_mem_functor0&lt;T_return, T_obj&gt; mem_fun0(/* </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a48" doxytag="sigc::mem_fun0"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> const_volatile_mem_functor0&lt;T_return, T_obj&gt; sigc::mem_fun0 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)() volatile          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor0.html">sigc::const_volatile_mem_functor0</a> which wraps a const volatile method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a40" doxytag="sigc::mem_fun0"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> const_mem_functor0&lt;T_return, T_obj&gt; mem_fun0 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)() const          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor0.html">sigc::const_mem_functor0</a> which wraps a const method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a32" doxytag="sigc::mem_fun0"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> mem_functor0&lt;T_return, T_obj&gt; mem_fun0 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)()          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1mem__functor0.html">sigc::mem_functor0</a> which wraps a method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a89" doxytag="sigc::mem_fun1"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_volatile_mem_functor1&lt;T_return, T_obj, T_arg1&gt; mem_fun1 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1) const volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">sigc::bound_const_volatile_mem_functor1</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a81" doxytag="sigc::mem_fun1"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_volatile_mem_functor1&lt;T_return, T_obj, T_arg1&gt; sigc::mem_fun1 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1) volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">sigc::bound_const_volatile_mem_functor1</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>
/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1) volatile) { return bound_volatile_mem_functor1&lt;T_return, T_obj, T_arg1&gt;(_A_obj, _A_func); }<p>
template &lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; inline bound_volatile_mem_functor1&lt;T_return, T_obj, T_arg1&gt; mem_fun1(/* </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a67" doxytag="sigc::mem_fun1"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_mem_functor1&lt;T_return, T_obj, T_arg1&gt; mem_fun1 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1) const</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor1.html">sigc::bound_const_mem_functor1</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a66" doxytag="sigc::mem_fun1"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_mem_functor1&lt;T_return, T_obj, T_arg1&gt; mem_fun1 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1) const</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor1.html">sigc::bound_const_mem_functor1</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a57" doxytag="sigc::mem_fun1"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_mem_functor1&lt;T_return, T_obj, T_arg1&gt; mem_fun1 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1)</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor1.html">sigc::bound_mem_functor1</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>
/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1) ) { return bound_mem_functor1&lt;T_return, T_obj, T_arg1&gt;(_A_obj, _A_func); }<p>
template &lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; inline bound_mem_functor1&lt;T_return, T_obj, T_arg1&gt; mem_fun1(/* </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a49" doxytag="sigc::mem_fun1"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> const_volatile_mem_functor1&lt;T_return, T_obj, T_arg1&gt; sigc::mem_fun1 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1) volatile          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor1.html">sigc::const_volatile_mem_functor1</a> which wraps a const volatile method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a41" doxytag="sigc::mem_fun1"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> const_mem_functor1&lt;T_return, T_obj, T_arg1&gt; mem_fun1 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1) const          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor1.html">sigc::const_mem_functor1</a> which wraps a const method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a33" doxytag="sigc::mem_fun1"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> mem_functor1&lt;T_return, T_obj, T_arg1&gt; mem_fun1 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1)          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1mem__functor1.html">sigc::mem_functor1</a> which wraps a method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a90" doxytag="sigc::mem_fun2"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_volatile_mem_functor2&lt;T_return, T_obj, T_arg1,T_arg2&gt; mem_fun2 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2) const volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">sigc::bound_const_volatile_mem_functor2</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a82" doxytag="sigc::mem_fun2"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_volatile_mem_functor2&lt;T_return, T_obj, T_arg1, T_arg2&gt; sigc::mem_fun2 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2) volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">sigc::bound_const_volatile_mem_functor2</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>
/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2) volatile) { return bound_volatile_mem_functor2&lt;T_return, T_obj, T_arg1,T_arg2&gt;(_A_obj, _A_func); }<p>
template &lt;class T_arg1,class T_arg2, class T_return, class T_obj, class T_obj2&gt; inline bound_volatile_mem_functor2&lt;T_return, T_obj, T_arg1,T_arg2&gt; mem_fun2(/* </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a69" doxytag="sigc::mem_fun2"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_mem_functor2&lt;T_return, T_obj, T_arg1,T_arg2&gt; mem_fun2 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2) const</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor2.html">sigc::bound_const_mem_functor2</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a68" doxytag="sigc::mem_fun2"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_mem_functor2&lt;T_return, T_obj, T_arg1,T_arg2&gt; mem_fun2 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2) const</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor2.html">sigc::bound_const_mem_functor2</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a58" doxytag="sigc::mem_fun2"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_mem_functor2&lt;T_return, T_obj, T_arg1,T_arg2&gt; mem_fun2 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2)</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor2.html">sigc::bound_mem_functor2</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>
/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2) ) { return bound_mem_functor2&lt;T_return, T_obj, T_arg1,T_arg2&gt;(_A_obj, _A_func); }<p>
template &lt;class T_arg1,class T_arg2, class T_return, class T_obj, class T_obj2&gt; inline bound_mem_functor2&lt;T_return, T_obj, T_arg1,T_arg2&gt; mem_fun2(/* </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a50" doxytag="sigc::mem_fun2"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> const_volatile_mem_functor2&lt;T_return, T_obj, T_arg1, T_arg2&gt; sigc::mem_fun2 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2) volatile          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor2.html">sigc::const_volatile_mem_functor2</a> which wraps a const volatile method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a42" doxytag="sigc::mem_fun2"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> const_mem_functor2&lt;T_return, T_obj, T_arg1,T_arg2&gt; mem_fun2 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2) const          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor2.html">sigc::const_mem_functor2</a> which wraps a const method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a34" doxytag="sigc::mem_fun2"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> mem_functor2&lt;T_return, T_obj, T_arg1,T_arg2&gt; mem_fun2 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2)          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1mem__functor2.html">sigc::mem_functor2</a> which wraps a method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a91" doxytag="sigc::mem_fun3"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_volatile_mem_functor3&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3&gt; mem_fun3 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3) const volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">sigc::bound_const_volatile_mem_functor3</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a83" doxytag="sigc::mem_fun3"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_volatile_mem_functor3&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt; sigc::mem_fun3 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3) volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">sigc::bound_const_volatile_mem_functor3</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>
/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3) volatile) { return bound_volatile_mem_functor3&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3&gt;(_A_obj, _A_func); }<p>
template &lt;class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj, class T_obj2&gt; inline bound_volatile_mem_functor3&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3&gt; mem_fun3(/* </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a71" doxytag="sigc::mem_fun3"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_mem_functor3&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3&gt; mem_fun3 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3) const</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor3.html">sigc::bound_const_mem_functor3</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a70" doxytag="sigc::mem_fun3"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_mem_functor3&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3&gt; mem_fun3 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3) const</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor3.html">sigc::bound_const_mem_functor3</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a59" doxytag="sigc::mem_fun3"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_mem_functor3&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3&gt; mem_fun3 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3)</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor3.html">sigc::bound_mem_functor3</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>
/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3) ) { return bound_mem_functor3&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3&gt;(_A_obj, _A_func); }<p>
template &lt;class T_arg1,class T_arg2,class T_arg3, class T_return, class T_obj, class T_obj2&gt; inline bound_mem_functor3&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3&gt; mem_fun3(/* </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a51" doxytag="sigc::mem_fun3"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> const_volatile_mem_functor3&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt; sigc::mem_fun3 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3) volatile          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor3.html">sigc::const_volatile_mem_functor3</a> which wraps a const volatile method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a43" doxytag="sigc::mem_fun3"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> const_mem_functor3&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3&gt; mem_fun3 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3) const          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor3.html">sigc::const_mem_functor3</a> which wraps a const method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a35" doxytag="sigc::mem_fun3"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> mem_functor3&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3&gt; mem_fun3 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3)          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1mem__functor3.html">sigc::mem_functor3</a> which wraps a method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a92" doxytag="sigc::mem_fun4"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_volatile_mem_functor4&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4&gt; mem_fun4 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4) const volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">sigc::bound_const_volatile_mem_functor4</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a84" doxytag="sigc::mem_fun4"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_volatile_mem_functor4&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt; sigc::mem_fun4 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4) volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">sigc::bound_const_volatile_mem_functor4</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>
/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) volatile) { return bound_volatile_mem_functor4&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4&gt;(_A_obj, _A_func); }<p>
template &lt;class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj, class T_obj2&gt; inline bound_volatile_mem_functor4&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4&gt; mem_fun4(/* </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a73" doxytag="sigc::mem_fun4"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_mem_functor4&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4&gt; mem_fun4 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4) const</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor4.html">sigc::bound_const_mem_functor4</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a72" doxytag="sigc::mem_fun4"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_mem_functor4&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4&gt; mem_fun4 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4) const</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor4.html">sigc::bound_const_mem_functor4</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a60" doxytag="sigc::mem_fun4"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_mem_functor4&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4&gt; mem_fun4 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4)</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor4.html">sigc::bound_mem_functor4</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>
/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4) ) { return bound_mem_functor4&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4&gt;(_A_obj, _A_func); }<p>
template &lt;class T_arg1,class T_arg2,class T_arg3,class T_arg4, class T_return, class T_obj, class T_obj2&gt; inline bound_mem_functor4&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4&gt; mem_fun4(/* </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a52" doxytag="sigc::mem_fun4"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> const_volatile_mem_functor4&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt; sigc::mem_fun4 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4) volatile          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor4.html">sigc::const_volatile_mem_functor4</a> which wraps a const volatile method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a44" doxytag="sigc::mem_fun4"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> const_mem_functor4&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4&gt; mem_fun4 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4) const          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor4.html">sigc::const_mem_functor4</a> which wraps a const method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a36" doxytag="sigc::mem_fun4"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> mem_functor4&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4&gt; mem_fun4 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4)          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1mem__functor4.html">sigc::mem_functor4</a> which wraps a method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a93" doxytag="sigc::mem_fun5"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_volatile_mem_functor5&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5&gt; mem_fun5 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">sigc::bound_const_volatile_mem_functor5</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a85" doxytag="sigc::mem_fun5"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_volatile_mem_functor5&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt; sigc::mem_fun5 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">sigc::bound_const_volatile_mem_functor5</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>
/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) volatile) { return bound_volatile_mem_functor5&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5&gt;(_A_obj, _A_func); }<p>
template &lt;class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj, class T_obj2&gt; inline bound_volatile_mem_functor5&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5&gt; mem_fun5(/* </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a75" doxytag="sigc::mem_fun5"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_mem_functor5&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5&gt; mem_fun5 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor5.html">sigc::bound_const_mem_functor5</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a74" doxytag="sigc::mem_fun5"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_mem_functor5&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5&gt; mem_fun5 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor5.html">sigc::bound_const_mem_functor5</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a61" doxytag="sigc::mem_fun5"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_mem_functor5&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5&gt; mem_fun5 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5)</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor5.html">sigc::bound_mem_functor5</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>
/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5) ) { return bound_mem_functor5&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5&gt;(_A_obj, _A_func); }<p>
template &lt;class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5, class T_return, class T_obj, class T_obj2&gt; inline bound_mem_functor5&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5&gt; mem_fun5(/* </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a53" doxytag="sigc::mem_fun5"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> const_volatile_mem_functor5&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt; sigc::mem_fun5 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) volatile          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor5.html">sigc::const_volatile_mem_functor5</a> which wraps a const volatile method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a45" doxytag="sigc::mem_fun5"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> const_mem_functor5&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5&gt; mem_fun5 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor5.html">sigc::const_mem_functor5</a> which wraps a const method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a37" doxytag="sigc::mem_fun5"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> mem_functor5&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5&gt; mem_fun5 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5)          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1mem__functor5.html">sigc::mem_functor5</a> which wraps a method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a94" doxytag="sigc::mem_fun6"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_volatile_mem_functor6&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6&gt; mem_fun6 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">sigc::bound_const_volatile_mem_functor6</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a86" doxytag="sigc::mem_fun6"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_volatile_mem_functor6&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt; sigc::mem_fun6 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">sigc::bound_const_volatile_mem_functor6</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>
/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) volatile) { return bound_volatile_mem_functor6&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6&gt;(_A_obj, _A_func); }<p>
template &lt;class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj, class T_obj2&gt; inline bound_volatile_mem_functor6&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6&gt; mem_fun6(/* </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a77" doxytag="sigc::mem_fun6"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_mem_functor6&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6&gt; mem_fun6 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor6.html">sigc::bound_const_mem_functor6</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a76" doxytag="sigc::mem_fun6"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_mem_functor6&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6&gt; mem_fun6 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor6.html">sigc::bound_const_mem_functor6</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a62" doxytag="sigc::mem_fun6"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_mem_functor6&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6&gt; mem_fun6 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6)</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor6.html">sigc::bound_mem_functor6</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>
/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6) ) { return bound_mem_functor6&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6&gt;(_A_obj, _A_func); }<p>
template &lt;class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6, class T_return, class T_obj, class T_obj2&gt; inline bound_mem_functor6&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6&gt; mem_fun6(/* </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a54" doxytag="sigc::mem_fun6"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> const_volatile_mem_functor6&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt; sigc::mem_fun6 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) volatile          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor6.html">sigc::const_volatile_mem_functor6</a> which wraps a const volatile method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a46" doxytag="sigc::mem_fun6"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> const_mem_functor6&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6&gt; mem_fun6 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor6.html">sigc::const_mem_functor6</a> which wraps a const method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a38" doxytag="sigc::mem_fun6"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> mem_functor6&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6&gt; mem_fun6 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6)          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1mem__functor6.html">sigc::mem_functor6</a> which wraps a method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a95" doxytag="sigc::mem_fun7"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_volatile_mem_functor7&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7&gt; mem_fun7 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">sigc::bound_const_volatile_mem_functor7</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a87" doxytag="sigc::mem_fun7"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_volatile_mem_functor7&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt; sigc::mem_fun7 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">sigc::bound_const_volatile_mem_functor7</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>
/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) volatile) { return bound_volatile_mem_functor7&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7&gt;(_A_obj, _A_func); }<p>
template &lt;class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj, class T_obj2&gt; inline bound_volatile_mem_functor7&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7&gt; mem_fun7(/* </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a79" doxytag="sigc::mem_fun7"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_mem_functor7&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7&gt; mem_fun7 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor7.html">sigc::bound_const_mem_functor7</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a78" doxytag="sigc::mem_fun7"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_const_mem_functor7&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7&gt; mem_fun7 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor7.html">sigc::bound_const_mem_functor7</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a63" doxytag="sigc::mem_fun7"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bound_mem_functor7&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7&gt; mem_fun7 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7)</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor7.html">sigc::bound_mem_functor7</a> which encapsulates a method and an object instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>
/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7) ) { return bound_mem_functor7&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7&gt;(_A_obj, _A_func); }<p>
template &lt;class T_arg1,class T_arg2,class T_arg3,class T_arg4,class T_arg5,class T_arg6,class T_arg7, class T_return, class T_obj, class T_obj2&gt; inline bound_mem_functor7&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7&gt; mem_fun7(/* </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a55" doxytag="sigc::mem_fun7"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> const_volatile_mem_functor7&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt; sigc::mem_fun7 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) volatile          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor7.html">sigc::const_volatile_mem_functor7</a> which wraps a const volatile method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a47" doxytag="sigc::mem_fun7"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> const_mem_functor7&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7&gt; mem_fun7 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor7.html">sigc::const_mem_functor7</a> which wraps a const method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a39" doxytag="sigc::mem_fun7"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> mem_functor7&lt;T_return, T_obj, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7&gt; mem_fun7 </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7)          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classsigc_1_1mem__functor7.html">sigc::mem_functor7</a> which wraps a method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a31" doxytag="sigc::visit_each"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void visit_each </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_action&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const bound_const_volatile_mem_functor7&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_target</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_const_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_const_volatile_mem_functor object.     </td>
  </tr>
</table>
<a name="a30" doxytag="sigc::visit_each"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void visit_each </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_action&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const bound_const_volatile_mem_functor6&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_target</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_const_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_const_volatile_mem_functor object.     </td>
  </tr>
</table>
<a name="a29" doxytag="sigc::visit_each"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void visit_each </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_action&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const bound_const_volatile_mem_functor5&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_target</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_const_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_const_volatile_mem_functor object.     </td>
  </tr>
</table>
<a name="a28" doxytag="sigc::visit_each"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void visit_each </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_action&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const bound_const_volatile_mem_functor4&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_target</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_const_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_const_volatile_mem_functor object.     </td>
  </tr>
</table>
<a name="a27" doxytag="sigc::visit_each"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void visit_each </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_action&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const bound_const_volatile_mem_functor3&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_target</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_const_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_const_volatile_mem_functor object.     </td>
  </tr>
</table>
<a name="a26" doxytag="sigc::visit_each"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void visit_each </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_action&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const bound_const_volatile_mem_functor2&lt;T_return, T_obj, T_arg1, T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_target</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_const_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_const_volatile_mem_functor object.     </td>
  </tr>
</table>
<a name="a25" doxytag="sigc::visit_each"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_action, class T_return, class T_obj, class T_arg1&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void visit_each </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_action&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const bound_const_volatile_mem_functor1&lt;T_return, T_obj, T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_target</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_const_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_const_volatile_mem_functor object.     </td>
  </tr>
</table>
<a name="a24" doxytag="sigc::visit_each"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_action, class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void visit_each </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_action&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const bound_const_volatile_mem_functor0&lt;T_return, T_obj&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_target</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_const_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_const_volatile_mem_functor object.     </td>
  </tr>
</table>
<a name="a23" doxytag="sigc::visit_each"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void visit_each </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_action&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const bound_volatile_mem_functor7&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_target</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_volatile_mem_functor object.     </td>
  </tr>
</table>
<a name="a22" doxytag="sigc::visit_each"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void visit_each </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_action&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const bound_volatile_mem_functor6&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_target</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_volatile_mem_functor object.     </td>
  </tr>
</table>
<a name="a21" doxytag="sigc::visit_each"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void visit_each </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_action&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const bound_volatile_mem_functor5&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_target</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_volatile_mem_functor object.     </td>
  </tr>
</table>
<a name="a20" doxytag="sigc::visit_each"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void visit_each </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_action&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const bound_volatile_mem_functor4&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_target</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_volatile_mem_functor object.     </td>
  </tr>
</table>
<a name="a19" doxytag="sigc::visit_each"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void visit_each </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_action&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const bound_volatile_mem_functor3&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_target</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_volatile_mem_functor object.     </td>
  </tr>
</table>
<a name="a18" doxytag="sigc::visit_each"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void visit_each </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_action&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const bound_volatile_mem_functor2&lt;T_return, T_obj, T_arg1, T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_target</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_volatile_mem_functor object.     </td>
  </tr>
</table>
<a name="a17" doxytag="sigc::visit_each"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_action, class T_return, class T_obj, class T_arg1&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void visit_each </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_action&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const bound_volatile_mem_functor1&lt;T_return, T_obj, T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_target</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_volatile_mem_functor object.     </td>
  </tr>
</table>
<a name="a16" doxytag="sigc::visit_each"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_action, class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void visit_each </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_action&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const bound_volatile_mem_functor0&lt;T_return, T_obj&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_target</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_volatile_mem_functor object.     </td>
  </tr>
</table>
<a name="a15" doxytag="sigc::visit_each"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void visit_each </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_action&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const bound_const_mem_functor7&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_target</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_const_mem_functor performs a functor on the object instance stored in the sigc::bound_const_mem_functor object.     </td>
  </tr>
</table>
<a name="a14" doxytag="sigc::visit_each"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void visit_each </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_action&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const bound_const_mem_functor6&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_target</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_const_mem_functor performs a functor on the object instance stored in the sigc::bound_const_mem_functor object.     </td>
  </tr>
</table>
<a name="a13" doxytag="sigc::visit_each"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void visit_each </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_action&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const bound_const_mem_functor5&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_target</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_const_mem_functor performs a functor on the object instance stored in the sigc::bound_const_mem_functor object.     </td>
  </tr>
</table>
<a name="a12" doxytag="sigc::visit_each"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void visit_each </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_action&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const bound_const_mem_functor4&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_target</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_const_mem_functor performs a functor on the object instance stored in the sigc::bound_const_mem_functor object.     </td>
  </tr>
</table>
<a name="a11" doxytag="sigc::visit_each"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void visit_each </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_action&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const bound_const_mem_functor3&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_target</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_const_mem_functor performs a functor on the object instance stored in the sigc::bound_const_mem_functor object.     </td>
  </tr>
</table>
<a name="a10" doxytag="sigc::visit_each"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void visit_each </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_action&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const bound_const_mem_functor2&lt;T_return, T_obj, T_arg1, T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_target</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_const_mem_functor performs a functor on the object instance stored in the sigc::bound_const_mem_functor object.     </td>
  </tr>
</table>
<a name="a9" doxytag="sigc::visit_each"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_action, class T_return, class T_obj, class T_arg1&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void visit_each </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_action&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const bound_const_mem_functor1&lt;T_return, T_obj, T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_target</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_const_mem_functor performs a functor on the object instance stored in the sigc::bound_const_mem_functor object.     </td>
  </tr>
</table>
<a name="a8" doxytag="sigc::visit_each"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_action, class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void visit_each </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_action&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const bound_const_mem_functor0&lt;T_return, T_obj&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_target</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_const_mem_functor performs a functor on the object instance stored in the sigc::bound_const_mem_functor object.     </td>
  </tr>
</table>
<a name="a7" doxytag="sigc::visit_each"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void visit_each </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_action&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const bound_mem_functor7&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_target</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_mem_functor performs a functor on the object instance stored in the sigc::bound_mem_functor object.     </td>
  </tr>
</table>
<a name="a6" doxytag="sigc::visit_each"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void visit_each </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_action&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const bound_mem_functor6&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_target</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_mem_functor performs a functor on the object instance stored in the sigc::bound_mem_functor object.     </td>
  </tr>
</table>
<a name="a5" doxytag="sigc::visit_each"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void visit_each </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_action&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const bound_mem_functor5&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_target</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_mem_functor performs a functor on the object instance stored in the sigc::bound_mem_functor object.     </td>
  </tr>
</table>
<a name="a4" doxytag="sigc::visit_each"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void visit_each </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_action&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const bound_mem_functor4&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_target</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_mem_functor performs a functor on the object instance stored in the sigc::bound_mem_functor object.     </td>
  </tr>
</table>
<a name="a3" doxytag="sigc::visit_each"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void visit_each </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_action&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const bound_mem_functor3&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_target</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_mem_functor performs a functor on the object instance stored in the sigc::bound_mem_functor object.     </td>
  </tr>
</table>
<a name="a2" doxytag="sigc::visit_each"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void visit_each </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_action&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const bound_mem_functor2&lt;T_return, T_obj, T_arg1, T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_target</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_mem_functor performs a functor on the object instance stored in the sigc::bound_mem_functor object.     </td>
  </tr>
</table>
<a name="a1" doxytag="sigc::visit_each"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_action, class T_return, class T_obj, class T_arg1&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void visit_each </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_action&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const bound_mem_functor1&lt;T_return, T_obj, T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_target</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_mem_functor performs a functor on the object instance stored in the sigc::bound_mem_functor object.     </td>
  </tr>
</table>
<a name="a0" doxytag="sigc::visit_each"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_action, class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void visit_each </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_action&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const bound_mem_functor0&lt;T_return, T_obj&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_target</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Performs a functor on each of the targets of a functor. 
<p>
The function overload for sigc::bound_mem_functor performs a functor on the object instance stored in the sigc::bound_mem_functor object.     </td>
  </tr>
</table>
<hr><address><small>
Generated for libsigc++ 2.0 by <a href="http://www.doxygen.org/index.html">
Doxygen</a> 1.3.3 &copy;&nbsp;1997-2001</small></address>
</body>
</html>

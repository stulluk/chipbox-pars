<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>sigc Namespace Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head>
<body bgcolor="#ffffff">
<table border="0" width="100%">
<tr>
    <td width="10%" height="40"><img src="../../images/libsigc_logo.gif" alt="logo" border="0" width="100%" height="100%"/></td>
    <td width="90%" height="40"><img src="../../images/top.gif" alt="top" width="100%" height="40"/></td>
</tr>
</table>
<center>
  <a class="qindex" href="../../index.html">Main Page</a> &nbsp;
  <a class="qindex" href="modules.html">Groups</a> &nbsp;
  <a class="qindex" href="namespaces.html"> Namespaces</a> &nbsp;
</center>
<hr width="100%"/>

<!-- Generated by Doxygen 1.3.3 -->
<h1>sigc Namespace Reference</h1>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Compounds</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1adaptor__base.html">adaptor_base</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A hint to the compiler. </em> <a href="structsigc_1_1adaptor__base.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1adaptor__functor.html">adaptor_functor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an arbitrary functor into an adaptor type. </em> <a href="structsigc_1_1adaptor__functor.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1adaptor__functor_1_1deduce__result__type.html">adaptor_functor.deduce_result_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1adaptor__trait_3_01T__functor_00_01false_01_4.html">adaptor_trait&lt;T_functor, false&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Trait that specifies what is the adaptor version of a functor type. </em> <a href="structsigc_1_1adaptor__trait_3_01T__functor_00_01false_01_4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1adaptor__trait_3_01T__functor_00_01true_01_4.html">adaptor_trait&lt;T_functor, true&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Trait that specifies what is the adaptor version of a functor type. </em> <a href="structsigc_1_1adaptor__trait_3_01T__functor_00_01true_01_4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1adapts.html">adapts</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base type for adaptors. </em> <a href="structsigc_1_1adapts.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1address.html">address</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1and__.html">and_</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1assign.html">assign</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1bind__functor_3_010_00_01T__functor_00_01T__bound_01_4.html">bind_functor&lt;0, T_functor, T_bound&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that binds an argument to the wrapped functor. </em> <a href="structsigc_1_1bind__functor_3_010_00_01T__functor_00_01T__bound_01_4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1bind__functor_3_010_00_01T__functor_00_01T__bound_01_4_1_1deduce__result__type.html">bind_functor&lt;0, T_functor, T_bound&gt;.deduce_result_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1bind__functor_3_011_00_01T__functor_00_01T__bound_01_4.html">bind_functor&lt;1, T_functor, T_bound&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that binds an argument to the wrapped functor. </em> <a href="structsigc_1_1bind__functor_3_011_00_01T__functor_00_01T__bound_01_4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1bind__functor_3_011_00_01T__functor_00_01T__bound_01_4_1_1deduce__result__type.html">bind_functor&lt;1, T_functor, T_bound&gt;.deduce_result_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1bind__functor_3_012_00_01T__functor_00_01T__bound_01_4.html">bind_functor&lt;2, T_functor, T_bound&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that binds an argument to the wrapped functor. </em> <a href="structsigc_1_1bind__functor_3_012_00_01T__functor_00_01T__bound_01_4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1bind__functor_3_012_00_01T__functor_00_01T__bound_01_4_1_1deduce__result__type.html">bind_functor&lt;2, T_functor, T_bound&gt;.deduce_result_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1bind__functor_3_013_00_01T__functor_00_01T__bound_01_4.html">bind_functor&lt;3, T_functor, T_bound&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that binds an argument to the wrapped functor. </em> <a href="structsigc_1_1bind__functor_3_013_00_01T__functor_00_01T__bound_01_4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1bind__functor_3_013_00_01T__functor_00_01T__bound_01_4_1_1deduce__result__type.html">bind_functor&lt;3, T_functor, T_bound&gt;.deduce_result_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1bind__functor_3_014_00_01T__functor_00_01T__bound_01_4.html">bind_functor&lt;4, T_functor, T_bound&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that binds an argument to the wrapped functor. </em> <a href="structsigc_1_1bind__functor_3_014_00_01T__functor_00_01T__bound_01_4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1bind__functor_3_014_00_01T__functor_00_01T__bound_01_4_1_1deduce__result__type.html">bind_functor&lt;4, T_functor, T_bound&gt;.deduce_result_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1bind__functor_3_015_00_01T__functor_00_01T__bound_01_4.html">bind_functor&lt;5, T_functor, T_bound&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that binds an argument to the wrapped functor. </em> <a href="structsigc_1_1bind__functor_3_015_00_01T__functor_00_01T__bound_01_4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1bind__functor_3_015_00_01T__functor_00_01T__bound_01_4_1_1deduce__result__type.html">bind_functor&lt;5, T_functor, T_bound&gt;.deduce_result_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1bind__functor_3_016_00_01T__functor_00_01T__bound_01_4.html">bind_functor&lt;6, T_functor, T_bound&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that binds an argument to the wrapped functor. </em> <a href="structsigc_1_1bind__functor_3_016_00_01T__functor_00_01T__bound_01_4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1bind__functor_3_016_00_01T__functor_00_01T__bound_01_4_1_1deduce__result__type.html">bind_functor&lt;6, T_functor, T_bound&gt;.deduce_result_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_01_4.html">bind_functor&lt;-1, T_functor, T_type1 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that binds 1 argument(s) to the wrapped functor. </em> <a href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_01_4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_01_4_1_1deduce__result__type.html">bind_functor&lt;-1, T_functor, T_type1 &gt;.deduce_result_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_01_4_1_1deduce__result__type_3_01T__arg1_01_4.html">bind_functor&lt;-1, T_functor, T_type1 &gt;.deduce_result_type&lt;T_arg1&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_01_4_1_1deduce__result__type_3_01T__arg1_00_01T__arg2_01_4.html">bind_functor&lt;-1, T_functor, T_type1 &gt;.deduce_result_type&lt;T_arg1, T_arg2&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_01_4_1_1deduce__result__type_3_01T__arg1_00_01T__arg2_00_01T__arg3_01_4.html">bind_functor&lt;-1, T_functor, T_type1 &gt;.deduce_result_type&lt;T_arg1, T_arg2, T_arg3&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_01_4_1_1deduce__result__type_3_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_01_4.html">bind_functor&lt;-1, T_functor, T_type1 &gt;.deduce_result_type&lt;T_arg1, T_arg2, T_arg3, T_arg4&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_01_4_1_1deduce__result__type_3_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_01_4.html">bind_functor&lt;-1, T_functor, T_type1 &gt;.deduce_result_type&lt;T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_01_4.html">bind_functor&lt;-1, T_functor, T_type1, T_type2 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that binds 2 argument(s) to the wrapped functor. </em> <a href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_01_4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_01_4_1_1deduce__result__type.html">bind_functor&lt;-1, T_functor, T_type1, T_type2 &gt;.deduce_result_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_01_4_1_1deduce__result__type_3_01T__arg1_01_4.html">bind_functor&lt;-1, T_functor, T_type1, T_type2 &gt;.deduce_result_type&lt;T_arg1&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_01_4_1_1deduce__result__type_3_01T__arg1_00_01T__arg2_01_4.html">bind_functor&lt;-1, T_functor, T_type1, T_type2 &gt;.deduce_result_type&lt;T_arg1, T_arg2&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_01_4_1_1deduce__result__type_3_01T__arg1_00_01T__arg2_00_01T__arg3_01_4.html">bind_functor&lt;-1, T_functor, T_type1, T_type2 &gt;.deduce_result_type&lt;T_arg1, T_arg2, T_arg3&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_01_4_1_1deduce__result__type_3_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_01_4.html">bind_functor&lt;-1, T_functor, T_type1, T_type2 &gt;.deduce_result_type&lt;T_arg1, T_arg2, T_arg3, T_arg4&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_01_4.html">bind_functor&lt;-1, T_functor, T_type1, T_type2, T_type3 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that binds 3 argument(s) to the wrapped functor. </em> <a href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_01_4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_01_4_1_1deduce__result__type.html">bind_functor&lt;-1, T_functor, T_type1, T_type2, T_type3 &gt;.deduce_result_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_01_4_1_1deduce__result__type_3_01T__arg1_01_4.html">bind_functor&lt;-1, T_functor, T_type1, T_type2, T_type3 &gt;.deduce_result_type&lt;T_arg1&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_01_4_1_1deduce__result__type_3_01T__arg1_00_01T__arg2_01_4.html">bind_functor&lt;-1, T_functor, T_type1, T_type2, T_type3 &gt;.deduce_result_type&lt;T_arg1, T_arg2&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_01_4_1_1deduce__result__type_3_01T__arg1_00_01T__arg2_00_01T__arg3_01_4.html">bind_functor&lt;-1, T_functor, T_type1, T_type2, T_type3 &gt;.deduce_result_type&lt;T_arg1, T_arg2, T_arg3&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_00_01T__type4_01_4.html">bind_functor&lt;-1, T_functor, T_type1, T_type2, T_type3, T_type4 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that binds 4 argument(s) to the wrapped functor. </em> <a href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_00_01T__type4_01_4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_00_01T__type4_01_4_1_1deduce__result__type.html">bind_functor&lt;-1, T_functor, T_type1, T_type2, T_type3, T_type4 &gt;.deduce_result_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_00_01T__type4_01_4_1_1deduce__result__type_3_01T__arg1_01_4.html">bind_functor&lt;-1, T_functor, T_type1, T_type2, T_type3, T_type4 &gt;.deduce_result_type&lt;T_arg1&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_00_01T__type4_01_4_1_1deduce__result__type_3_01T__arg1_00_01T__arg2_01_4.html">bind_functor&lt;-1, T_functor, T_type1, T_type2, T_type3, T_type4 &gt;.deduce_result_type&lt;T_arg1, T_arg2&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_00_01T__type4_00_01T__type5_01_4.html">bind_functor&lt;-1, T_functor, T_type1, T_type2, T_type3, T_type4, T_type5 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that binds 5 argument(s) to the wrapped functor. </em> <a href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_00_01T__type4_00_01T__type5_01_4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_00_01T__type4_00_01T__type5_01_4_1_1deduce__result__type.html">bind_functor&lt;-1, T_functor, T_type1, T_type2, T_type3, T_type4, T_type5 &gt;.deduce_result_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_00_01T__type4_00_01T__type5_01_4_1_1deduce__result__type_3_01T__arg1_01_4.html">bind_functor&lt;-1, T_functor, T_type1, T_type2, T_type3, T_type4, T_type5 &gt;.deduce_result_type&lt;T_arg1&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_00_01T__type4_00_01T__type5_00_01T__type6_01_4.html">bind_functor&lt;-1, T_functor, T_type1, T_type2, T_type3, T_type4, T_type5, T_type6 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that binds 6 argument(s) to the wrapped functor. </em> <a href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_00_01T__type4_00_01T__type5_00_01T__type6_01_4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_00_01T__type4_00_01T__type5_00_01T__type6_01_4_1_1deduce__result__type.html">bind_functor&lt;-1, T_functor, T_type1, T_type2, T_type3, T_type4, T_type5, T_type6 &gt;.deduce_result_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_00_01T__type4_00_01T__type5_00_01T__type6_00_01T__type7_01_4.html">bind_functor&lt;-1, T_functor, T_type1, T_type2, T_type3, T_type4, T_type5, T_type6, T_type7 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that binds 7 argument(s) to the wrapped functor. </em> <a href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_00_01T__type4_00_01T__type5_00_01T__type6_00_01T__type7_01_4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_00_01T__type4_00_01T__type5_00_01T__type6_00_01T__type7_01_4_1_1deduce__result__type.html">bind_functor&lt;-1, T_functor, T_type1, T_type2, T_type3, T_type4, T_type5, T_type6, T_type7 &gt;.deduce_result_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1bind__return__functor.html">bind_return_functor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that fixes the return value of the wrapped functor. </em> <a href="structsigc_1_1bind__return__functor.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1bind__return__functor_1_1deduce__result__type.html">bind_return_functor.deduce_result_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1bitwise.html">bitwise</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__const__mem__functor0.html">bound_const_mem_functor0</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor0.html">bound_const_mem_functor0</a> encapsulates a const method with 0 arguments and an object instance. </em> <a href="classsigc_1_1bound__const__mem__functor0.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__const__mem__functor1.html">bound_const_mem_functor1</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor1.html">bound_const_mem_functor1</a> encapsulates a const method with 1 arguments and an object instance. </em> <a href="classsigc_1_1bound__const__mem__functor1.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__const__mem__functor2.html">bound_const_mem_functor2</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor2.html">bound_const_mem_functor2</a> encapsulates a const method with 2 arguments and an object instance. </em> <a href="classsigc_1_1bound__const__mem__functor2.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__const__mem__functor3.html">bound_const_mem_functor3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor3.html">bound_const_mem_functor3</a> encapsulates a const method with 3 arguments and an object instance. </em> <a href="classsigc_1_1bound__const__mem__functor3.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__const__mem__functor4.html">bound_const_mem_functor4</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor4.html">bound_const_mem_functor4</a> encapsulates a const method with 4 arguments and an object instance. </em> <a href="classsigc_1_1bound__const__mem__functor4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__const__mem__functor5.html">bound_const_mem_functor5</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor5.html">bound_const_mem_functor5</a> encapsulates a const method with 5 arguments and an object instance. </em> <a href="classsigc_1_1bound__const__mem__functor5.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__const__mem__functor6.html">bound_const_mem_functor6</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor6.html">bound_const_mem_functor6</a> encapsulates a const method with 6 arguments and an object instance. </em> <a href="classsigc_1_1bound__const__mem__functor6.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__const__mem__functor7.html">bound_const_mem_functor7</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor7.html">bound_const_mem_functor7</a> encapsulates a const method with 7 arguments and an object instance. </em> <a href="classsigc_1_1bound__const__mem__functor7.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">bound_const_volatile_mem_functor0</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">bound_const_volatile_mem_functor0</a> encapsulates a const volatile method with 0 arguments and an object instance. </em> <a href="classsigc_1_1bound__const__volatile__mem__functor0.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">bound_const_volatile_mem_functor1</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">bound_const_volatile_mem_functor1</a> encapsulates a const volatile method with 1 arguments and an object instance. </em> <a href="classsigc_1_1bound__const__volatile__mem__functor1.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">bound_const_volatile_mem_functor2</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">bound_const_volatile_mem_functor2</a> encapsulates a const volatile method with 2 arguments and an object instance. </em> <a href="classsigc_1_1bound__const__volatile__mem__functor2.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">bound_const_volatile_mem_functor3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">bound_const_volatile_mem_functor3</a> encapsulates a const volatile method with 3 arguments and an object instance. </em> <a href="classsigc_1_1bound__const__volatile__mem__functor3.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">bound_const_volatile_mem_functor4</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">bound_const_volatile_mem_functor4</a> encapsulates a const volatile method with 4 arguments and an object instance. </em> <a href="classsigc_1_1bound__const__volatile__mem__functor4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">bound_const_volatile_mem_functor5</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">bound_const_volatile_mem_functor5</a> encapsulates a const volatile method with 5 arguments and an object instance. </em> <a href="classsigc_1_1bound__const__volatile__mem__functor5.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">bound_const_volatile_mem_functor6</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">bound_const_volatile_mem_functor6</a> encapsulates a const volatile method with 6 arguments and an object instance. </em> <a href="classsigc_1_1bound__const__volatile__mem__functor6.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">bound_const_volatile_mem_functor7</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">bound_const_volatile_mem_functor7</a> encapsulates a const volatile method with 7 arguments and an object instance. </em> <a href="classsigc_1_1bound__const__volatile__mem__functor7.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__mem__functor0.html">bound_mem_functor0</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor0.html">bound_mem_functor0</a> encapsulates a method with 0 arguments and an object instance. </em> <a href="classsigc_1_1bound__mem__functor0.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__mem__functor1.html">bound_mem_functor1</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor1.html">bound_mem_functor1</a> encapsulates a method with 1 arguments and an object instance. </em> <a href="classsigc_1_1bound__mem__functor1.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__mem__functor2.html">bound_mem_functor2</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor2.html">bound_mem_functor2</a> encapsulates a method with 2 arguments and an object instance. </em> <a href="classsigc_1_1bound__mem__functor2.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__mem__functor3.html">bound_mem_functor3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor3.html">bound_mem_functor3</a> encapsulates a method with 3 arguments and an object instance. </em> <a href="classsigc_1_1bound__mem__functor3.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__mem__functor4.html">bound_mem_functor4</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor4.html">bound_mem_functor4</a> encapsulates a method with 4 arguments and an object instance. </em> <a href="classsigc_1_1bound__mem__functor4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__mem__functor5.html">bound_mem_functor5</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor5.html">bound_mem_functor5</a> encapsulates a method with 5 arguments and an object instance. </em> <a href="classsigc_1_1bound__mem__functor5.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__mem__functor6.html">bound_mem_functor6</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor6.html">bound_mem_functor6</a> encapsulates a method with 6 arguments and an object instance. </em> <a href="classsigc_1_1bound__mem__functor6.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__mem__functor7.html">bound_mem_functor7</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor7.html">bound_mem_functor7</a> encapsulates a method with 7 arguments and an object instance. </em> <a href="classsigc_1_1bound__mem__functor7.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html">bound_volatile_mem_functor0</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html">bound_volatile_mem_functor0</a> encapsulates a volatile method with 0 arguments and an object instance. </em> <a href="classsigc_1_1bound__volatile__mem__functor0.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html">bound_volatile_mem_functor1</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html">bound_volatile_mem_functor1</a> encapsulates a volatile method with 1 arguments and an object instance. </em> <a href="classsigc_1_1bound__volatile__mem__functor1.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html">bound_volatile_mem_functor2</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html">bound_volatile_mem_functor2</a> encapsulates a volatile method with 2 arguments and an object instance. </em> <a href="classsigc_1_1bound__volatile__mem__functor2.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html">bound_volatile_mem_functor3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html">bound_volatile_mem_functor3</a> encapsulates a volatile method with 3 arguments and an object instance. </em> <a href="classsigc_1_1bound__volatile__mem__functor3.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html">bound_volatile_mem_functor4</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html">bound_volatile_mem_functor4</a> encapsulates a volatile method with 4 arguments and an object instance. </em> <a href="classsigc_1_1bound__volatile__mem__functor4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html">bound_volatile_mem_functor5</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html">bound_volatile_mem_functor5</a> encapsulates a volatile method with 5 arguments and an object instance. </em> <a href="classsigc_1_1bound__volatile__mem__functor5.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html">bound_volatile_mem_functor6</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html">bound_volatile_mem_functor6</a> encapsulates a volatile method with 6 arguments and an object instance. </em> <a href="classsigc_1_1bound__volatile__mem__functor6.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html">bound_volatile_mem_functor7</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html">bound_volatile_mem_functor7</a> encapsulates a volatile method with 7 arguments and an object instance. </em> <a href="classsigc_1_1bound__volatile__mem__functor7.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1cast__.html">cast_</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1compose1__functor.html">compose1_functor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that combines two functors. </em> <a href="structsigc_1_1compose1__functor.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1compose1__functor_1_1deduce__result__type.html">compose1_functor.deduce_result_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1compose2__functor.html">compose2_functor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that combines three functors. </em> <a href="structsigc_1_1compose2__functor.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1compose2__functor_1_1deduce__result__type.html">compose2_functor.deduce_result_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1connection.html">connection</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convinience class for safe disconnection. </em> <a href="structsigc_1_1connection.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1const__mem__functor0.html">const_mem_functor0</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor0.html">const_mem_functor0</a> wraps const methods with 0 argument(s). </em> <a href="classsigc_1_1const__mem__functor0.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1const__mem__functor1.html">const_mem_functor1</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor1.html">const_mem_functor1</a> wraps const methods with 1 argument(s). </em> <a href="classsigc_1_1const__mem__functor1.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1const__mem__functor2.html">const_mem_functor2</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor2.html">const_mem_functor2</a> wraps const methods with 2 argument(s). </em> <a href="classsigc_1_1const__mem__functor2.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1const__mem__functor3.html">const_mem_functor3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor3.html">const_mem_functor3</a> wraps const methods with 3 argument(s). </em> <a href="classsigc_1_1const__mem__functor3.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1const__mem__functor4.html">const_mem_functor4</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor4.html">const_mem_functor4</a> wraps const methods with 4 argument(s). </em> <a href="classsigc_1_1const__mem__functor4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1const__mem__functor5.html">const_mem_functor5</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor5.html">const_mem_functor5</a> wraps const methods with 5 argument(s). </em> <a href="classsigc_1_1const__mem__functor5.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1const__mem__functor6.html">const_mem_functor6</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor6.html">const_mem_functor6</a> wraps const methods with 6 argument(s). </em> <a href="classsigc_1_1const__mem__functor6.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1const__mem__functor7.html">const_mem_functor7</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor7.html">const_mem_functor7</a> wraps const methods with 7 argument(s). </em> <a href="classsigc_1_1const__mem__functor7.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1const__reference__wrapper.html">const_reference_wrapper</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Const reference wrapper. </em> <a href="structsigc_1_1const__reference__wrapper.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1const__volatile__mem__functor0.html">const_volatile_mem_functor0</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor0.html">const_volatile_mem_functor0</a> wraps const volatile methods with 0 argument(s). </em> <a href="classsigc_1_1const__volatile__mem__functor0.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1const__volatile__mem__functor1.html">const_volatile_mem_functor1</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor1.html">const_volatile_mem_functor1</a> wraps const volatile methods with 1 argument(s). </em> <a href="classsigc_1_1const__volatile__mem__functor1.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1const__volatile__mem__functor2.html">const_volatile_mem_functor2</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor2.html">const_volatile_mem_functor2</a> wraps const volatile methods with 2 argument(s). </em> <a href="classsigc_1_1const__volatile__mem__functor2.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1const__volatile__mem__functor3.html">const_volatile_mem_functor3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor3.html">const_volatile_mem_functor3</a> wraps const volatile methods with 3 argument(s). </em> <a href="classsigc_1_1const__volatile__mem__functor3.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1const__volatile__mem__functor4.html">const_volatile_mem_functor4</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor4.html">const_volatile_mem_functor4</a> wraps const volatile methods with 4 argument(s). </em> <a href="classsigc_1_1const__volatile__mem__functor4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1const__volatile__mem__functor5.html">const_volatile_mem_functor5</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor5.html">const_volatile_mem_functor5</a> wraps const volatile methods with 5 argument(s). </em> <a href="classsigc_1_1const__volatile__mem__functor5.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1const__volatile__mem__functor6.html">const_volatile_mem_functor6</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor6.html">const_volatile_mem_functor6</a> wraps const volatile methods with 6 argument(s). </em> <a href="classsigc_1_1const__volatile__mem__functor6.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1const__volatile__mem__functor7.html">const_volatile_mem_functor7</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor7.html">const_volatile_mem_functor7</a> wraps const volatile methods with 7 argument(s). </em> <a href="classsigc_1_1const__volatile__mem__functor7.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1deduce__result__type.html">deduce_result_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deduce the return type of a functor. </em> <a href="structsigc_1_1deduce__result__type.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01T__arg6_00_01T__arg7_00_01true_01_4.html">deduce_result_type&lt;T_functor, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7, true&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deduce the return type of a functor. </em> <a href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01T__arg6_00_01T__arg7_00_01true_01_4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01T__arg6_00_01void_00_01true_01_4.html">deduce_result_type&lt;T_functor, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, void, true&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deduce the return type of a functor. </em> <a href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01T__arg6_00_01void_00_01true_01_4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01void_00_01void_00_01true_01_4.html">deduce_result_type&lt;T_functor, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, void, void, true&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deduce the return type of a functor. </em> <a href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01void_00_01void_00_01true_01_4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01void_00_01void_00_01void_00_01true_01_4.html">deduce_result_type&lt;T_functor, T_arg1, T_arg2, T_arg3, T_arg4, void, void, void, true&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deduce the return type of a functor. </em> <a href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01void_00_01void_00_01void_00_01true_01_4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01void_00_01void_00_01void_00_01void_00_01true_01_4.html">deduce_result_type&lt;T_functor, T_arg1, T_arg2, T_arg3, void, void, void, void, true&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deduce the return type of a functor. </em> <a href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01void_00_01void_00_01void_00_01void_00_01true_01_4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01T__arg2_00_01void_00_01void_00_01void_00_01void_00_01void_00_01true_01_4.html">deduce_result_type&lt;T_functor, T_arg1, T_arg2, void, void, void, void, void, true&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deduce the return type of a functor. </em> <a href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01T__arg2_00_01void_00_01void_00_01void_00_01void_00_01void_00_01true_01_4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01void_00_01void_00_01void_00_01void_00_01void_00_01void_00_01true_01_4.html">deduce_result_type&lt;T_functor, T_arg1, void, void, void, void, void, void, true&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deduce the return type of a functor. </em> <a href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01void_00_01void_00_01void_00_01void_00_01void_00_01void_00_01true_01_4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1deduce__result__type_3_01T__functor_00_01void_00_01void_00_01void_00_01void_00_01void_00_01void_00_01void_00_01true_01_4.html">deduce_result_type&lt;T_functor, void, void, void, void, void, void, void, true&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deduce the return type of a functor. </em> <a href="structsigc_1_1deduce__result__type_3_01T__functor_00_01void_00_01void_00_01void_00_01void_00_01void_00_01void_00_01void_00_01true_01_4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1dereference.html">dereference</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1dereference__trait.html">dereference_trait</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1dereference__trait_3_01const_01T__type_01_5_01_4.html">dereference_trait&lt;const T_type*&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1dereference__trait_3_01const_01T__type_01_5_6_01_4.html">dereference_trait&lt;const T_type*&amp;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1dereference__trait_3_01const_01T__type_01_5const_01_6_01_4.html">dereference_trait&lt;const T_type* const&amp;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1dereference__trait_3_01T__type_01_5_01_4.html">dereference_trait&lt;T_type*&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1dereference__trait_3_01T__type_01_5_6_01_4.html">dereference_trait&lt;T_type*&amp;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1dereference__trait_3_01T__type_01_5const_01_6_01_4.html">dereference_trait&lt;T_type* const&amp;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1divides.html">divides</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1dynamic__.html">dynamic_</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1equal__to.html">equal_to</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1exception__catch__functor.html">exception_catch_functor</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1exception__catch__functor_1_1deduce__result__type.html">exception_catch_functor.deduce_result_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1exception__catch__functor_3_01T__functor_00_01T__catcher_00_01void_01_4.html">exception_catch_functor&lt;T_functor, T_catcher, void&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1functor__base.html">functor_base</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A hint to the compiler. </em> <a href="structsigc_1_1functor__base.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1functor__trait.html">functor_trait</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1functor__trait_3_01T__functor_00_01true_01_4.html">functor_trait&lt;T_functor, true&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1functor__trait_3_01T__return(_5)()_00_01false_01_4.html">functor_trait&lt;T_return(*)(), false&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1functor__trait_3_01T__return(_5)(T__arg1)_00_01false_01_4.html">functor_trait&lt;T_return(*)(T_arg1), false&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1functor__trait_3_01T__return(_5)(T__arg1_00_01T__arg2)_00_01false_01_4.html">functor_trait&lt;T_return(*)(T_arg1, T_arg2), false&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1functor__trait_3_01T__return(_5)(T__arg1_00_01T__arg2_00_01T__arg3)_00_01false_01_4.html">functor_trait&lt;T_return(*)(T_arg1, T_arg2, T_arg3), false&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1functor__trait_3_01T__return(_5)(T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4)_00_01false_01_4.html">functor_trait&lt;T_return(*)(T_arg1, T_arg2, T_arg3, T_arg4), false&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1functor__trait_3_01T__return(_5)(T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5)_00_01false_01_4.html">functor_trait&lt;T_return(*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5), false&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1functor__trait_3_01T__return(_5)(T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01T__arg6)_00_01false_01_4.html">functor_trait&lt;T_return(*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6), false&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1functor__trait_3_01T__return(_5)(T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01T__arg6_00_01T__arg7)_00_01false_01_4.html">functor_trait&lt;T_return(*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7), false&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1functor__trait_3_01T__return(T__obj_1_1_5)()_01const_00_01false_01_4.html">functor_trait&lt;T_return(T_obj.*)() const, false&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1functor__trait_3_01T__return(T__obj_1_1_5)()_00_01false_01_4.html">functor_trait&lt;T_return(T_obj.*)(), false&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1functor__trait_3_01T__return(T__obj_1_1_5)(T__arg1)_01const_00_01false_01_4.html">functor_trait&lt;T_return(T_obj.*)(T_arg1) const, false&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1functor__trait_3_01T__return(T__obj_1_1_5)(T__arg1)_00_01false_01_4.html">functor_trait&lt;T_return(T_obj.*)(T_arg1), false&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1functor__trait_3_01T__return(T__obj_1_1_5)(T__arg1_00_01T__arg2)_01const_00_01false_01_4.html">functor_trait&lt;T_return(T_obj.*)(T_arg1, T_arg2) const, false&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1functor__trait_3_01T__return(T__obj_1_1_5)(T__arg1_00_01T__arg2)_00_01false_01_4.html">functor_trait&lt;T_return(T_obj.*)(T_arg1, T_arg2), false&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1functor__trait_3_01T__return(T__obj_1_1_5)(T__arg1_00_01T__arg2_00_01T__arg3)_01const_00_01false_01_4.html">functor_trait&lt;T_return(T_obj.*)(T_arg1, T_arg2, T_arg3) const, false&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1functor__trait_3_01T__return(T__obj_1_1_5)(T__arg1_00_01T__arg2_00_01T__arg3)_00_01false_01_4.html">functor_trait&lt;T_return(T_obj.*)(T_arg1, T_arg2, T_arg3), false&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1functor__trait_3_01T__return(T__obj_1_1_5)(T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4)_01const_00_01false_01_4.html">functor_trait&lt;T_return(T_obj.*)(T_arg1, T_arg2, T_arg3, T_arg4) const, false&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1functor__trait_3_01T__return(T__obj_1_1_5)(T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4)_00_01false_01_4.html">functor_trait&lt;T_return(T_obj.*)(T_arg1, T_arg2, T_arg3, T_arg4), false&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1functor__trait_3_01T__return(T__obj_1_1_5)(T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5)_01const_00_01false_01_4.html">functor_trait&lt;T_return(T_obj.*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const, false&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1functor__trait_3_01T__return(T__obj_1_1_5)(T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5)_00_01false_01_4.html">functor_trait&lt;T_return(T_obj.*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5), false&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1functor__trait_3_01T__return(T__obj_1_1_5)(T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01T__arg6)_01const_00_01false_01_4.html">functor_trait&lt;T_return(T_obj.*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const, false&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1functor__trait_3_01T__return(T__obj_1_1_5)(T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01T__arg6)_00_01false_01_4.html">functor_trait&lt;T_return(T_obj.*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6), false&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1functor__trait_3_01T__return(T__obj_1_1_5)(T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01T__arg6_00_01T__arg7)_01const_00_01false_01_4.html">functor_trait&lt;T_return(T_obj.*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const, false&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1functor__trait_3_01T__return(T__obj_1_1_5)(T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01T__arg6_00_01T__arg7)_00_01false_01_4.html">functor_trait&lt;T_return(T_obj.*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7), false&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1greater.html">greater</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1greater__equal.html">greater_equal</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1hide__functor_3_010_00_01T__functor_01_4.html">hide_functor&lt;0, T_functor&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that adds a dummy parameter to the wrapped functor. </em> <a href="structsigc_1_1hide__functor_3_010_00_01T__functor_01_4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1hide__functor_3_010_00_01T__functor_01_4_1_1deduce__result__type.html">hide_functor&lt;0, T_functor&gt;.deduce_result_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1hide__functor_3_011_00_01T__functor_01_4.html">hide_functor&lt;1, T_functor&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that adds a dummy parameter to the wrapped functor. </em> <a href="structsigc_1_1hide__functor_3_011_00_01T__functor_01_4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1hide__functor_3_011_00_01T__functor_01_4_1_1deduce__result__type.html">hide_functor&lt;1, T_functor&gt;.deduce_result_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1hide__functor_3_012_00_01T__functor_01_4.html">hide_functor&lt;2, T_functor&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that adds a dummy parameter to the wrapped functor. </em> <a href="structsigc_1_1hide__functor_3_012_00_01T__functor_01_4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1hide__functor_3_012_00_01T__functor_01_4_1_1deduce__result__type.html">hide_functor&lt;2, T_functor&gt;.deduce_result_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1hide__functor_3_013_00_01T__functor_01_4.html">hide_functor&lt;3, T_functor&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that adds a dummy parameter to the wrapped functor. </em> <a href="structsigc_1_1hide__functor_3_013_00_01T__functor_01_4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1hide__functor_3_013_00_01T__functor_01_4_1_1deduce__result__type.html">hide_functor&lt;3, T_functor&gt;.deduce_result_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1hide__functor_3_014_00_01T__functor_01_4.html">hide_functor&lt;4, T_functor&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that adds a dummy parameter to the wrapped functor. </em> <a href="structsigc_1_1hide__functor_3_014_00_01T__functor_01_4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1hide__functor_3_014_00_01T__functor_01_4_1_1deduce__result__type.html">hide_functor&lt;4, T_functor&gt;.deduce_result_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1hide__functor_3_015_00_01T__functor_01_4.html">hide_functor&lt;5, T_functor&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that adds a dummy parameter to the wrapped functor. </em> <a href="structsigc_1_1hide__functor_3_015_00_01T__functor_01_4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1hide__functor_3_015_00_01T__functor_01_4_1_1deduce__result__type.html">hide_functor&lt;5, T_functor&gt;.deduce_result_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1hide__functor_3_016_00_01T__functor_01_4.html">hide_functor&lt;6, T_functor&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that adds a dummy parameter to the wrapped functor. </em> <a href="structsigc_1_1hide__functor_3_016_00_01T__functor_01_4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1hide__functor_3_016_00_01T__functor_01_4_1_1deduce__result__type.html">hide_functor&lt;6, T_functor&gt;.deduce_result_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1hide__functor_3-1_00_01T__functor_01_4.html">hide_functor&lt;-1, T_functor &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that adds a dummy parameter to the wrapped functor. </em> <a href="structsigc_1_1hide__functor_3-1_00_01T__functor_01_4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1hide__functor_3-1_00_01T__functor_01_4_1_1deduce__result__type.html">hide_functor&lt;-1, T_functor &gt;.deduce_result_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1is__base__and__derived.html">is_base_and_derived</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">From Esa Pulkkin: Compile-time determination of base-class relationship in C++ (adapted to match the syntax of boost's type_traits library). </em> <a href="structsigc_1_1is__base__and__derived.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><b>is_base_and_derived.big</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><b>is_base_and_derived.test</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1is__base__and__derived_3_01T__base_00_01T__base_01_4.html">is_base_and_derived&lt;T_base, T_base&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action.html">lambda_action</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action_3_01arithmetic_3_01divides_01_4_01_4.html">lambda_action&lt;arithmetic&lt;divides&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action_3_01arithmetic_3_01minus_01_4_01_4.html">lambda_action&lt;arithmetic&lt;minus&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action_3_01arithmetic_3_01modulus_01_4_01_4.html">lambda_action&lt;arithmetic&lt;modulus&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action_3_01arithmetic_3_01multiplies_01_4_01_4.html">lambda_action&lt;arithmetic&lt;multiplies&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action_3_01arithmetic_3_01plus_01_4_01_4.html">lambda_action&lt;arithmetic&lt;plus&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action_3_01arithmetic__assign_3_01divides_01_4_01_4.html">lambda_action&lt;arithmetic_assign&lt;divides&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action_3_01arithmetic__assign_3_01minus_01_4_01_4.html">lambda_action&lt;arithmetic_assign&lt;minus&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action_3_01arithmetic__assign_3_01modulus_01_4_01_4.html">lambda_action&lt;arithmetic_assign&lt;modulus&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action_3_01arithmetic__assign_3_01multiplies_01_4_01_4.html">lambda_action&lt;arithmetic_assign&lt;multiplies&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action_3_01arithmetic__assign_3_01plus_01_4_01_4.html">lambda_action&lt;arithmetic_assign&lt;plus&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action_3_01bitwise_3_01and___01_4_01_4.html">lambda_action&lt;bitwise&lt;and_&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action_3_01bitwise_3_01leftshift_01_4_01_4.html">lambda_action&lt;bitwise&lt;leftshift&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action_3_01bitwise_3_01or___01_4_01_4.html">lambda_action&lt;bitwise&lt;or_&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action_3_01bitwise_3_01rightshift_01_4_01_4.html">lambda_action&lt;bitwise&lt;rightshift&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action_3_01bitwise_3_01xor___01_4_01_4.html">lambda_action&lt;bitwise&lt;xor_&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action_3_01bitwise__assign_3_01and___01_4_01_4.html">lambda_action&lt;bitwise_assign&lt;and_&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action_3_01bitwise__assign_3_01leftshift_01_4_01_4.html">lambda_action&lt;bitwise_assign&lt;leftshift&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action_3_01bitwise__assign_3_01or___01_4_01_4.html">lambda_action&lt;bitwise_assign&lt;or_&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action_3_01bitwise__assign_3_01rightshift_01_4_01_4.html">lambda_action&lt;bitwise_assign&lt;rightshift&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action_3_01bitwise__assign_3_01xor___01_4_01_4.html">lambda_action&lt;bitwise_assign&lt;xor_&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action_3_01logical_3_01and___01_4_01_4.html">lambda_action&lt;logical&lt;and_&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action_3_01logical_3_01or___01_4_01_4.html">lambda_action&lt;logical&lt;or_&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action_3_01other_3_01assign_01_4_01_4.html">lambda_action&lt;other&lt;assign&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action_3_01other_3_01subscript_01_4_01_4.html">lambda_action&lt;other&lt;subscript&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action_3_01relational_3_01equal__to_01_4_01_4.html">lambda_action&lt;relational&lt;equal_to&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action_3_01relational_3_01greater_01_4_01_4.html">lambda_action&lt;relational&lt;greater&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action_3_01relational_3_01greater__equal_01_4_01_4.html">lambda_action&lt;relational&lt;greater_equal&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action_3_01relational_3_01less_01_4_01_4.html">lambda_action&lt;relational&lt;less&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action_3_01relational_3_01less__equal_01_4_01_4.html">lambda_action&lt;relational&lt;less_equal&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action_3_01relational_3_01not__equal__to_01_4_01_4.html">lambda_action&lt;relational&lt;not_equal_to&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action__convert.html">lambda_action_convert</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action__convert_3_01cast___3_01dynamic___01_4_00_01T__type_01_4.html">lambda_action_convert&lt;cast_&lt;dynamic_&gt;, T_type&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action__convert_3_01cast___3_01reinterpret___01_4_00_01T__type_01_4.html">lambda_action_convert&lt;cast_&lt;reinterpret_&gt;, T_type&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action__convert_3_01cast___3_01static___01_4_00_01T__type_01_4.html">lambda_action_convert&lt;cast_&lt;static_&gt;, T_type&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action__convert__deduce__result__type.html">lambda_action_convert_deduce_result_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action__deduce__result__type.html">lambda_action_deduce_result_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action__deduce__result__type_3_01arithmetic__assign_3_01T__action_01_4_00_01T__test1_00_01T__test2_01_4.html">lambda_action_deduce_result_type&lt;arithmetic_assign&lt;T_action&gt;, T_test1, T_test2&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action__deduce__result__type_3_01bitwise__assign_3_01T__action_01_4_00_01T__test1_00_01T__test2_01_4.html">lambda_action_deduce_result_type&lt;bitwise_assign&lt;T_action&gt;, T_test1, T_test2&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action__deduce__result__type_3_01logical_3_01T__action_01_4_00_01T__test1_00_01T__test2_01_4.html">lambda_action_deduce_result_type&lt;logical&lt;T_action&gt;, T_test1, T_test2&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action__deduce__result__type_3_01other_3_01subscript_01_4_00_01T__test1_00_01T__test2_01_4.html">lambda_action_deduce_result_type&lt;other&lt;subscript&gt;, T_test1, T_test2&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action__deduce__result__type_3_01relational_3_01T__action_01_4_00_01T__test1_00_01T__test2_01_4.html">lambda_action_deduce_result_type&lt;relational&lt;T_action&gt;, T_test1, T_test2&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action__unary.html">lambda_action_unary</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action__unary_3_01unary__arithmetic_3_01negate_01_4_01_4.html">lambda_action_unary&lt;unary_arithmetic&lt;negate&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action__unary_3_01unary__arithmetic_3_01pre__decrement_01_4_01_4.html">lambda_action_unary&lt;unary_arithmetic&lt;pre_decrement&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action__unary_3_01unary__arithmetic_3_01pre__increment_01_4_01_4.html">lambda_action_unary&lt;unary_arithmetic&lt;pre_increment&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action__unary_3_01unary__bitwise_3_01not___01_4_01_4.html">lambda_action_unary&lt;unary_bitwise&lt;not_&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action__unary_3_01unary__logical_3_01not___01_4_01_4.html">lambda_action_unary&lt;unary_logical&lt;not_&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action__unary_3_01unary__other_3_01address_01_4_01_4.html">lambda_action_unary&lt;unary_other&lt;address&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action__unary_3_01unary__other_3_01dereference_01_4_01_4.html">lambda_action_unary&lt;unary_other&lt;dereference&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action__unary__deduce__result__type.html">lambda_action_unary_deduce_result_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action__unary__deduce__result__type_3_01unary__logical_3_01T__action_01_4_00_01T__test_01_4.html">lambda_action_unary_deduce_result_type&lt;unary_logical&lt;T_action&gt;, T_test&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action__unary__deduce__result__type_3_01unary__other_3_01address_01_4_00_01T__test_01_4.html">lambda_action_unary_deduce_result_type&lt;unary_other&lt;address&gt;, T_test&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__action__unary__deduce__result__type_3_01unary__other_3_01dereference_01_4_00_01T__test_01_4.html">lambda_action_unary_deduce_result_type&lt;unary_other&lt;dereference&gt;, T_test&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__group1.html">lambda_group1</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__group1_1_1deduce__result__type.html">lambda_group1.deduce_result_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__group2.html">lambda_group2</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__group2_1_1deduce__result__type.html">lambda_group2.deduce_result_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__group3.html">lambda_group3</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__group3_1_1deduce__result__type.html">lambda_group3.deduce_result_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__operator_1_1deduce__result__type.html">lambda_operator.deduce_result_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__operator__convert.html">lambda_operator_convert</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__operator__convert_1_1deduce__result__type.html">lambda_operator_convert.deduce_result_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__operator__unary.html">lambda_operator_unary</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1lambda__operator__unary_1_1deduce__result__type.html">lambda_operator_unary.deduce_result_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1leftshift.html">leftshift</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1less.html">less</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1less__equal.html">less_equal</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1logical.html">logical</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1mem__functor0.html">mem_functor0</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor0.html">mem_functor0</a> wraps methods with 0 argument(s). </em> <a href="classsigc_1_1mem__functor0.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1mem__functor1.html">mem_functor1</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor1.html">mem_functor1</a> wraps methods with 1 argument(s). </em> <a href="classsigc_1_1mem__functor1.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1mem__functor2.html">mem_functor2</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor2.html">mem_functor2</a> wraps methods with 2 argument(s). </em> <a href="classsigc_1_1mem__functor2.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1mem__functor3.html">mem_functor3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor3.html">mem_functor3</a> wraps methods with 3 argument(s). </em> <a href="classsigc_1_1mem__functor3.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1mem__functor4.html">mem_functor4</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor4.html">mem_functor4</a> wraps methods with 4 argument(s). </em> <a href="classsigc_1_1mem__functor4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1mem__functor5.html">mem_functor5</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor5.html">mem_functor5</a> wraps methods with 5 argument(s). </em> <a href="classsigc_1_1mem__functor5.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1mem__functor6.html">mem_functor6</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor6.html">mem_functor6</a> wraps methods with 6 argument(s). </em> <a href="classsigc_1_1mem__functor6.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1mem__functor7.html">mem_functor7</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor7.html">mem_functor7</a> wraps methods with 7 argument(s). </em> <a href="classsigc_1_1mem__functor7.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1minus.html">minus</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1modulus.html">modulus</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1multiplies.html">multiplies</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1negate.html">negate</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1not__.html">not_</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1not__equal__to.html">not_equal_to</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1or__.html">or_</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1other.html">other</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1plus.html">plus</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1pointer__functor0.html">pointer_functor0</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1pointer__functor0.html">pointer_functor0</a> wraps existing non-member functions with 0 argument(s). </em> <a href="classsigc_1_1pointer__functor0.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1pointer__functor1.html">pointer_functor1</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1pointer__functor1.html">pointer_functor1</a> wraps existing non-member functions with 1 argument(s). </em> <a href="classsigc_1_1pointer__functor1.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1pointer__functor2.html">pointer_functor2</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1pointer__functor2.html">pointer_functor2</a> wraps existing non-member functions with 2 argument(s). </em> <a href="classsigc_1_1pointer__functor2.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1pointer__functor3.html">pointer_functor3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1pointer__functor3.html">pointer_functor3</a> wraps existing non-member functions with 3 argument(s). </em> <a href="classsigc_1_1pointer__functor3.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1pointer__functor4.html">pointer_functor4</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1pointer__functor4.html">pointer_functor4</a> wraps existing non-member functions with 4 argument(s). </em> <a href="classsigc_1_1pointer__functor4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1pointer__functor5.html">pointer_functor5</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1pointer__functor5.html">pointer_functor5</a> wraps existing non-member functions with 5 argument(s). </em> <a href="classsigc_1_1pointer__functor5.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1pointer__functor6.html">pointer_functor6</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1pointer__functor6.html">pointer_functor6</a> wraps existing non-member functions with 6 argument(s). </em> <a href="classsigc_1_1pointer__functor6.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1pointer__functor7.html">pointer_functor7</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1pointer__functor7.html">pointer_functor7</a> wraps existing non-member functions with 7 argument(s). </em> <a href="classsigc_1_1pointer__functor7.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1pre__decrement.html">pre_decrement</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1pre__increment.html">pre_increment</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1reference__wrapper.html">reference_wrapper</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reference wrapper. </em> <a href="structsigc_1_1reference__wrapper.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1reinterpret__.html">reinterpret_</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1relational.html">relational</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that performs C-style casts on the parameters passed on to the functor. </em> <a href="structsigc_1_1retype__functor.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1retype__functor_1_1deduce__result__type.html">retype_functor.deduce_result_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1retype__return__functor.html">retype_return_functor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that perform a C-style cast on the return value of a functor. </em> <a href="structsigc_1_1retype__return__functor.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1retype__return__functor_1_1deduce__result__type.html">retype_return_functor.deduce_result_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1retype__return__functor_3_01void_00_01T__functor_01_4.html">retype_return_functor&lt;void, T_functor&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that perform a C-style cast on the return value of a functor. </em> <a href="structsigc_1_1retype__return__functor_3_01void_00_01T__functor_01_4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1retype__return__functor_3_01void_00_01T__functor_01_4_1_1deduce__result__type.html">retype_return_functor&lt;void, T_functor&gt;.deduce_result_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1rightshift.html">rightshift</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1signal.html">signal</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience wrapper for the numbered sigc::signal# templates. </em> <a href="classsigc_1_1signal.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1signal0.html">signal0</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal declaration. </em> <a href="classsigc_1_1signal0.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1signal1.html">signal1</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal declaration. </em> <a href="classsigc_1_1signal1.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1signal2.html">signal2</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal declaration. </em> <a href="classsigc_1_1signal2.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1signal3.html">signal3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal declaration. </em> <a href="classsigc_1_1signal3.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1signal4.html">signal4</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal declaration. </em> <a href="classsigc_1_1signal4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1signal5.html">signal5</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal declaration. </em> <a href="classsigc_1_1signal5.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1signal6.html">signal6</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal declaration. </em> <a href="classsigc_1_1signal6.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1signal7.html">signal7</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal declaration. </em> <a href="classsigc_1_1signal7.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1signal_1_1accumulated.html">signal.accumulated</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1signal.html">sigc::signal</a># templates. </em> <a href="classsigc_1_1signal_1_1accumulated.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1signal_3_01T__return_01_4.html">signal&lt;T_return&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1signal0.html">sigc::signal0</a> template. </em> <a href="classsigc_1_1signal_3_01T__return_01_4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1signal_3_01T__return_01_4_1_1accumulated.html">signal&lt;T_return&gt;.accumulated</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1signal0.html">sigc::signal0</a> template. </em> <a href="classsigc_1_1signal_3_01T__return_01_4_1_1accumulated.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1signal_3_01T__return_00_01T__arg1_01_4.html">signal&lt;T_return, T_arg1&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1signal1.html">sigc::signal1</a> template. </em> <a href="classsigc_1_1signal_3_01T__return_00_01T__arg1_01_4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1signal_3_01T__return_00_01T__arg1_01_4_1_1accumulated.html">signal&lt;T_return, T_arg1&gt;.accumulated</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1signal1.html">sigc::signal1</a> template. </em> <a href="classsigc_1_1signal_3_01T__return_00_01T__arg1_01_4_1_1accumulated.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_01_4.html">signal&lt;T_return, T_arg1, T_arg2&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1signal2.html">sigc::signal2</a> template. </em> <a href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_01_4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_01_4_1_1accumulated.html">signal&lt;T_return, T_arg1, T_arg2&gt;.accumulated</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1signal2.html">sigc::signal2</a> template. </em> <a href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_01_4_1_1accumulated.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_01_4.html">signal&lt;T_return, T_arg1, T_arg2, T_arg3&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1signal3.html">sigc::signal3</a> template. </em> <a href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_01_4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_01_4_1_1accumulated.html">signal&lt;T_return, T_arg1, T_arg2, T_arg3&gt;.accumulated</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1signal3.html">sigc::signal3</a> template. </em> <a href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_01_4_1_1accumulated.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_01_4.html">signal&lt;T_return, T_arg1, T_arg2, T_arg3, T_arg4&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1signal4.html">sigc::signal4</a> template. </em> <a href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_01_4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_01_4_1_1accumulated.html">signal&lt;T_return, T_arg1, T_arg2, T_arg3, T_arg4&gt;.accumulated</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1signal4.html">sigc::signal4</a> template. </em> <a href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_01_4_1_1accumulated.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_01_4.html">signal&lt;T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1signal5.html">sigc::signal5</a> template. </em> <a href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_01_4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_01_4_1_1accumulated.html">signal&lt;T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;.accumulated</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1signal5.html">sigc::signal5</a> template. </em> <a href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_01_4_1_1accumulated.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01T__arg6_01_4.html">signal&lt;T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1signal6.html">sigc::signal6</a> template. </em> <a href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01T__arg6_01_4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01T__arg6_01_4_1_1accumulated.html">signal&lt;T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;.accumulated</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1signal6.html">sigc::signal6</a> template. </em> <a href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01T__arg6_01_4_1_1accumulated.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1signal__base.html">signal_base</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for the <a class="el" href="classsigc_1_1signal.html">sigc::signal</a># templates. </em> <a href="structsigc_1_1signal__base.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1slot.html">slot</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience wrapper for the numbered sigc::slot# templates. </em> <a href="classsigc_1_1slot.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1slot0.html">slot0</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque. </em> <a href="classsigc_1_1slot0.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1slot1.html">slot1</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque. </em> <a href="classsigc_1_1slot1.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1slot2.html">slot2</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque. </em> <a href="classsigc_1_1slot2.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1slot3.html">slot3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque. </em> <a href="classsigc_1_1slot3.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1slot4.html">slot4</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque. </em> <a href="classsigc_1_1slot4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1slot5.html">slot5</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque. </em> <a href="classsigc_1_1slot5.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1slot6.html">slot6</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque. </em> <a href="classsigc_1_1slot6.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1slot7.html">slot7</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque. </em> <a href="classsigc_1_1slot7.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1slot_3_01T__return_01_4.html">slot&lt;T_return&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1slot0.html">sigc::slot0</a> template. </em> <a href="classsigc_1_1slot_3_01T__return_01_4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1slot_3_01T__return_00_01T__arg1_01_4.html">slot&lt;T_return, T_arg1&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1slot1.html">sigc::slot1</a> template. </em> <a href="classsigc_1_1slot_3_01T__return_00_01T__arg1_01_4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_01_4.html">slot&lt;T_return, T_arg1, T_arg2&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1slot2.html">sigc::slot2</a> template. </em> <a href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_01_4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_01_4.html">slot&lt;T_return, T_arg1, T_arg2, T_arg3&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1slot3.html">sigc::slot3</a> template. </em> <a href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_01_4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_01_4.html">slot&lt;T_return, T_arg1, T_arg2, T_arg3, T_arg4&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1slot4.html">sigc::slot4</a> template. </em> <a href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_01_4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_01_4.html">slot&lt;T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1slot5.html">sigc::slot5</a> template. </em> <a href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_01_4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01T__arg6_01_4.html">slot&lt;T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1slot6.html">sigc::slot6</a> template. </em> <a href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01T__arg6_01_4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1slot__base.html">slot_base</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base type for slots. </em> <a href="classsigc_1_1slot__base.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1slot__const__iterator.html">slot_const_iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL-style const iterator for <a class="el" href="structsigc_1_1slot__list.html">slot_list</a>. </em> <a href="structsigc_1_1slot__const__iterator.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1slot__iterator.html">slot_iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL-style iterator for <a class="el" href="structsigc_1_1slot__list.html">slot_list</a>. </em> <a href="structsigc_1_1slot__iterator.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1slot__list.html">slot_list</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL-style list interface for <a class="el" href="classsigc_1_1signal.html">sigc::signal</a>#. </em> <a href="structsigc_1_1slot__list.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1static__.html">static_</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1subscript.html">subscript</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1trackable.html">trackable</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for objects with auto-disconnection. </em> <a href="structsigc_1_1trackable.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1type__trait.html">type_trait</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1type__trait_3_01const_01T__type_01_6_01_4.html">type_trait&lt;const T_type&amp;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1type__trait_3_01const__reference__wrapper_3_01T__type_01_4_01_4.html">type_trait&lt;const_reference_wrapper&lt;T_type&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1type__trait_3_01reference__wrapper_3_01T__type_01_4_01_4.html">type_trait&lt;reference_wrapper&lt;T_type&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1type__trait_3_01T__type_01_6_01_4.html">type_trait&lt;T_type&amp;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1type__trait_3_01T__type[N]_4.html">type_trait&lt; T_type[N]&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1type__trait_3_01void_01_4.html">type_trait&lt;void&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1unary__arithmetic.html">unary_arithmetic</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1unary__bitwise.html">unary_bitwise</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1unary__logical.html">unary_logical</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1unary__other.html">unary_other</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1unwrap__reference_3_01const__reference__wrapper_3_01T__type_01_4_01_4.html">unwrap_reference&lt;const_reference_wrapper&lt;T_type&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1unwrap__reference_3_01reference__wrapper_3_01T__type_01_4_01_4.html">unwrap_reference&lt;reference_wrapper&lt;T_type&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1volatile__mem__functor0.html">volatile_mem_functor0</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor0.html">volatile_mem_functor0</a> wraps volatile methods with 0 argument(s). </em> <a href="classsigc_1_1volatile__mem__functor0.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1volatile__mem__functor1.html">volatile_mem_functor1</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor1.html">volatile_mem_functor1</a> wraps volatile methods with 1 argument(s). </em> <a href="classsigc_1_1volatile__mem__functor1.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1volatile__mem__functor2.html">volatile_mem_functor2</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor2.html">volatile_mem_functor2</a> wraps volatile methods with 2 argument(s). </em> <a href="classsigc_1_1volatile__mem__functor2.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1volatile__mem__functor3.html">volatile_mem_functor3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor3.html">volatile_mem_functor3</a> wraps volatile methods with 3 argument(s). </em> <a href="classsigc_1_1volatile__mem__functor3.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1volatile__mem__functor4.html">volatile_mem_functor4</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor4.html">volatile_mem_functor4</a> wraps volatile methods with 4 argument(s). </em> <a href="classsigc_1_1volatile__mem__functor4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1volatile__mem__functor5.html">volatile_mem_functor5</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor5.html">volatile_mem_functor5</a> wraps volatile methods with 5 argument(s). </em> <a href="classsigc_1_1volatile__mem__functor5.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1volatile__mem__functor6.html">volatile_mem_functor6</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor6.html">volatile_mem_functor6</a> wraps volatile methods with 6 argument(s). </em> <a href="classsigc_1_1volatile__mem__functor6.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classsigc_1_1volatile__mem__functor7.html">volatile_mem_functor7</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor7.html">volatile_mem_functor7</a> wraps volatile methods with 7 argument(s). </em> <a href="classsigc_1_1volatile__mem__functor7.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsigc_1_1xor__.html">xor_</a></td></tr>

<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_functor&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__adaptors.html#a0">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="structsigc_1_1adaptor__functor.html">adaptor_functor</a>&lt;T_functor&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="group__adaptors.html#a0"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, int T_loc, class T_functor, class T_bound&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__bind.html#a0">visit_each</a> (const T_action&amp; _A_action, const bind_functor&lt;T_loc, T_functor, T_bound&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="group__bind.html#a0"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_functor, class T_type1&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__bind.html#a1">visit_each</a> (const T_action&amp; _A_action, const bind_functor&lt;-1, T_functor, T_type1 &gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="group__bind.html#a1"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_functor, class T_type1, class T_type2&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__bind.html#a2">visit_each</a> (const T_action&amp; _A_action, const bind_functor&lt;-1, T_functor, T_type1, T_type2 &gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="group__bind.html#a2"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_functor, class T_type1, class T_type2, class T_type3&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__bind.html#a3">visit_each</a> (const T_action&amp; _A_action, const bind_functor&lt;-1, T_functor, T_type1, T_type2, T_type3 &gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="group__bind.html#a3"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_functor, class T_type1, class T_type2, class T_type3, class T_type4&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__bind.html#a4">visit_each</a> (const T_action&amp; _A_action, const bind_functor&lt;-1, T_functor, T_type1, T_type2, T_type3, T_type4 &gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="group__bind.html#a4"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_functor, class T_type1, class T_type2, class T_type3, class T_type4, class T_type5&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__bind.html#a5">visit_each</a> (const T_action&amp; _A_action, const bind_functor&lt;-1, T_functor, T_type1, T_type2, T_type3, T_type4, T_type5 &gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="group__bind.html#a5"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_functor, class T_type1, class T_type2, class T_type3, class T_type4, class T_type5, class T_type6&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__bind.html#a6">visit_each</a> (const T_action&amp; _A_action, const bind_functor&lt;-1, T_functor, T_type1, T_type2, T_type3, T_type4, T_type5, T_type6 &gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="group__bind.html#a6"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_functor, class T_type1, class T_type2, class T_type3, class T_type4, class T_type5, class T_type6, class T_type7&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__bind.html#a7">visit_each</a> (const T_action&amp; _A_action, const bind_functor&lt;-1, T_functor, T_type1, T_type2, T_type3, T_type4, T_type5, T_type6, T_type7 &gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="group__bind.html#a7"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;int I_location, class T_bound1, class T_functor&gt; bind_functor&lt; I_location,<br>
 T_functor, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_bound1 &gt;::type &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__bind.html#a8">bind</a> (const T_functor&amp; _A_func, T_bound1 _A_b1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type sigc::bind_functor which binds the passed argument to the passed functor. </em> <a href="group__bind.html#a8"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_type1, class T_functor&gt; bind_functor&lt;-1, T_functor,<br>
 typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_type1 &gt;::type &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__bind.html#a9">bind</a> (const T_functor&amp; _A_func, T_type1 _A_b1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type sigc::bind_functor which fixes the last 1 argument(s) of the passed functor. </em> <a href="group__bind.html#a9"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_type1, class T_type2, class T_functor&gt; bind_functor&lt;-1, T_functor,<br>
 typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_type1 &gt;::type, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_type2 <br>
&gt;::type &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__bind.html#a10">bind</a> (const T_functor&amp; _A_func, T_type1 _A_b1, T_type2 _A_b2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type sigc::bind_functor which fixes the last 2 argument(s) of the passed functor. </em> <a href="group__bind.html#a10"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_type1, class T_type2, class T_type3, class T_functor&gt; bind_functor&lt;-1, T_functor,<br>
 typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_type1 &gt;::type, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_type2 <br>
&gt;::type, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_type3 &gt;::type &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__bind.html#a11">bind</a> (const T_functor&amp; _A_func, T_type1 _A_b1, T_type2 _A_b2, T_type3 _A_b3)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type sigc::bind_functor which fixes the last 3 argument(s) of the passed functor. </em> <a href="group__bind.html#a11"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_type1, class T_type2, class T_type3, class T_type4, class T_functor&gt; bind_functor&lt;-1, T_functor,<br>
 typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_type1 &gt;::type, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_type2 <br>
&gt;::type, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_type3 &gt;::type, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_type4 <br>
&gt;::type &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__bind.html#a12">bind</a> (const T_functor&amp; _A_func, T_type1 _A_b1, T_type2 _A_b2, T_type3 _A_b3, T_type4 _A_b4)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type sigc::bind_functor which fixes the last 4 argument(s) of the passed functor. </em> <a href="group__bind.html#a12"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_type1, class T_type2, class T_type3, class T_type4, class T_type5, class T_functor&gt; bind_functor&lt;-1, T_functor,<br>
 typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_type1 &gt;::type, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_type2 <br>
&gt;::type, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_type3 &gt;::type, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_type4 <br>
&gt;::type, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_type5 &gt;::type &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__bind.html#a13">bind</a> (const T_functor&amp; _A_func, T_type1 _A_b1, T_type2 _A_b2, T_type3 _A_b3, T_type4 _A_b4, T_type5 _A_b5)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type sigc::bind_functor which fixes the last 5 argument(s) of the passed functor. </em> <a href="group__bind.html#a13"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_type1, class T_type2, class T_type3, class T_type4, class T_type5, class T_type6, class T_functor&gt; bind_functor&lt;-1, T_functor,<br>
 typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_type1 &gt;::type, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_type2 <br>
&gt;::type, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_type3 &gt;::type, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_type4 <br>
&gt;::type, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_type5 &gt;::type, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_type6 <br>
&gt;::type &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__bind.html#a14">bind</a> (const T_functor&amp; _A_func, T_type1 _A_b1, T_type2 _A_b2, T_type3 _A_b3, T_type4 _A_b4, T_type5 _A_b5, T_type6 _A_b6)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type sigc::bind_functor which fixes the last 6 argument(s) of the passed functor. </em> <a href="group__bind.html#a14"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_type1, class T_type2, class T_type3, class T_type4, class T_type5, class T_type6, class T_type7, class T_functor&gt; bind_functor&lt;-1, T_functor,<br>
 typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_type1 &gt;::type, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_type2 <br>
&gt;::type, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_type3 &gt;::type, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_type4 <br>
&gt;::type, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_type5 &gt;::type, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_type6 <br>
&gt;::type, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_type7 &gt;::type &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__bind.html#a15">bind</a> (const T_functor&amp; _A_func, T_type1 _A_b1, T_type2 _A_b2, T_type3 _A_b3, T_type4 _A_b4, T_type5 _A_b5, T_type6 _A_b6, T_type7 _A_b7)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type sigc::bind_functor which fixes the last 7 argument(s) of the passed functor. </em> <a href="group__bind.html#a15"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_functor&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__bind.html#a16">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="structsigc_1_1bind__return__functor.html">bind_return_functor</a>&lt;T_return, T_functor&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="group__bind.html#a16"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_functor&gt; <a class="el" href="structsigc_1_1bind__return__functor.html">bind_return_functor</a>&lt; typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_return <br>
&gt;::type, T_functor &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__bind.html#a17">bind_return</a> (const T_functor&amp; _A_functor, T_return _A_ret_value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1bind__return__functor.html">sigc::bind_return_functor</a> which fixes the return value of the passed functor to the passed argument. </em> <a href="group__bind.html#a17"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_setter, class T_getter&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compose.html#a0">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="structsigc_1_1compose1__functor.html">compose1_functor</a>&lt;T_setter, T_getter&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="group__compose.html#a0"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_setter, class T_getter1, class T_getter2&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compose.html#a1">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="structsigc_1_1compose2__functor.html">compose2_functor</a>&lt;T_setter, T_getter1, T_getter2&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="group__compose.html#a1"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_setter, class T_getter&gt; <a class="el" href="structsigc_1_1compose1__functor.html">compose1_functor</a>&lt; T_setter,<br>
 T_getter &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compose.html#a2">compose</a> (const T_setter&amp; _A_setter, const T_getter&amp; _A_getter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1compose1__functor.html">sigc::compose1_functor</a> which combines two functors. </em> <a href="group__compose.html#a2"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_setter, class T_getter1, class T_getter2&gt; <a class="el" href="structsigc_1_1compose2__functor.html">compose2_functor</a>&lt; T_setter,<br>
 T_getter1, T_getter2 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compose.html#a3">compose</a> (const T_setter&amp; _A_setter, const T_getter1&amp; _A_getter1, const T_getter2&amp; _A_getter2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1compose2__functor.html">sigc::compose2_functor</a> which combines three functors. </em> <a href="group__compose.html#a3"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_functor, class T_catcher, class T_return&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a30">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="structsigc_1_1exception__catch__functor.html">exception_catch_functor</a>&lt;T_functor, T_catcher, T_return&gt;&amp; _A_target)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_functor, class T_catcher&gt; <a class="el" href="structsigc_1_1exception__catch__functor.html">exception_catch_functor</a>&lt; T_functor,<br>
 T_catcher &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a31">exception_catch</a> (const T_functor&amp; _A_func, const T_catcher&amp; _A_catcher)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, int I_location, class T_functor&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__hide.html#a0">visit_each</a> (const T_action&amp; _A_action, const hide_functor&lt;I_location, T_functor&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="group__hide.html#a0"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;int I_location, class T_functor&gt; hide_functor&lt; I_location,<br>
 T_functor &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__hide.html#a1">hide</a> (const T_functor&amp; _A_func)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type sigc::hide_functor which adds a dummy parameter to the passed functor. </em> <a href="group__hide.html#a1"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_functor, class T_type1&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a34">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="structsigc_1_1lambda__group1.html">lambda_group1</a>&lt;T_functor, T_type1&gt;&amp; _A_target)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_functor, class T_type1, class T_type2&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a35">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="structsigc_1_1lambda__group2.html">lambda_group2</a>&lt;T_functor, T_type1, T_type2&gt;&amp; _A_target)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_functor, class T_type1, class T_type2, class T_type3&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a36">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="structsigc_1_1lambda__group3.html">lambda_group3</a>&lt;T_functor, T_type1, T_type2, T_type3&gt;&amp; _A_target)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_functor, class T_type1&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__group1.html">lambda_group1</a>&lt; T_functor,<br>
 typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_type1 &gt;::type &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a37">group</a> (const T_functor&amp; _A_func, T_type1 _A_1)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_functor, class T_type1, class T_type2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__group2.html">lambda_group2</a>&lt; T_functor,<br>
 typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_type1 &gt;::type, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_type2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a38">group</a> (const T_functor&amp; _A_func, T_type1 _A_1, T_type2 _A_2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_functor, class T_type1, class T_type2, class T_type3&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__group3.html">lambda_group3</a>&lt; T_functor,<br>
 typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_type1 &gt;::type, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_type2 <br>
&gt;::type, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_type3 &gt;::type &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a39">group</a> (const T_functor&amp; _A_func, T_type1 _A_1, T_type2 _A_2, T_type3 _A_3)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_lambda_action, class T_arg1, class T_arg2&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a40">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;T_lambda_action, T_arg1, T_arg2 &gt;&amp; _A_target)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_lambda_action, class T_arg&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a41">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="structsigc_1_1lambda__operator__unary.html">lambda_operator_unary</a>&lt;T_lambda_action, T_arg&gt;&amp; _A_target)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_lambda_action, class T_type, class T_arg&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a42">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="structsigc_1_1lambda__operator__convert.html">lambda_operator_convert</a>&lt;T_lambda_action, T_type, T_arg&gt;&amp; _A_target)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<br>
 <a class="el" href="structsigc_1_1plus.html">plus</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a43">operator+</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<br>
 <a class="el" href="structsigc_1_1plus.html">plus</a> &gt;, T_arg1, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a44">operator+</a> (const lambda&lt;T_arg1&gt;&amp; a1, T_arg2 a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<br>
 <a class="el" href="structsigc_1_1plus.html">plus</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a45">operator+</a> (T_arg1 a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<br>
 <a class="el" href="structsigc_1_1minus.html">minus</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a46">operator-</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<br>
 <a class="el" href="structsigc_1_1minus.html">minus</a> &gt;, T_arg1, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a47">operator-</a> (const lambda&lt;T_arg1&gt;&amp; a1, T_arg2 a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<br>
 <a class="el" href="structsigc_1_1minus.html">minus</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a48">operator-</a> (T_arg1 a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<br>
 <a class="el" href="structsigc_1_1multiplies.html">multiplies</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a49">operator*</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<br>
 <a class="el" href="structsigc_1_1multiplies.html">multiplies</a> &gt;, T_arg1, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a50">operator*</a> (const lambda&lt;T_arg1&gt;&amp; a1, T_arg2 a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<br>
 <a class="el" href="structsigc_1_1multiplies.html">multiplies</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a51">operator*</a> (T_arg1 a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<br>
 <a class="el" href="structsigc_1_1divides.html">divides</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a52">operator/</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<br>
 <a class="el" href="structsigc_1_1divides.html">divides</a> &gt;, T_arg1, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a53">operator/</a> (const lambda&lt;T_arg1&gt;&amp; a1, T_arg2 a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<br>
 <a class="el" href="structsigc_1_1divides.html">divides</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a54">operator/</a> (T_arg1 a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<br>
 <a class="el" href="structsigc_1_1modulus.html">modulus</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a55">operator%</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<br>
 <a class="el" href="structsigc_1_1modulus.html">modulus</a> &gt;, T_arg1, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a56">operator%</a> (const lambda&lt;T_arg1&gt;&amp; a1, T_arg2 a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<br>
 <a class="el" href="structsigc_1_1modulus.html">modulus</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a57">operator%</a> (T_arg1 a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<br>
 <a class="el" href="structsigc_1_1leftshift.html">leftshift</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a58">operator&lt;&lt;</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<br>
 <a class="el" href="structsigc_1_1leftshift.html">leftshift</a> &gt;, T_arg1, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a59">operator&lt;&lt;</a> (const lambda&lt;T_arg1&gt;&amp; a1, T_arg2 a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<br>
 <a class="el" href="structsigc_1_1leftshift.html">leftshift</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a60">operator&lt;&lt;</a> (T_arg1 a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<br>
 <a class="el" href="structsigc_1_1rightshift.html">rightshift</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a61">operator&gt;&gt;</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<br>
 <a class="el" href="structsigc_1_1rightshift.html">rightshift</a> &gt;, T_arg1, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a62">operator&gt;&gt;</a> (const lambda&lt;T_arg1&gt;&amp; a1, T_arg2 a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<br>
 <a class="el" href="structsigc_1_1rightshift.html">rightshift</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a63">operator&gt;&gt;</a> (T_arg1 a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<br>
 <a class="el" href="structsigc_1_1and__.html">and_</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a64">operator&amp;</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<br>
 <a class="el" href="structsigc_1_1and__.html">and_</a> &gt;, T_arg1, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a65">operator&amp;</a> (const lambda&lt;T_arg1&gt;&amp; a1, T_arg2 a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<br>
 <a class="el" href="structsigc_1_1and__.html">and_</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a66">operator&amp;</a> (T_arg1 a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<br>
 <a class="el" href="structsigc_1_1or__.html">or_</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a67">operator|</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<br>
 <a class="el" href="structsigc_1_1or__.html">or_</a> &gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg2 &gt;::type &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a68">operator|</a> (const lambda&lt;T_arg1&gt;&amp; a1, T_arg2 a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<br>
 <a class="el" href="structsigc_1_1or__.html">or_</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a69">operator|</a> (T_arg1 a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<br>
 <a class="el" href="structsigc_1_1xor__.html">xor_</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a70">operator^</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<br>
 <a class="el" href="structsigc_1_1xor__.html">xor_</a> &gt;, T_arg1, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a71">operator^</a> (const lambda&lt;T_arg1&gt;&amp; a1, T_arg2 a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<br>
 <a class="el" href="structsigc_1_1xor__.html">xor_</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a72">operator^</a> (T_arg1 a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1logical.html">logical</a>&lt;<br>
 <a class="el" href="structsigc_1_1and__.html">and_</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a73">operator&amp;&amp;</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1logical.html">logical</a>&lt;<br>
 <a class="el" href="structsigc_1_1and__.html">and_</a> &gt;, T_arg1, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a74">operator&amp;&amp;</a> (const lambda&lt;T_arg1&gt;&amp; a1, T_arg2 a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1logical.html">logical</a>&lt;<br>
 <a class="el" href="structsigc_1_1and__.html">and_</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a75">operator&amp;&amp;</a> (T_arg1 a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1logical.html">logical</a>&lt;<br>
 <a class="el" href="structsigc_1_1or__.html">or_</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a76">operator||</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1logical.html">logical</a>&lt;<br>
 <a class="el" href="structsigc_1_1or__.html">or_</a> &gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg2 &gt;::type &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a77">operator||</a> (const lambda&lt;T_arg1&gt;&amp; a1, T_arg2 a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1logical.html">logical</a>&lt;<br>
 <a class="el" href="structsigc_1_1or__.html">or_</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a78">operator||</a> (T_arg1 a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<br>
 <a class="el" href="structsigc_1_1less.html">less</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a79">operator&lt;</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<br>
 <a class="el" href="structsigc_1_1less.html">less</a> &gt;, T_arg1, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a80">operator&lt;</a> (const lambda&lt;T_arg1&gt;&amp; a1, T_arg2 a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<br>
 <a class="el" href="structsigc_1_1less.html">less</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a81">operator&lt;</a> (T_arg1 a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<br>
 <a class="el" href="structsigc_1_1greater.html">greater</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a82">operator&gt;</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<br>
 <a class="el" href="structsigc_1_1greater.html">greater</a> &gt;, T_arg1, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a83">operator&gt;</a> (const lambda&lt;T_arg1&gt;&amp; a1, T_arg2 a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<br>
 <a class="el" href="structsigc_1_1greater.html">greater</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a84">operator&gt;</a> (T_arg1 a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<br>
 <a class="el" href="structsigc_1_1less__equal.html">less_equal</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a85">operator&lt;=</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<br>
 <a class="el" href="structsigc_1_1less__equal.html">less_equal</a> &gt;, T_arg1, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a86">operator&lt;=</a> (const lambda&lt;T_arg1&gt;&amp; a1, T_arg2 a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<br>
 <a class="el" href="structsigc_1_1less__equal.html">less_equal</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a87">operator&lt;=</a> (T_arg1 a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<br>
 <a class="el" href="structsigc_1_1greater__equal.html">greater_equal</a> &gt;, T_arg1,<br>
 T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a88">operator&gt;=</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<br>
 <a class="el" href="structsigc_1_1greater__equal.html">greater_equal</a> &gt;, T_arg1,<br>
 typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg2 &gt;::type &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a89">operator&gt;=</a> (const lambda&lt;T_arg1&gt;&amp; a1, T_arg2 a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<br>
 <a class="el" href="structsigc_1_1greater__equal.html">greater_equal</a> &gt;, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg1 <br>
&gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a90">operator&gt;=</a> (T_arg1 a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<br>
 <a class="el" href="structsigc_1_1equal__to.html">equal_to</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a91">operator==</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<br>
 <a class="el" href="structsigc_1_1equal__to.html">equal_to</a> &gt;, T_arg1, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a92">operator==</a> (const lambda&lt;T_arg1&gt;&amp; a1, T_arg2 a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<br>
 <a class="el" href="structsigc_1_1equal__to.html">equal_to</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a93">operator==</a> (T_arg1 a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<br>
 <a class="el" href="structsigc_1_1not__equal__to.html">not_equal_to</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a94">operator!=</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<br>
 <a class="el" href="structsigc_1_1not__equal__to.html">not_equal_to</a> &gt;, T_arg1, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a95">operator!=</a> (const lambda&lt;T_arg1&gt;&amp; a1, T_arg2 a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<br>
 <a class="el" href="structsigc_1_1not__equal__to.html">not_equal_to</a> &gt;, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg1 <br>
&gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a96">operator!=</a> (T_arg1 a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1plus.html">plus</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a97">operator+=</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1plus.html">plus</a> &gt;, T_arg1, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a98">operator+=</a> (const lambda&lt;T_arg1&gt;&amp; a1, T_arg2 a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1plus.html">plus</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a99">operator+=</a> (T_arg1 a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1minus.html">minus</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a100">operator-=</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1minus.html">minus</a> &gt;, T_arg1, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a101">operator-=</a> (const lambda&lt;T_arg1&gt;&amp; a1, T_arg2 a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1minus.html">minus</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a102">operator-=</a> (T_arg1 a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1multiplies.html">multiplies</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a103">operator*=</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1multiplies.html">multiplies</a> &gt;, T_arg1, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a104">operator*=</a> (const lambda&lt;T_arg1&gt;&amp; a1, T_arg2 a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1multiplies.html">multiplies</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a105">operator*=</a> (T_arg1 a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1divides.html">divides</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a106">operator/=</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1divides.html">divides</a> &gt;, T_arg1, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a107">operator/=</a> (const lambda&lt;T_arg1&gt;&amp; a1, T_arg2 a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1divides.html">divides</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a108">operator/=</a> (T_arg1 a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1modulus.html">modulus</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a109">operator%=</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1modulus.html">modulus</a> &gt;, T_arg1, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a110">operator%=</a> (const lambda&lt;T_arg1&gt;&amp; a1, T_arg2 a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1modulus.html">modulus</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a111">operator%=</a> (T_arg1 a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1leftshift.html">leftshift</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a112">operator&lt;&lt;=</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1leftshift.html">leftshift</a> &gt;, T_arg1, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a113">operator&lt;&lt;=</a> (const lambda&lt;T_arg1&gt;&amp; a1, T_arg2 a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1leftshift.html">leftshift</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a114">operator&lt;&lt;=</a> (T_arg1 a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1rightshift.html">rightshift</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a115">operator&gt;&gt;=</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1rightshift.html">rightshift</a> &gt;, T_arg1, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a116">operator&gt;&gt;=</a> (const lambda&lt;T_arg1&gt;&amp; a1, T_arg2 a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1rightshift.html">rightshift</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a117">operator&gt;&gt;=</a> (T_arg1 a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1and__.html">and_</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a118">operator&amp;=</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1and__.html">and_</a> &gt;, T_arg1, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a119">operator&amp;=</a> (const lambda&lt;T_arg1&gt;&amp; a1, T_arg2 a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1and__.html">and_</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a120">operator&amp;=</a> (T_arg1 a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1or__.html">or_</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a121">operator|=</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1or__.html">or_</a> &gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg2 &gt;::type &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a122">operator|=</a> (const lambda&lt;T_arg1&gt;&amp; a1, T_arg2 a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1or__.html">or_</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a123">operator|=</a> (T_arg1 a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1xor__.html">xor_</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a124">operator^=</a> (const lambda&lt;T_arg1&gt;&amp; a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1xor__.html">xor_</a> &gt;, T_arg1, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a125">operator^=</a> (const lambda&lt;T_arg1&gt;&amp; a1, T_arg2 a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1xor__.html">xor_</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a126">operator^=</a> (T_arg1 a1, const lambda&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator__unary.html">lambda_operator_unary</a>&lt;<br>
 <a class="el" href="structsigc_1_1unary__arithmetic.html">unary_arithmetic</a>&lt;<a class="el" href="structsigc_1_1pre__increment.html">pre_increment</a>&gt;,<br>
 T_arg &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a127">operator++</a> (const lambda&lt;T_arg&gt;&amp; a)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator__unary.html">lambda_operator_unary</a>&lt;<br>
 <a class="el" href="structsigc_1_1unary__arithmetic.html">unary_arithmetic</a>&lt;<a class="el" href="structsigc_1_1pre__decrement.html">pre_decrement</a>&gt;,<br>
 T_arg &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a128">operator--</a> (const lambda&lt;T_arg&gt;&amp; a)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator__unary.html">lambda_operator_unary</a>&lt;<br>
 <a class="el" href="structsigc_1_1unary__arithmetic.html">unary_arithmetic</a>&lt;<a class="el" href="structsigc_1_1negate.html">negate</a>&gt;,<br>
 T_arg &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a129">operator-</a> (const lambda&lt;T_arg&gt;&amp; a)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator__unary.html">lambda_operator_unary</a>&lt;<br>
 <a class="el" href="structsigc_1_1unary__bitwise.html">unary_bitwise</a>&lt;<a class="el" href="structsigc_1_1not__.html">not_</a> &gt;, T_arg &gt;&gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a130">operator~</a> (const lambda&lt;T_arg&gt;&amp; a)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator__unary.html">lambda_operator_unary</a>&lt;<br>
 <a class="el" href="structsigc_1_1unary__logical.html">unary_logical</a>&lt;<a class="el" href="structsigc_1_1not__.html">not_</a> &gt;, T_arg &gt;&gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a131">operator!</a> (const lambda&lt;T_arg&gt;&amp; a)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator__unary.html">lambda_operator_unary</a>&lt;<br>
 <a class="el" href="structsigc_1_1unary__other.html">unary_other</a>&lt;<a class="el" href="structsigc_1_1address.html">address</a> &gt;, T_arg &gt;&gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a132">operator&amp;</a> (const lambda&lt;T_arg&gt;&amp; a)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator__unary.html">lambda_operator_unary</a>&lt;<br>
 <a class="el" href="structsigc_1_1unary__other.html">unary_other</a>&lt;<a class="el" href="structsigc_1_1dereference.html">dereference</a>&gt;,<br>
 T_arg &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a133">operator*</a> (const lambda&lt;T_arg&gt;&amp; a)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_type, class T_arg&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator__convert.html">lambda_operator_convert</a>&lt;<br>
 <a class="el" href="structsigc_1_1cast__.html">cast_</a>&lt;<a class="el" href="structsigc_1_1reinterpret__.html">reinterpret_</a>&gt;, T_type,<br>
 T_arg &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a134">reinterpret_cast_</a> (const lambda&lt;T_arg&gt;&amp; a)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_type, class T_arg&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator__convert.html">lambda_operator_convert</a>&lt;<br>
 <a class="el" href="structsigc_1_1cast__.html">cast_</a>&lt;<a class="el" href="structsigc_1_1static__.html">static_</a>&gt;, T_type,<br>
 T_arg &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a135">static_cast_</a> (const lambda&lt;T_arg&gt;&amp; a)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_type, class T_arg&gt; lambda&lt; <a class="el" href="structsigc_1_1lambda__operator__convert.html">lambda_operator_convert</a>&lt;<br>
 <a class="el" href="structsigc_1_1cast__.html">cast_</a>&lt;<a class="el" href="structsigc_1_1dynamic__.html">dynamic_</a>&gt;, T_type,<br>
 T_arg &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a136">dynamic_cast_</a> (const lambda&lt;T_arg&gt;&amp; a)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_functor, class T_type1, class T_type2, class T_type3, class T_type4, class T_type5, class T_type6, class T_type7&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a0">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt;T_functor, T_type1, T_type2, T_type3, T_type4, T_type5, T_type6, T_type7&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="group__retype.html#a0"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1slot.html">slot</a>&lt; T_return,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5, T_arg6, T_arg7 &gt;,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5, T_arg6, T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a1">retype</a> (const <a class="el" href="classsigc_1_1slot.html">slot</a>&lt;T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a1"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1pointer__functor0.html">pointer_functor0</a>&lt;<br>
 T_return &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a2">retype</a> (const <a class="el" href="classsigc_1_1pointer__functor0.html">pointer_functor0</a>&lt;T_return&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a2"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_return&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1pointer__functor1.html">pointer_functor1</a>&lt;<br>
 T_arg1, T_return &gt;, T_arg1 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a3">retype</a> (const <a class="el" href="classsigc_1_1pointer__functor1.html">pointer_functor1</a>&lt;T_arg1, T_return&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a3"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_return&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1pointer__functor2.html">pointer_functor2</a>&lt;<br>
 T_arg1, T_arg2, T_return &gt;,<br>
 T_arg1, T_arg2 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a4">retype</a> (const <a class="el" href="classsigc_1_1pointer__functor2.html">pointer_functor2</a>&lt;T_arg1, T_arg2, T_return&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a4"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_return&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1pointer__functor3.html">pointer_functor3</a>&lt;<br>
 T_arg1, T_arg2, T_arg3, T_return &gt;,<br>
 T_arg1, T_arg2, T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a5">retype</a> (const <a class="el" href="classsigc_1_1pointer__functor3.html">pointer_functor3</a>&lt;T_arg1, T_arg2, T_arg3, T_return&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a5"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1pointer__functor4.html">pointer_functor4</a>&lt;<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_return &gt;, T_arg1, T_arg2,<br>
 T_arg3, T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a6">retype</a> (const <a class="el" href="classsigc_1_1pointer__functor4.html">pointer_functor4</a>&lt;T_arg1, T_arg2, T_arg3, T_arg4, T_return&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a6"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1pointer__functor5.html">pointer_functor5</a>&lt;<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5, T_return &gt;, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a7">retype</a> (const <a class="el" href="classsigc_1_1pointer__functor5.html">pointer_functor5</a>&lt;T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_return&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a7"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1pointer__functor6.html">pointer_functor6</a>&lt;<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5, T_arg6, T_return &gt;,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5, T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a8">retype</a> (const <a class="el" href="classsigc_1_1pointer__functor6.html">pointer_functor6</a>&lt;T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_return&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a8"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1pointer__functor7.html">pointer_functor7</a>&lt;<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5, T_arg6, T_arg7, T_return &gt;,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5, T_arg6, T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a9">retype</a> (const <a class="el" href="classsigc_1_1pointer__functor7.html">pointer_functor7</a>&lt;T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7, T_return&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a9"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1mem__functor0.html">mem_functor0</a>&lt;<br>
 T_return, T_obj &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a10">retype</a> (const <a class="el" href="classsigc_1_1mem__functor0.html">mem_functor0</a>&lt;T_return, T_obj&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a10"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1mem__functor1.html">mem_functor1</a>&lt;<br>
 T_return, T_obj, T_arg1 &gt;,<br>
 T_arg1 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a11">retype</a> (const <a class="el" href="classsigc_1_1mem__functor1.html">mem_functor1</a>&lt;T_return, T_obj, T_arg1&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a11"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1, class T_arg2&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1mem__functor2.html">mem_functor2</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2 &gt;, T_arg1, T_arg2 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a12">retype</a> (const <a class="el" href="classsigc_1_1mem__functor2.html">mem_functor2</a>&lt;T_return, T_obj, T_arg1, T_arg2&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a12"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1mem__functor3.html">mem_functor3</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3 &gt;, T_arg1,<br>
 T_arg2, T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a13">retype</a> (const <a class="el" href="classsigc_1_1mem__functor3.html">mem_functor3</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a13"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1mem__functor4.html">mem_functor4</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4 &gt;,<br>
 T_arg1, T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a14">retype</a> (const <a class="el" href="classsigc_1_1mem__functor4.html">mem_functor4</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a14"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1mem__functor5.html">mem_functor5</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5 &gt;,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a15">retype</a> (const <a class="el" href="classsigc_1_1mem__functor5.html">mem_functor5</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a15"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1mem__functor6.html">mem_functor6</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6 &gt;, T_arg1, T_arg2,<br>
 T_arg3, T_arg4, T_arg5, T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a16">retype</a> (const <a class="el" href="classsigc_1_1mem__functor6.html">mem_functor6</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a16"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1mem__functor7.html">mem_functor7</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a17">retype</a> (const <a class="el" href="classsigc_1_1mem__functor7.html">mem_functor7</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a17"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1const__mem__functor0.html">const_mem_functor0</a>&lt;<br>
 T_return, T_obj &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a18">retype</a> (const <a class="el" href="classsigc_1_1const__mem__functor0.html">const_mem_functor0</a>&lt;T_return, T_obj&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a18"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1const__mem__functor1.html">const_mem_functor1</a>&lt;<br>
 T_return, T_obj, T_arg1 &gt;,<br>
 T_arg1 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a19">retype</a> (const <a class="el" href="classsigc_1_1const__mem__functor1.html">const_mem_functor1</a>&lt;T_return, T_obj, T_arg1&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a19"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1, class T_arg2&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1const__mem__functor2.html">const_mem_functor2</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2 &gt;, T_arg1, T_arg2 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a20">retype</a> (const <a class="el" href="classsigc_1_1const__mem__functor2.html">const_mem_functor2</a>&lt;T_return, T_obj, T_arg1, T_arg2&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a20"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1const__mem__functor3.html">const_mem_functor3</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3 &gt;, T_arg1,<br>
 T_arg2, T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a21">retype</a> (const <a class="el" href="classsigc_1_1const__mem__functor3.html">const_mem_functor3</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a21"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1const__mem__functor4.html">const_mem_functor4</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4 &gt;,<br>
 T_arg1, T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a22">retype</a> (const <a class="el" href="classsigc_1_1const__mem__functor4.html">const_mem_functor4</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a22"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1const__mem__functor5.html">const_mem_functor5</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5 &gt;,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a23">retype</a> (const <a class="el" href="classsigc_1_1const__mem__functor5.html">const_mem_functor5</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a23"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1const__mem__functor6.html">const_mem_functor6</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6 &gt;, T_arg1, T_arg2,<br>
 T_arg3, T_arg4, T_arg5, T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a24">retype</a> (const <a class="el" href="classsigc_1_1const__mem__functor6.html">const_mem_functor6</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a24"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1const__mem__functor7.html">const_mem_functor7</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a25">retype</a> (const <a class="el" href="classsigc_1_1const__mem__functor7.html">const_mem_functor7</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a25"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1volatile__mem__functor0.html">volatile_mem_functor0</a>&lt;<br>
 T_return, T_obj &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a26">retype</a> (const <a class="el" href="classsigc_1_1volatile__mem__functor0.html">volatile_mem_functor0</a>&lt;T_return, T_obj&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a26"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1volatile__mem__functor1.html">volatile_mem_functor1</a>&lt;<br>
 T_return, T_obj, T_arg1 &gt;,<br>
 T_arg1 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a27">retype</a> (const <a class="el" href="classsigc_1_1volatile__mem__functor1.html">volatile_mem_functor1</a>&lt;T_return, T_obj, T_arg1&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a27"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1, class T_arg2&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1volatile__mem__functor2.html">volatile_mem_functor2</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2 &gt;, T_arg1, T_arg2 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a28">retype</a> (const <a class="el" href="classsigc_1_1volatile__mem__functor2.html">volatile_mem_functor2</a>&lt;T_return, T_obj, T_arg1, T_arg2&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a28"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1volatile__mem__functor3.html">volatile_mem_functor3</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3 &gt;, T_arg1,<br>
 T_arg2, T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a29">retype</a> (const <a class="el" href="classsigc_1_1volatile__mem__functor3.html">volatile_mem_functor3</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a29"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1volatile__mem__functor4.html">volatile_mem_functor4</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4 &gt;,<br>
 T_arg1, T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a30">retype</a> (const <a class="el" href="classsigc_1_1volatile__mem__functor4.html">volatile_mem_functor4</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a30"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1volatile__mem__functor5.html">volatile_mem_functor5</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5 &gt;,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a31">retype</a> (const <a class="el" href="classsigc_1_1volatile__mem__functor5.html">volatile_mem_functor5</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a31"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1volatile__mem__functor6.html">volatile_mem_functor6</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6 &gt;, T_arg1, T_arg2,<br>
 T_arg3, T_arg4, T_arg5, T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a32">retype</a> (const <a class="el" href="classsigc_1_1volatile__mem__functor6.html">volatile_mem_functor6</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a32"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1volatile__mem__functor7.html">volatile_mem_functor7</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a33">retype</a> (const <a class="el" href="classsigc_1_1volatile__mem__functor7.html">volatile_mem_functor7</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a33"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1const__volatile__mem__functor0.html">const_volatile_mem_functor0</a>&lt;<br>
 T_return, T_obj &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a34">retype</a> (const <a class="el" href="classsigc_1_1const__volatile__mem__functor0.html">const_volatile_mem_functor0</a>&lt;T_return, T_obj&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a34"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1const__volatile__mem__functor1.html">const_volatile_mem_functor1</a>&lt;<br>
 T_return, T_obj, T_arg1 &gt;,<br>
 T_arg1 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a35">retype</a> (const <a class="el" href="classsigc_1_1const__volatile__mem__functor1.html">const_volatile_mem_functor1</a>&lt;T_return, T_obj, T_arg1&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a35"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1, class T_arg2&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1const__volatile__mem__functor2.html">const_volatile_mem_functor2</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2 &gt;, T_arg1, T_arg2 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a36">retype</a> (const <a class="el" href="classsigc_1_1const__volatile__mem__functor2.html">const_volatile_mem_functor2</a>&lt;T_return, T_obj, T_arg1, T_arg2&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a36"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1const__volatile__mem__functor3.html">const_volatile_mem_functor3</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3 &gt;, T_arg1,<br>
 T_arg2, T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a37">retype</a> (const <a class="el" href="classsigc_1_1const__volatile__mem__functor3.html">const_volatile_mem_functor3</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a37"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1const__volatile__mem__functor4.html">const_volatile_mem_functor4</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4 &gt;,<br>
 T_arg1, T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a38">retype</a> (const <a class="el" href="classsigc_1_1const__volatile__mem__functor4.html">const_volatile_mem_functor4</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a38"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1const__volatile__mem__functor5.html">const_volatile_mem_functor5</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5 &gt;,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a39">retype</a> (const <a class="el" href="classsigc_1_1const__volatile__mem__functor5.html">const_volatile_mem_functor5</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a39"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1const__volatile__mem__functor6.html">const_volatile_mem_functor6</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6 &gt;, T_arg1, T_arg2,<br>
 T_arg3, T_arg4, T_arg5, T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a40">retype</a> (const <a class="el" href="classsigc_1_1const__volatile__mem__functor6.html">const_volatile_mem_functor6</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a40"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1const__volatile__mem__functor7.html">const_volatile_mem_functor7</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a41">retype</a> (const <a class="el" href="classsigc_1_1const__volatile__mem__functor7.html">const_volatile_mem_functor7</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a41"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__mem__functor0.html">bound_mem_functor0</a>&lt;<br>
 T_return, T_obj &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a42">retype</a> (const <a class="el" href="classsigc_1_1bound__mem__functor0.html">bound_mem_functor0</a>&lt;T_return, T_obj&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a42"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__mem__functor1.html">bound_mem_functor1</a>&lt;<br>
 T_return, T_obj, T_arg1 &gt;,<br>
 T_arg1 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a43">retype</a> (const <a class="el" href="classsigc_1_1bound__mem__functor1.html">bound_mem_functor1</a>&lt;T_return, T_obj, T_arg1&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a43"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1, class T_arg2&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__mem__functor2.html">bound_mem_functor2</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2 &gt;, T_arg1, T_arg2 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a44">retype</a> (const <a class="el" href="classsigc_1_1bound__mem__functor2.html">bound_mem_functor2</a>&lt;T_return, T_obj, T_arg1, T_arg2&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a44"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__mem__functor3.html">bound_mem_functor3</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3 &gt;, T_arg1,<br>
 T_arg2, T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a45">retype</a> (const <a class="el" href="classsigc_1_1bound__mem__functor3.html">bound_mem_functor3</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a45"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__mem__functor4.html">bound_mem_functor4</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4 &gt;,<br>
 T_arg1, T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a46">retype</a> (const <a class="el" href="classsigc_1_1bound__mem__functor4.html">bound_mem_functor4</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a46"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__mem__functor5.html">bound_mem_functor5</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5 &gt;,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a47">retype</a> (const <a class="el" href="classsigc_1_1bound__mem__functor5.html">bound_mem_functor5</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a47"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__mem__functor6.html">bound_mem_functor6</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6 &gt;, T_arg1, T_arg2,<br>
 T_arg3, T_arg4, T_arg5, T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a48">retype</a> (const <a class="el" href="classsigc_1_1bound__mem__functor6.html">bound_mem_functor6</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a48"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__mem__functor7.html">bound_mem_functor7</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a49">retype</a> (const <a class="el" href="classsigc_1_1bound__mem__functor7.html">bound_mem_functor7</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a49"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__const__mem__functor0.html">bound_const_mem_functor0</a>&lt;<br>
 T_return, T_obj &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a50">retype</a> (const <a class="el" href="classsigc_1_1bound__const__mem__functor0.html">bound_const_mem_functor0</a>&lt;T_return, T_obj&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a50"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__const__mem__functor1.html">bound_const_mem_functor1</a>&lt;<br>
 T_return, T_obj, T_arg1 &gt;,<br>
 T_arg1 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a51">retype</a> (const <a class="el" href="classsigc_1_1bound__const__mem__functor1.html">bound_const_mem_functor1</a>&lt;T_return, T_obj, T_arg1&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a51"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1, class T_arg2&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__const__mem__functor2.html">bound_const_mem_functor2</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2 &gt;, T_arg1, T_arg2 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a52">retype</a> (const <a class="el" href="classsigc_1_1bound__const__mem__functor2.html">bound_const_mem_functor2</a>&lt;T_return, T_obj, T_arg1, T_arg2&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a52"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__const__mem__functor3.html">bound_const_mem_functor3</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3 &gt;, T_arg1,<br>
 T_arg2, T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a53">retype</a> (const <a class="el" href="classsigc_1_1bound__const__mem__functor3.html">bound_const_mem_functor3</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a53"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__const__mem__functor4.html">bound_const_mem_functor4</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4 &gt;,<br>
 T_arg1, T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a54">retype</a> (const <a class="el" href="classsigc_1_1bound__const__mem__functor4.html">bound_const_mem_functor4</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a54"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__const__mem__functor5.html">bound_const_mem_functor5</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5 &gt;,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a55">retype</a> (const <a class="el" href="classsigc_1_1bound__const__mem__functor5.html">bound_const_mem_functor5</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a55"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__const__mem__functor6.html">bound_const_mem_functor6</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6 &gt;, T_arg1, T_arg2,<br>
 T_arg3, T_arg4, T_arg5, T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a56">retype</a> (const <a class="el" href="classsigc_1_1bound__const__mem__functor6.html">bound_const_mem_functor6</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a56"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__const__mem__functor7.html">bound_const_mem_functor7</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a57">retype</a> (const <a class="el" href="classsigc_1_1bound__const__mem__functor7.html">bound_const_mem_functor7</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a57"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html">bound_volatile_mem_functor0</a>&lt;<br>
 T_return, T_obj &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a58">retype</a> (const <a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html">bound_volatile_mem_functor0</a>&lt;T_return, T_obj&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a58"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html">bound_volatile_mem_functor1</a>&lt;<br>
 T_return, T_obj, T_arg1 &gt;,<br>
 T_arg1 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a59">retype</a> (const <a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html">bound_volatile_mem_functor1</a>&lt;T_return, T_obj, T_arg1&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a59"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1, class T_arg2&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html">bound_volatile_mem_functor2</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2 &gt;, T_arg1, T_arg2 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a60">retype</a> (const <a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html">bound_volatile_mem_functor2</a>&lt;T_return, T_obj, T_arg1, T_arg2&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a60"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html">bound_volatile_mem_functor3</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3 &gt;, T_arg1,<br>
 T_arg2, T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a61">retype</a> (const <a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html">bound_volatile_mem_functor3</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a61"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html">bound_volatile_mem_functor4</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4 &gt;,<br>
 T_arg1, T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a62">retype</a> (const <a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html">bound_volatile_mem_functor4</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a62"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html">bound_volatile_mem_functor5</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5 &gt;,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a63">retype</a> (const <a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html">bound_volatile_mem_functor5</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a63"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html">bound_volatile_mem_functor6</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6 &gt;, T_arg1, T_arg2,<br>
 T_arg3, T_arg4, T_arg5, T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a64">retype</a> (const <a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html">bound_volatile_mem_functor6</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a64"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html">bound_volatile_mem_functor7</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a65">retype</a> (const <a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html">bound_volatile_mem_functor7</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a65"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">bound_const_volatile_mem_functor0</a>&lt;<br>
 T_return, T_obj &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a66">retype</a> (const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">bound_const_volatile_mem_functor0</a>&lt;T_return, T_obj&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a66"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">bound_const_volatile_mem_functor1</a>&lt;<br>
 T_return, T_obj, T_arg1 &gt;,<br>
 T_arg1 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a67">retype</a> (const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">bound_const_volatile_mem_functor1</a>&lt;T_return, T_obj, T_arg1&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a67"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1, class T_arg2&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">bound_const_volatile_mem_functor2</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2 &gt;, T_arg1, T_arg2 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a68">retype</a> (const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">bound_const_volatile_mem_functor2</a>&lt;T_return, T_obj, T_arg1, T_arg2&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a68"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">bound_const_volatile_mem_functor3</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3 &gt;, T_arg1,<br>
 T_arg2, T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a69">retype</a> (const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">bound_const_volatile_mem_functor3</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a69"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">bound_const_volatile_mem_functor4</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4 &gt;,<br>
 T_arg1, T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a70">retype</a> (const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">bound_const_volatile_mem_functor4</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a70"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">bound_const_volatile_mem_functor5</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5 &gt;,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a71">retype</a> (const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">bound_const_volatile_mem_functor5</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a71"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">bound_const_volatile_mem_functor6</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6 &gt;, T_arg1, T_arg2,<br>
 T_arg3, T_arg4, T_arg5, T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a72">retype</a> (const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">bound_const_volatile_mem_functor6</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a72"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">bound_const_volatile_mem_functor7</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a73">retype</a> (const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">bound_const_volatile_mem_functor7</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. </em> <a href="group__retype.html#a73"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_functor&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a74">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="structsigc_1_1retype__return__functor.html">retype_return_functor</a>&lt;T_return, T_functor&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="group__retype.html#a74"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_functor&gt; <a class="el" href="structsigc_1_1retype__return__functor.html">retype_return_functor</a>&lt; T_return,<br>
 T_functor &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__retype.html#a75">retype_return</a> (const T_functor&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__return__functor.html">sigc::retype_return_functor</a> which performs a C-style cast on the return value of the passed functor. </em> <a href="group__retype.html#a75"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_functor&gt; <a class="el" href="structsigc_1_1retype__return__functor.html">retype_return_functor</a>&lt; void,<br>
 T_functor &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__hide.html#a2">hide_return</a> (const T_functor&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__return__functor.html">sigc::retype_return_functor</a> which drops the return value of the passed functor. </em> <a href="group__hide.html#a2"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a0">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__mem__functor0.html">bound_mem_functor0</a>&lt;T_return, T_obj&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="group__mem__fun.html#a0"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a1">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__mem__functor1.html">bound_mem_functor1</a>&lt;T_return, T_obj, T_arg1&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="group__mem__fun.html#a1"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a2">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__mem__functor2.html">bound_mem_functor2</a>&lt;T_return, T_obj, T_arg1, T_arg2&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="group__mem__fun.html#a2"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a3">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__mem__functor3.html">bound_mem_functor3</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="group__mem__fun.html#a3"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a4">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__mem__functor4.html">bound_mem_functor4</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="group__mem__fun.html#a4"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a5">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__mem__functor5.html">bound_mem_functor5</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="group__mem__fun.html#a5"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a6">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__mem__functor6.html">bound_mem_functor6</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="group__mem__fun.html#a6"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a7">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__mem__functor7.html">bound_mem_functor7</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="group__mem__fun.html#a7"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a8">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__mem__functor0.html">bound_const_mem_functor0</a>&lt;T_return, T_obj&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="group__mem__fun.html#a8"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a9">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__mem__functor1.html">bound_const_mem_functor1</a>&lt;T_return, T_obj, T_arg1&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="group__mem__fun.html#a9"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a10">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__mem__functor2.html">bound_const_mem_functor2</a>&lt;T_return, T_obj, T_arg1, T_arg2&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="group__mem__fun.html#a10"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a11">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__mem__functor3.html">bound_const_mem_functor3</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="group__mem__fun.html#a11"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a12">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__mem__functor4.html">bound_const_mem_functor4</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="group__mem__fun.html#a12"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a13">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__mem__functor5.html">bound_const_mem_functor5</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="group__mem__fun.html#a13"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a14">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__mem__functor6.html">bound_const_mem_functor6</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="group__mem__fun.html#a14"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a15">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__mem__functor7.html">bound_const_mem_functor7</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="group__mem__fun.html#a15"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a16">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html">bound_volatile_mem_functor0</a>&lt;T_return, T_obj&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="group__mem__fun.html#a16"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a17">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html">bound_volatile_mem_functor1</a>&lt;T_return, T_obj, T_arg1&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="group__mem__fun.html#a17"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a18">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html">bound_volatile_mem_functor2</a>&lt;T_return, T_obj, T_arg1, T_arg2&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="group__mem__fun.html#a18"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a19">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html">bound_volatile_mem_functor3</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="group__mem__fun.html#a19"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a20">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html">bound_volatile_mem_functor4</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="group__mem__fun.html#a20"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a21">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html">bound_volatile_mem_functor5</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="group__mem__fun.html#a21"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a22">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html">bound_volatile_mem_functor6</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="group__mem__fun.html#a22"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a23">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html">bound_volatile_mem_functor7</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="group__mem__fun.html#a23"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a24">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">bound_const_volatile_mem_functor0</a>&lt;T_return, T_obj&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="group__mem__fun.html#a24"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a25">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">bound_const_volatile_mem_functor1</a>&lt;T_return, T_obj, T_arg1&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="group__mem__fun.html#a25"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a26">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">bound_const_volatile_mem_functor2</a>&lt;T_return, T_obj, T_arg1, T_arg2&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="group__mem__fun.html#a26"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a27">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">bound_const_volatile_mem_functor3</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="group__mem__fun.html#a27"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a28">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">bound_const_volatile_mem_functor4</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="group__mem__fun.html#a28"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a29">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">bound_const_volatile_mem_functor5</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="group__mem__fun.html#a29"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a30">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">bound_const_volatile_mem_functor6</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="group__mem__fun.html#a30"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a31">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">bound_const_volatile_mem_functor7</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. </em> <a href="group__mem__fun.html#a31"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj&gt; <a class="el" href="classsigc_1_1mem__functor0.html">mem_functor0</a>&lt;T_return, T_obj&gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a32">mem_fun0</a> (T_return(T_obj::* _A_func)())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor0.html">sigc::mem_functor0</a> which wraps a method. </em> <a href="group__mem__fun.html#a32"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_return, class T_obj&gt; <a class="el" href="classsigc_1_1mem__functor1.html">mem_functor1</a>&lt; T_return, T_obj,<br>
 T_arg1 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a33">mem_fun1</a> (T_return(T_obj::* _A_func)(T_arg1))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor1.html">sigc::mem_functor1</a> which wraps a method. </em> <a href="group__mem__fun.html#a33"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_return, class T_obj&gt; <a class="el" href="classsigc_1_1mem__functor2.html">mem_functor2</a>&lt; T_return, T_obj,<br>
 T_arg1, T_arg2 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a34">mem_fun2</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor2.html">sigc::mem_functor2</a> which wraps a method. </em> <a href="group__mem__fun.html#a34"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj&gt; <a class="el" href="classsigc_1_1mem__functor3.html">mem_functor3</a>&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a35">mem_fun3</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor3.html">sigc::mem_functor3</a> which wraps a method. </em> <a href="group__mem__fun.html#a35"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj&gt; <a class="el" href="classsigc_1_1mem__functor4.html">mem_functor4</a>&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a36">mem_fun4</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor4.html">sigc::mem_functor4</a> which wraps a method. </em> <a href="group__mem__fun.html#a36"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj&gt; <a class="el" href="classsigc_1_1mem__functor5.html">mem_functor5</a>&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a37">mem_fun5</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor5.html">sigc::mem_functor5</a> which wraps a method. </em> <a href="group__mem__fun.html#a37"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj&gt; <a class="el" href="classsigc_1_1mem__functor6.html">mem_functor6</a>&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5, T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a38">mem_fun6</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor6.html">sigc::mem_functor6</a> which wraps a method. </em> <a href="group__mem__fun.html#a38"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj&gt; <a class="el" href="classsigc_1_1mem__functor7.html">mem_functor7</a>&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5, T_arg6, T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a39">mem_fun7</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor7.html">sigc::mem_functor7</a> which wraps a method. </em> <a href="group__mem__fun.html#a39"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj&gt; <a class="el" href="classsigc_1_1const__mem__functor0.html">const_mem_functor0</a>&lt; T_return,<br>
 T_obj &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a40">mem_fun0</a> (T_return(T_obj::* _A_func)() const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor0.html">sigc::const_mem_functor0</a> which wraps a const method. </em> <a href="group__mem__fun.html#a40"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_return, class T_obj&gt; <a class="el" href="classsigc_1_1const__mem__functor1.html">const_mem_functor1</a>&lt; T_return,<br>
 T_obj, T_arg1 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a41">mem_fun1</a> (T_return(T_obj::* _A_func)(T_arg1) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor1.html">sigc::const_mem_functor1</a> which wraps a const method. </em> <a href="group__mem__fun.html#a41"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_return, class T_obj&gt; <a class="el" href="classsigc_1_1const__mem__functor2.html">const_mem_functor2</a>&lt; T_return,<br>
 T_obj, T_arg1, T_arg2 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a42">mem_fun2</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor2.html">sigc::const_mem_functor2</a> which wraps a const method. </em> <a href="group__mem__fun.html#a42"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj&gt; <a class="el" href="classsigc_1_1const__mem__functor3.html">const_mem_functor3</a>&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a43">mem_fun3</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor3.html">sigc::const_mem_functor3</a> which wraps a const method. </em> <a href="group__mem__fun.html#a43"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj&gt; <a class="el" href="classsigc_1_1const__mem__functor4.html">const_mem_functor4</a>&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a44">mem_fun4</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor4.html">sigc::const_mem_functor4</a> which wraps a const method. </em> <a href="group__mem__fun.html#a44"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj&gt; <a class="el" href="classsigc_1_1const__mem__functor5.html">const_mem_functor5</a>&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a45">mem_fun5</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor5.html">sigc::const_mem_functor5</a> which wraps a const method. </em> <a href="group__mem__fun.html#a45"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj&gt; <a class="el" href="classsigc_1_1const__mem__functor6.html">const_mem_functor6</a>&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5, T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a46">mem_fun6</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor6.html">sigc::const_mem_functor6</a> which wraps a const method. </em> <a href="group__mem__fun.html#a46"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj&gt; <a class="el" href="classsigc_1_1const__mem__functor7.html">const_mem_functor7</a>&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5, T_arg6, T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a47">mem_fun7</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor7.html">sigc::const_mem_functor7</a> which wraps a const method. </em> <a href="group__mem__fun.html#a47"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj&gt; <a class="el" href="classsigc_1_1volatile__mem__functor0.html">volatile_mem_functor0</a>&lt; T_return,<br>
 T_obj &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a48">mem_fun0</a> (T_return(T_obj::* _A_func)() volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor0.html">sigc::const_volatile_mem_functor0</a> which wraps a const volatile method. </em> <a href="group__mem__fun.html#a48"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_return, class T_obj&gt; <a class="el" href="classsigc_1_1volatile__mem__functor1.html">volatile_mem_functor1</a>&lt; T_return,<br>
 T_obj, T_arg1 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a49">mem_fun1</a> (T_return(T_obj::* _A_func)(T_arg1) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor1.html">sigc::const_volatile_mem_functor1</a> which wraps a const volatile method. </em> <a href="group__mem__fun.html#a49"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_return, class T_obj&gt; <a class="el" href="classsigc_1_1volatile__mem__functor2.html">volatile_mem_functor2</a>&lt; T_return,<br>
 T_obj, T_arg1, T_arg2 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a50">mem_fun2</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor2.html">sigc::const_volatile_mem_functor2</a> which wraps a const volatile method. </em> <a href="group__mem__fun.html#a50"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj&gt; <a class="el" href="classsigc_1_1volatile__mem__functor3.html">volatile_mem_functor3</a>&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a51">mem_fun3</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor3.html">sigc::const_volatile_mem_functor3</a> which wraps a const volatile method. </em> <a href="group__mem__fun.html#a51"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj&gt; <a class="el" href="classsigc_1_1volatile__mem__functor4.html">volatile_mem_functor4</a>&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a52">mem_fun4</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor4.html">sigc::const_volatile_mem_functor4</a> which wraps a const volatile method. </em> <a href="group__mem__fun.html#a52"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj&gt; <a class="el" href="classsigc_1_1volatile__mem__functor5.html">volatile_mem_functor5</a>&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a53">mem_fun5</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor5.html">sigc::const_volatile_mem_functor5</a> which wraps a const volatile method. </em> <a href="group__mem__fun.html#a53"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj&gt; <a class="el" href="classsigc_1_1volatile__mem__functor6.html">volatile_mem_functor6</a>&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5, T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a54">mem_fun6</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor6.html">sigc::const_volatile_mem_functor6</a> which wraps a const volatile method. </em> <a href="group__mem__fun.html#a54"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj&gt; <a class="el" href="classsigc_1_1volatile__mem__functor7.html">volatile_mem_functor7</a>&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5, T_arg6, T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a55">mem_fun7</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor7.html">sigc::const_volatile_mem_functor7</a> which wraps a const volatile method. </em> <a href="group__mem__fun.html#a55"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__mem__functor0.html">bound_mem_functor0</a>&lt; T_return,<br>
 T_obj &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a56">mem_fun0</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor0.html">sigc::bound_mem_functor0</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a56"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__mem__functor1.html">bound_mem_functor1</a>&lt; T_return,<br>
 T_obj, T_arg1 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a57">mem_fun1</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor1.html">sigc::bound_mem_functor1</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a57"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__mem__functor2.html">bound_mem_functor2</a>&lt; T_return,<br>
 T_obj, T_arg1, T_arg2 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a58">mem_fun2</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor2.html">sigc::bound_mem_functor2</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a58"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__mem__functor3.html">bound_mem_functor3</a>&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a59">mem_fun3</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor3.html">sigc::bound_mem_functor3</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a59"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__mem__functor4.html">bound_mem_functor4</a>&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a60">mem_fun4</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor4.html">sigc::bound_mem_functor4</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a60"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__mem__functor5.html">bound_mem_functor5</a>&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a61">mem_fun5</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor5.html">sigc::bound_mem_functor5</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a61"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__mem__functor6.html">bound_mem_functor6</a>&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5, T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a62">mem_fun6</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor6.html">sigc::bound_mem_functor6</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a62"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__mem__functor7.html">bound_mem_functor7</a>&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5, T_arg6, T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a63">mem_fun7</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor7.html">sigc::bound_mem_functor7</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a63"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__const__mem__functor0.html">bound_const_mem_functor0</a>&lt;<br>
 T_return, T_obj &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a64">mem_fun0</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)() const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor0.html">sigc::bound_const_mem_functor0</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a64"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__const__mem__functor0.html">bound_const_mem_functor0</a>&lt;<br>
 T_return, T_obj &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a65">mem_fun0</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)() const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor0.html">sigc::bound_const_mem_functor0</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a65"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__const__mem__functor1.html">bound_const_mem_functor1</a>&lt;<br>
 T_return, T_obj, T_arg1 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a66">mem_fun1</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor1.html">sigc::bound_const_mem_functor1</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a66"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__const__mem__functor1.html">bound_const_mem_functor1</a>&lt;<br>
 T_return, T_obj, T_arg1 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a67">mem_fun1</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor1.html">sigc::bound_const_mem_functor1</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a67"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__const__mem__functor2.html">bound_const_mem_functor2</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a68">mem_fun2</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor2.html">sigc::bound_const_mem_functor2</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a68"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__const__mem__functor2.html">bound_const_mem_functor2</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a69">mem_fun2</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor2.html">sigc::bound_const_mem_functor2</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a69"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__const__mem__functor3.html">bound_const_mem_functor3</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a70">mem_fun3</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor3.html">sigc::bound_const_mem_functor3</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a70"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__const__mem__functor3.html">bound_const_mem_functor3</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a71">mem_fun3</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor3.html">sigc::bound_const_mem_functor3</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a71"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__const__mem__functor4.html">bound_const_mem_functor4</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a72">mem_fun4</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor4.html">sigc::bound_const_mem_functor4</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a72"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__const__mem__functor4.html">bound_const_mem_functor4</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a73">mem_fun4</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor4.html">sigc::bound_const_mem_functor4</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a73"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__const__mem__functor5.html">bound_const_mem_functor5</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a74">mem_fun5</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor5.html">sigc::bound_const_mem_functor5</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a74"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__const__mem__functor5.html">bound_const_mem_functor5</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a75">mem_fun5</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor5.html">sigc::bound_const_mem_functor5</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a75"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__const__mem__functor6.html">bound_const_mem_functor6</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a76">mem_fun6</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor6.html">sigc::bound_const_mem_functor6</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a76"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__const__mem__functor6.html">bound_const_mem_functor6</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a77">mem_fun6</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor6.html">sigc::bound_const_mem_functor6</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a77"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__const__mem__functor7.html">bound_const_mem_functor7</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a78">mem_fun7</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor7.html">sigc::bound_const_mem_functor7</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a78"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__const__mem__functor7.html">bound_const_mem_functor7</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a79">mem_fun7</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor7.html">sigc::bound_const_mem_functor7</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a79"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html">bound_volatile_mem_functor0</a>&lt;<br>
 T_return, T_obj &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a80">mem_fun0</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)() volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">sigc::bound_const_volatile_mem_functor0</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a80"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html">bound_volatile_mem_functor1</a>&lt;<br>
 T_return, T_obj, T_arg1 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a81">mem_fun1</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">sigc::bound_const_volatile_mem_functor1</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a81"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html">bound_volatile_mem_functor2</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a82">mem_fun2</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">sigc::bound_const_volatile_mem_functor2</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a82"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html">bound_volatile_mem_functor3</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a83">mem_fun3</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">sigc::bound_const_volatile_mem_functor3</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a83"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html">bound_volatile_mem_functor4</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a84">mem_fun4</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">sigc::bound_const_volatile_mem_functor4</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a84"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html">bound_volatile_mem_functor5</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a85">mem_fun5</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">sigc::bound_const_volatile_mem_functor5</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a85"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html">bound_volatile_mem_functor6</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a86">mem_fun6</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">sigc::bound_const_volatile_mem_functor6</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a86"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html">bound_volatile_mem_functor7</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a87">mem_fun7</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">sigc::bound_const_volatile_mem_functor7</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a87"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">bound_const_volatile_mem_functor0</a>&lt;<br>
 T_return, T_obj &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a88">mem_fun0</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)() const volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">sigc::bound_const_volatile_mem_functor0</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a88"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">bound_const_volatile_mem_functor1</a>&lt;<br>
 T_return, T_obj, T_arg1 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a89">mem_fun1</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1) const volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">sigc::bound_const_volatile_mem_functor1</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a89"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">bound_const_volatile_mem_functor2</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a90">mem_fun2</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2) const volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">sigc::bound_const_volatile_mem_functor2</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a90"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">bound_const_volatile_mem_functor3</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a91">mem_fun3</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3) const volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">sigc::bound_const_volatile_mem_functor3</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a91"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">bound_const_volatile_mem_functor4</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a92">mem_fun4</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">sigc::bound_const_volatile_mem_functor4</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a92"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">bound_const_volatile_mem_functor5</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a93">mem_fun5</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">sigc::bound_const_volatile_mem_functor5</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a93"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">bound_const_volatile_mem_functor6</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a94">mem_fun6</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">sigc::bound_const_volatile_mem_functor6</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a94"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">bound_const_volatile_mem_functor7</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a95">mem_fun7</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">sigc::bound_const_volatile_mem_functor7</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a95"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj&gt; <a class="el" href="classsigc_1_1mem__functor0.html">mem_functor0</a>&lt;T_return, T_obj&gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a96">mem_fun</a> (T_return(T_obj::* _A_func)())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor0.html">sigc::mem_functor0</a> which wraps a method. </em> <a href="group__mem__fun.html#a96"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_return, class T_obj&gt; <a class="el" href="classsigc_1_1mem__functor1.html">mem_functor1</a>&lt; T_return, T_obj,<br>
 T_arg1 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a97">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor1.html">sigc::mem_functor1</a> which wraps a method. </em> <a href="group__mem__fun.html#a97"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_return, class T_obj&gt; <a class="el" href="classsigc_1_1mem__functor2.html">mem_functor2</a>&lt; T_return, T_obj,<br>
 T_arg1, T_arg2 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a98">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor2.html">sigc::mem_functor2</a> which wraps a method. </em> <a href="group__mem__fun.html#a98"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj&gt; <a class="el" href="classsigc_1_1mem__functor3.html">mem_functor3</a>&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a99">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor3.html">sigc::mem_functor3</a> which wraps a method. </em> <a href="group__mem__fun.html#a99"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj&gt; <a class="el" href="classsigc_1_1mem__functor4.html">mem_functor4</a>&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a100">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor4.html">sigc::mem_functor4</a> which wraps a method. </em> <a href="group__mem__fun.html#a100"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj&gt; <a class="el" href="classsigc_1_1mem__functor5.html">mem_functor5</a>&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a101">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor5.html">sigc::mem_functor5</a> which wraps a method. </em> <a href="group__mem__fun.html#a101"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj&gt; <a class="el" href="classsigc_1_1mem__functor6.html">mem_functor6</a>&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5, T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a102">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor6.html">sigc::mem_functor6</a> which wraps a method. </em> <a href="group__mem__fun.html#a102"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj&gt; <a class="el" href="classsigc_1_1mem__functor7.html">mem_functor7</a>&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5, T_arg6, T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a103">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor7.html">sigc::mem_functor7</a> which wraps a method. </em> <a href="group__mem__fun.html#a103"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj&gt; <a class="el" href="classsigc_1_1const__mem__functor0.html">const_mem_functor0</a>&lt; T_return,<br>
 T_obj &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a104">mem_fun</a> (T_return(T_obj::* _A_func)() const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor0.html">sigc::const_mem_functor0</a> which wraps a const method. </em> <a href="group__mem__fun.html#a104"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_return, class T_obj&gt; <a class="el" href="classsigc_1_1const__mem__functor1.html">const_mem_functor1</a>&lt; T_return,<br>
 T_obj, T_arg1 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a105">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor1.html">sigc::const_mem_functor1</a> which wraps a const method. </em> <a href="group__mem__fun.html#a105"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_return, class T_obj&gt; <a class="el" href="classsigc_1_1const__mem__functor2.html">const_mem_functor2</a>&lt; T_return,<br>
 T_obj, T_arg1, T_arg2 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a106">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor2.html">sigc::const_mem_functor2</a> which wraps a const method. </em> <a href="group__mem__fun.html#a106"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj&gt; <a class="el" href="classsigc_1_1const__mem__functor3.html">const_mem_functor3</a>&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a107">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor3.html">sigc::const_mem_functor3</a> which wraps a const method. </em> <a href="group__mem__fun.html#a107"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj&gt; <a class="el" href="classsigc_1_1const__mem__functor4.html">const_mem_functor4</a>&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a108">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor4.html">sigc::const_mem_functor4</a> which wraps a const method. </em> <a href="group__mem__fun.html#a108"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj&gt; <a class="el" href="classsigc_1_1const__mem__functor5.html">const_mem_functor5</a>&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a109">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor5.html">sigc::const_mem_functor5</a> which wraps a const method. </em> <a href="group__mem__fun.html#a109"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj&gt; <a class="el" href="classsigc_1_1const__mem__functor6.html">const_mem_functor6</a>&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5, T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a110">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor6.html">sigc::const_mem_functor6</a> which wraps a const method. </em> <a href="group__mem__fun.html#a110"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj&gt; <a class="el" href="classsigc_1_1const__mem__functor7.html">const_mem_functor7</a>&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5, T_arg6, T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a111">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor7.html">sigc::const_mem_functor7</a> which wraps a const method. </em> <a href="group__mem__fun.html#a111"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj&gt; <a class="el" href="classsigc_1_1volatile__mem__functor0.html">volatile_mem_functor0</a>&lt; T_return,<br>
 T_obj &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a112">mem_fun</a> (T_return(T_obj::* _A_func)() volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor0.html">sigc::const_volatile_mem_functor0</a> which wraps a const volatile method. </em> <a href="group__mem__fun.html#a112"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_return, class T_obj&gt; <a class="el" href="classsigc_1_1volatile__mem__functor1.html">volatile_mem_functor1</a>&lt; T_return,<br>
 T_obj, T_arg1 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a113">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor1.html">sigc::const_volatile_mem_functor1</a> which wraps a const volatile method. </em> <a href="group__mem__fun.html#a113"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_return, class T_obj&gt; <a class="el" href="classsigc_1_1volatile__mem__functor2.html">volatile_mem_functor2</a>&lt; T_return,<br>
 T_obj, T_arg1, T_arg2 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a114">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor2.html">sigc::const_volatile_mem_functor2</a> which wraps a const volatile method. </em> <a href="group__mem__fun.html#a114"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj&gt; <a class="el" href="classsigc_1_1volatile__mem__functor3.html">volatile_mem_functor3</a>&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a115">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor3.html">sigc::const_volatile_mem_functor3</a> which wraps a const volatile method. </em> <a href="group__mem__fun.html#a115"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj&gt; <a class="el" href="classsigc_1_1volatile__mem__functor4.html">volatile_mem_functor4</a>&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a116">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor4.html">sigc::const_volatile_mem_functor4</a> which wraps a const volatile method. </em> <a href="group__mem__fun.html#a116"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj&gt; <a class="el" href="classsigc_1_1volatile__mem__functor5.html">volatile_mem_functor5</a>&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a117">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor5.html">sigc::const_volatile_mem_functor5</a> which wraps a const volatile method. </em> <a href="group__mem__fun.html#a117"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj&gt; <a class="el" href="classsigc_1_1volatile__mem__functor6.html">volatile_mem_functor6</a>&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5, T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a118">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor6.html">sigc::const_volatile_mem_functor6</a> which wraps a const volatile method. </em> <a href="group__mem__fun.html#a118"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj&gt; <a class="el" href="classsigc_1_1volatile__mem__functor7.html">volatile_mem_functor7</a>&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5, T_arg6, T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a119">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor7.html">sigc::const_volatile_mem_functor7</a> which wraps a const volatile method. </em> <a href="group__mem__fun.html#a119"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__mem__functor0.html">bound_mem_functor0</a>&lt; T_return,<br>
 T_obj &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a120">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor0.html">sigc::bound_mem_functor0</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a120"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__mem__functor1.html">bound_mem_functor1</a>&lt; T_return,<br>
 T_obj, T_arg1 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a121">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor1.html">sigc::bound_mem_functor1</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a121"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__mem__functor2.html">bound_mem_functor2</a>&lt; T_return,<br>
 T_obj, T_arg1, T_arg2 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a122">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor2.html">sigc::bound_mem_functor2</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a122"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__mem__functor3.html">bound_mem_functor3</a>&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a123">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor3.html">sigc::bound_mem_functor3</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a123"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__mem__functor4.html">bound_mem_functor4</a>&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a124">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor4.html">sigc::bound_mem_functor4</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a124"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__mem__functor5.html">bound_mem_functor5</a>&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a125">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor5.html">sigc::bound_mem_functor5</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a125"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__mem__functor6.html">bound_mem_functor6</a>&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5, T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a126">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor6.html">sigc::bound_mem_functor6</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a126"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__mem__functor7.html">bound_mem_functor7</a>&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5, T_arg6, T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a127">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor7.html">sigc::bound_mem_functor7</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a127"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__const__mem__functor0.html">bound_const_mem_functor0</a>&lt;<br>
 T_return, T_obj &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a128">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)() const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor0.html">sigc::bound_const_mem_functor0</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a128"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__const__mem__functor0.html">bound_const_mem_functor0</a>&lt;<br>
 T_return, T_obj &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a129">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)() const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor0.html">sigc::bound_const_mem_functor0</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a129"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__const__mem__functor1.html">bound_const_mem_functor1</a>&lt;<br>
 T_return, T_obj, T_arg1 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a130">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor1.html">sigc::bound_const_mem_functor1</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a130"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__const__mem__functor1.html">bound_const_mem_functor1</a>&lt;<br>
 T_return, T_obj, T_arg1 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a131">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor1.html">sigc::bound_const_mem_functor1</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a131"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__const__mem__functor2.html">bound_const_mem_functor2</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a132">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor2.html">sigc::bound_const_mem_functor2</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a132"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__const__mem__functor2.html">bound_const_mem_functor2</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a133">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor2.html">sigc::bound_const_mem_functor2</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a133"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__const__mem__functor3.html">bound_const_mem_functor3</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a134">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor3.html">sigc::bound_const_mem_functor3</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a134"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__const__mem__functor3.html">bound_const_mem_functor3</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a135">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor3.html">sigc::bound_const_mem_functor3</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a135"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__const__mem__functor4.html">bound_const_mem_functor4</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a136">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor4.html">sigc::bound_const_mem_functor4</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a136"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__const__mem__functor4.html">bound_const_mem_functor4</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a137">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor4.html">sigc::bound_const_mem_functor4</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a137"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__const__mem__functor5.html">bound_const_mem_functor5</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a138">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor5.html">sigc::bound_const_mem_functor5</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a138"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__const__mem__functor5.html">bound_const_mem_functor5</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a139">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor5.html">sigc::bound_const_mem_functor5</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a139"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__const__mem__functor6.html">bound_const_mem_functor6</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a140">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor6.html">sigc::bound_const_mem_functor6</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a140"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__const__mem__functor6.html">bound_const_mem_functor6</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a141">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor6.html">sigc::bound_const_mem_functor6</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a141"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__const__mem__functor7.html">bound_const_mem_functor7</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a142">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor7.html">sigc::bound_const_mem_functor7</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a142"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__const__mem__functor7.html">bound_const_mem_functor7</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a143">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor7.html">sigc::bound_const_mem_functor7</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a143"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html">bound_volatile_mem_functor0</a>&lt;<br>
 T_return, T_obj &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a144">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)() volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">sigc::bound_const_volatile_mem_functor0</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a144"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html">bound_volatile_mem_functor1</a>&lt;<br>
 T_return, T_obj, T_arg1 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a145">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">sigc::bound_const_volatile_mem_functor1</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a145"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html">bound_volatile_mem_functor2</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a146">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">sigc::bound_const_volatile_mem_functor2</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a146"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html">bound_volatile_mem_functor3</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a147">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">sigc::bound_const_volatile_mem_functor3</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a147"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html">bound_volatile_mem_functor4</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a148">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">sigc::bound_const_volatile_mem_functor4</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a148"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html">bound_volatile_mem_functor5</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a149">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">sigc::bound_const_volatile_mem_functor5</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a149"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html">bound_volatile_mem_functor6</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a150">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">sigc::bound_const_volatile_mem_functor6</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a150"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html">bound_volatile_mem_functor7</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a151">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">sigc::bound_const_volatile_mem_functor7</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a151"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">bound_const_volatile_mem_functor0</a>&lt;<br>
 T_return, T_obj &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a152">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)() const volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">sigc::bound_const_volatile_mem_functor0</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a152"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">bound_const_volatile_mem_functor1</a>&lt;<br>
 T_return, T_obj, T_arg1 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a153">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1) const volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">sigc::bound_const_volatile_mem_functor1</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a153"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">bound_const_volatile_mem_functor2</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a154">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2) const volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">sigc::bound_const_volatile_mem_functor2</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a154"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">bound_const_volatile_mem_functor3</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a155">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3) const volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">sigc::bound_const_volatile_mem_functor3</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a155"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">bound_const_volatile_mem_functor4</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a156">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">sigc::bound_const_volatile_mem_functor4</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a156"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">bound_const_volatile_mem_functor5</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a157">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">sigc::bound_const_volatile_mem_functor5</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a157"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">bound_const_volatile_mem_functor6</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a158">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">sigc::bound_const_volatile_mem_functor6</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a158"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2&gt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">bound_const_volatile_mem_functor7</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__fun.html#a159">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">sigc::bound_const_volatile_mem_functor7</a> which encapsulates a method and an object instance. </em> <a href="group__mem__fun.html#a159"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return&gt; <a class="el" href="classsigc_1_1pointer__functor0.html">pointer_functor0</a>&lt;T_return&gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__ptr__fun.html#a0">ptr_fun0</a> (T_return(* _A_func)())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor0.html">sigc::pointer_functor0</a> which wraps an existing non-member function. </em> <a href="group__ptr__fun.html#a0"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_return&gt; <a class="el" href="classsigc_1_1pointer__functor1.html">pointer_functor1</a>&lt; T_arg1,<br>
 T_return &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__ptr__fun.html#a1">ptr_fun1</a> (T_return(* _A_func)(T_arg1))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor1.html">sigc::pointer_functor1</a> which wraps an existing non-member function. </em> <a href="group__ptr__fun.html#a1"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_return&gt; <a class="el" href="classsigc_1_1pointer__functor2.html">pointer_functor2</a>&lt; T_arg1,<br>
 T_arg2, T_return &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__ptr__fun.html#a2">ptr_fun2</a> (T_return(* _A_func)(T_arg1, T_arg2))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor2.html">sigc::pointer_functor2</a> which wraps an existing non-member function. </em> <a href="group__ptr__fun.html#a2"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_return&gt; <a class="el" href="classsigc_1_1pointer__functor3.html">pointer_functor3</a>&lt; T_arg1,<br>
 T_arg2, T_arg3, T_return &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__ptr__fun.html#a3">ptr_fun3</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor3.html">sigc::pointer_functor3</a> which wraps an existing non-member function. </em> <a href="group__ptr__fun.html#a3"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return&gt; <a class="el" href="classsigc_1_1pointer__functor4.html">pointer_functor4</a>&lt; T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_return &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__ptr__fun.html#a4">ptr_fun4</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor4.html">sigc::pointer_functor4</a> which wraps an existing non-member function. </em> <a href="group__ptr__fun.html#a4"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return&gt; <a class="el" href="classsigc_1_1pointer__functor5.html">pointer_functor5</a>&lt; T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_return &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__ptr__fun.html#a5">ptr_fun5</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor5.html">sigc::pointer_functor5</a> which wraps an existing non-member function. </em> <a href="group__ptr__fun.html#a5"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return&gt; <a class="el" href="classsigc_1_1pointer__functor6.html">pointer_functor6</a>&lt; T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_return &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__ptr__fun.html#a6">ptr_fun6</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor6.html">sigc::pointer_functor6</a> which wraps an existing non-member function. </em> <a href="group__ptr__fun.html#a6"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return&gt; <a class="el" href="classsigc_1_1pointer__functor7.html">pointer_functor7</a>&lt; T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7, T_return &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__ptr__fun.html#a7">ptr_fun7</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor7.html">sigc::pointer_functor7</a> which wraps an existing non-member function. </em> <a href="group__ptr__fun.html#a7"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return&gt; <a class="el" href="classsigc_1_1pointer__functor0.html">pointer_functor0</a>&lt;T_return&gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__ptr__fun.html#a8">ptr_fun</a> (T_return(* _A_func)())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor0.html">sigc::pointer_functor0</a> which wraps an existing non-member function. </em> <a href="group__ptr__fun.html#a8"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_return&gt; <a class="el" href="classsigc_1_1pointer__functor1.html">pointer_functor1</a>&lt; T_arg1,<br>
 T_return &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__ptr__fun.html#a9">ptr_fun</a> (T_return(* _A_func)(T_arg1))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor1.html">sigc::pointer_functor1</a> which wraps an existing non-member function. </em> <a href="group__ptr__fun.html#a9"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_return&gt; <a class="el" href="classsigc_1_1pointer__functor2.html">pointer_functor2</a>&lt; T_arg1,<br>
 T_arg2, T_return &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__ptr__fun.html#a10">ptr_fun</a> (T_return(* _A_func)(T_arg1, T_arg2))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor2.html">sigc::pointer_functor2</a> which wraps an existing non-member function. </em> <a href="group__ptr__fun.html#a10"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_return&gt; <a class="el" href="classsigc_1_1pointer__functor3.html">pointer_functor3</a>&lt; T_arg1,<br>
 T_arg2, T_arg3, T_return &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__ptr__fun.html#a11">ptr_fun</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor3.html">sigc::pointer_functor3</a> which wraps an existing non-member function. </em> <a href="group__ptr__fun.html#a11"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return&gt; <a class="el" href="classsigc_1_1pointer__functor4.html">pointer_functor4</a>&lt; T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_return &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__ptr__fun.html#a12">ptr_fun</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor4.html">sigc::pointer_functor4</a> which wraps an existing non-member function. </em> <a href="group__ptr__fun.html#a12"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return&gt; <a class="el" href="classsigc_1_1pointer__functor5.html">pointer_functor5</a>&lt; T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_return &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__ptr__fun.html#a13">ptr_fun</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor5.html">sigc::pointer_functor5</a> which wraps an existing non-member function. </em> <a href="group__ptr__fun.html#a13"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return&gt; <a class="el" href="classsigc_1_1pointer__functor6.html">pointer_functor6</a>&lt; T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_return &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__ptr__fun.html#a14">ptr_fun</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor6.html">sigc::pointer_functor6</a> which wraps an existing non-member function. </em> <a href="group__ptr__fun.html#a14"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return&gt; <a class="el" href="classsigc_1_1pointer__functor7.html">pointer_functor7</a>&lt; T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7, T_return &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__ptr__fun.html#a15">ptr_fun</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor7.html">sigc::pointer_functor7</a> which wraps an existing non-member function. </em> <a href="group__ptr__fun.html#a15"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_type&gt; <a class="el" href="structsigc_1_1reference__wrapper.html">reference_wrapper</a>&lt;T_type&gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a390">ref</a> (T_type&amp; v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a reference wrapper. </em> <a href="#a390"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_type&gt; <a class="el" href="structsigc_1_1const__reference__wrapper.html">const_reference_wrapper</a>&lt;T_type&gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a391">ref</a> (const T_type&amp; v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a const reference wrapper. </em> <a href="#a391"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_type&gt; T_type&amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a392">unwrap</a> (T_type&amp; v)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_type&gt; const T_type&amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a393">unwrap</a> (const T_type&amp; v)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_type&gt; T_type&amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a394">unwrap</a> (const <a class="el" href="structsigc_1_1reference__wrapper.html">reference_wrapper</a>&lt;T_type&gt;&amp; v)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_type&gt; const T_type&amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a395">unwrap</a> (const <a class="el" href="structsigc_1_1const__reference__wrapper.html">const_reference_wrapper</a>&lt;T_type&gt;&amp; v)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_action, class T_functor&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__functors.html#a0">visit_each</a> (const T_action&amp; _A_action, const T_functor&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function performs a functor on each of the targets of a functor. </em> <a href="group__functors.html#a0"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_type, class T_action, class T_functor&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__functors.html#a1">visit_each_type</a> (const T_action&amp; _A_action, const T_functor&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function performs a functor on each of the targets of a functor limited to a restricted type. </em> <a href="group__functors.html#a1"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>const lambda&lt;<a class="el" href="structsigc_1_1internal_1_1lambda__select1.html">internal::lambda_select1</a>&gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a0">_1</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>const lambda&lt;<a class="el" href="structsigc_1_1internal_1_1lambda__select2.html">internal::lambda_select2</a>&gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a1">_2</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>const lambda&lt;<a class="el" href="structsigc_1_1internal_1_1lambda__select3.html">internal::lambda_select3</a>&gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a2">_3</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>const lambda&lt;<a class="el" href="structsigc_1_1internal_1_1lambda__select4.html">internal::lambda_select4</a>&gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a3">_4</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>const lambda&lt;<a class="el" href="structsigc_1_1internal_1_1lambda__select5.html">internal::lambda_select5</a>&gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a4">_5</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>const lambda&lt;<a class="el" href="structsigc_1_1internal_1_1lambda__select6.html">internal::lambda_select6</a>&gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a5">_6</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>const lambda&lt;<a class="el" href="structsigc_1_1internal_1_1lambda__select7.html">internal::lambda_select7</a>&gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespacesigc.html#a6">_7</a></td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a name="a136" doxytag="sigc::dynamic_cast_"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_type, class T_arg&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator__convert.html">lambda_operator_convert</a>&lt;<a class="el" href="structsigc_1_1cast__.html">cast_</a>&lt;<a class="el" href="structsigc_1_1dynamic__.html">dynamic_</a>&gt;, T_type, T_arg&gt; &gt; dynamic_cast_ </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg&gt;&amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>a</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a31" doxytag="sigc::exception_catch"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_functor, class T_catcher&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structsigc_1_1exception__catch__functor.html">exception_catch_functor</a>&lt;T_functor, T_catcher&gt; exception_catch </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_functor&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const T_catcher&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_catcher</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a39" doxytag="sigc::group"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_functor, class T_type1, class T_type2, class T_type3&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__group3.html">lambda_group3</a>&lt;T_functor, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_type1&gt;::type,typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_type2&gt;::type,typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_type3&gt;::type&gt; &gt; group </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_functor&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_type1&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_type2&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_type3&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_3</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a38" doxytag="sigc::group"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_functor, class T_type1, class T_type2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__group2.html">lambda_group2</a>&lt;T_functor, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_type1&gt;::type,typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_type2&gt;::type&gt; &gt; group </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_functor&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_type1&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_type2&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a37" doxytag="sigc::group"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_functor, class T_type1&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__group1.html">lambda_group1</a>&lt;T_functor, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_type1&gt;::type&gt; &gt; group </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_functor&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_type1&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_1</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a132" doxytag="sigc::operator &"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator__unary.html">lambda_operator_unary</a>&lt;<a class="el" href="structsigc_1_1unary__other.html">unary_other</a>&lt;<a class="el" href="structsigc_1_1address.html">address</a>&gt;, T_arg&gt; &gt; operator&amp; </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg&gt;&amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>a</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a66" doxytag="sigc::operator &"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<a class="el" href="structsigc_1_1and__.html">and_</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; operator&amp; </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_arg1&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a65" doxytag="sigc::operator &"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<a class="el" href="structsigc_1_1and__.html">and_</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; operator&amp; </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_arg2&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a64" doxytag="sigc::operator &"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<a class="el" href="structsigc_1_1and__.html">and_</a>&gt;, T_arg1, T_arg2&gt; &gt; operator&amp; </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a75" doxytag="sigc::operator &&"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1logical.html">logical</a>&lt;<a class="el" href="structsigc_1_1and__.html">and_</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; operator&amp;&amp; </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_arg1&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a74" doxytag="sigc::operator &&"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1logical.html">logical</a>&lt;<a class="el" href="structsigc_1_1and__.html">and_</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; operator&amp;&amp; </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_arg2&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a73" doxytag="sigc::operator &&"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1logical.html">logical</a>&lt;<a class="el" href="structsigc_1_1and__.html">and_</a>&gt;, T_arg1, T_arg2&gt; &gt; operator&amp;&amp; </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a120" doxytag="sigc::operator &="></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<a class="el" href="structsigc_1_1and__.html">and_</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; operator&amp;= </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_arg1&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a119" doxytag="sigc::operator &="></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<a class="el" href="structsigc_1_1and__.html">and_</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; operator&amp;= </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_arg2&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a118" doxytag="sigc::operator &="></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<a class="el" href="structsigc_1_1and__.html">and_</a>&gt;, T_arg1, T_arg2&gt; &gt; operator&amp;= </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a133" doxytag="sigc::operator *"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator__unary.html">lambda_operator_unary</a>&lt;<a class="el" href="structsigc_1_1unary__other.html">unary_other</a>&lt;<a class="el" href="structsigc_1_1dereference.html">dereference</a>&gt;, T_arg&gt; &gt; operator* </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg&gt;&amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>a</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a51" doxytag="sigc::operator *"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<a class="el" href="structsigc_1_1multiplies.html">multiplies</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; operator* </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_arg1&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a50" doxytag="sigc::operator *"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<a class="el" href="structsigc_1_1multiplies.html">multiplies</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; operator* </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_arg2&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a49" doxytag="sigc::operator *"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<a class="el" href="structsigc_1_1multiplies.html">multiplies</a>&gt;, T_arg1, T_arg2&gt; &gt; operator* </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a105" doxytag="sigc::operator *="></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<a class="el" href="structsigc_1_1multiplies.html">multiplies</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; operator*= </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_arg1&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a104" doxytag="sigc::operator *="></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<a class="el" href="structsigc_1_1multiplies.html">multiplies</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; operator*= </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_arg2&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a103" doxytag="sigc::operator *="></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<a class="el" href="structsigc_1_1multiplies.html">multiplies</a>&gt;, T_arg1, T_arg2&gt; &gt; operator*= </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a131" doxytag="sigc::operator!"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator__unary.html">lambda_operator_unary</a>&lt;<a class="el" href="structsigc_1_1unary__logical.html">unary_logical</a>&lt;<a class="el" href="structsigc_1_1not__.html">not_</a>&gt;, T_arg&gt; &gt; operator! </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg&gt;&amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>a</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a96" doxytag="sigc::operator!="></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<a class="el" href="structsigc_1_1not__equal__to.html">not_equal_to</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; operator!= </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_arg1&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a95" doxytag="sigc::operator!="></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<a class="el" href="structsigc_1_1not__equal__to.html">not_equal_to</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; operator!= </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_arg2&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a94" doxytag="sigc::operator!="></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<a class="el" href="structsigc_1_1not__equal__to.html">not_equal_to</a>&gt;, T_arg1, T_arg2&gt; &gt; operator!= </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a57" doxytag="sigc::operator%"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<a class="el" href="structsigc_1_1modulus.html">modulus</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; operator% </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_arg1&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a56" doxytag="sigc::operator%"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<a class="el" href="structsigc_1_1modulus.html">modulus</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; operator% </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_arg2&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a55" doxytag="sigc::operator%"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<a class="el" href="structsigc_1_1modulus.html">modulus</a>&gt;, T_arg1, T_arg2&gt; &gt; operator% </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a111" doxytag="sigc::operator%="></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<a class="el" href="structsigc_1_1modulus.html">modulus</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; operator%= </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_arg1&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a110" doxytag="sigc::operator%="></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<a class="el" href="structsigc_1_1modulus.html">modulus</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; operator%= </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_arg2&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a109" doxytag="sigc::operator%="></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<a class="el" href="structsigc_1_1modulus.html">modulus</a>&gt;, T_arg1, T_arg2&gt; &gt; operator%= </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a45" doxytag="sigc::operator+"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<a class="el" href="structsigc_1_1plus.html">plus</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; operator+ </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_arg1&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a44" doxytag="sigc::operator+"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<a class="el" href="structsigc_1_1plus.html">plus</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; operator+ </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_arg2&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a43" doxytag="sigc::operator+"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<a class="el" href="structsigc_1_1plus.html">plus</a>&gt;, T_arg1, T_arg2&gt; &gt; operator+ </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a127" doxytag="sigc::operator++"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator__unary.html">lambda_operator_unary</a>&lt;<a class="el" href="structsigc_1_1unary__arithmetic.html">unary_arithmetic</a>&lt;<a class="el" href="structsigc_1_1pre__increment.html">pre_increment</a>&gt;, T_arg&gt; &gt; operator++ </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg&gt;&amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>a</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a99" doxytag="sigc::operator+="></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<a class="el" href="structsigc_1_1plus.html">plus</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; operator+= </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_arg1&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a98" doxytag="sigc::operator+="></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<a class="el" href="structsigc_1_1plus.html">plus</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; operator+= </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_arg2&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a97" doxytag="sigc::operator+="></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<a class="el" href="structsigc_1_1plus.html">plus</a>&gt;, T_arg1, T_arg2&gt; &gt; operator+= </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a129" doxytag="sigc::operator-"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator__unary.html">lambda_operator_unary</a>&lt;<a class="el" href="structsigc_1_1unary__arithmetic.html">unary_arithmetic</a>&lt;<a class="el" href="structsigc_1_1negate.html">negate</a>&gt;, T_arg&gt; &gt; operator- </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg&gt;&amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>a</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a48" doxytag="sigc::operator-"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<a class="el" href="structsigc_1_1minus.html">minus</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; operator- </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_arg1&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a47" doxytag="sigc::operator-"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<a class="el" href="structsigc_1_1minus.html">minus</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; operator- </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_arg2&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a46" doxytag="sigc::operator-"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<a class="el" href="structsigc_1_1minus.html">minus</a>&gt;, T_arg1, T_arg2&gt; &gt; operator- </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a128" doxytag="sigc::operator--"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator__unary.html">lambda_operator_unary</a>&lt;<a class="el" href="structsigc_1_1unary__arithmetic.html">unary_arithmetic</a>&lt;<a class="el" href="structsigc_1_1pre__decrement.html">pre_decrement</a>&gt;, T_arg&gt; &gt; operator-- </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg&gt;&amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>a</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a102" doxytag="sigc::operator-="></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<a class="el" href="structsigc_1_1minus.html">minus</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; operator-= </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_arg1&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a101" doxytag="sigc::operator-="></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<a class="el" href="structsigc_1_1minus.html">minus</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; operator-= </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_arg2&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a100" doxytag="sigc::operator-="></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<a class="el" href="structsigc_1_1minus.html">minus</a>&gt;, T_arg1, T_arg2&gt; &gt; operator-= </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a54" doxytag="sigc::operator/"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<a class="el" href="structsigc_1_1divides.html">divides</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; operator/ </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_arg1&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a53" doxytag="sigc::operator/"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<a class="el" href="structsigc_1_1divides.html">divides</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; operator/ </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_arg2&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a52" doxytag="sigc::operator/"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<a class="el" href="structsigc_1_1divides.html">divides</a>&gt;, T_arg1, T_arg2&gt; &gt; operator/ </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a108" doxytag="sigc::operator/="></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<a class="el" href="structsigc_1_1divides.html">divides</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; operator/= </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_arg1&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a107" doxytag="sigc::operator/="></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<a class="el" href="structsigc_1_1divides.html">divides</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; operator/= </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_arg2&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a106" doxytag="sigc::operator/="></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<a class="el" href="structsigc_1_1divides.html">divides</a>&gt;, T_arg1, T_arg2&gt; &gt; operator/= </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a81" doxytag="sigc::operator<"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<a class="el" href="structsigc_1_1less.html">less</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; operator&lt; </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_arg1&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a80" doxytag="sigc::operator<"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<a class="el" href="structsigc_1_1less.html">less</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; operator&lt; </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_arg2&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a79" doxytag="sigc::operator<"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<a class="el" href="structsigc_1_1less.html">less</a>&gt;, T_arg1, T_arg2&gt; &gt; operator&lt; </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a60" doxytag="sigc::operator<<"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<a class="el" href="structsigc_1_1leftshift.html">leftshift</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; operator&lt;&lt; </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_arg1&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a59" doxytag="sigc::operator<<"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<a class="el" href="structsigc_1_1leftshift.html">leftshift</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; operator&lt;&lt; </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_arg2&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a58" doxytag="sigc::operator<<"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<a class="el" href="structsigc_1_1leftshift.html">leftshift</a>&gt;, T_arg1, T_arg2&gt; &gt; operator&lt;&lt; </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a114" doxytag="sigc::operator<<="></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<a class="el" href="structsigc_1_1leftshift.html">leftshift</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; operator&lt;&lt;= </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_arg1&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a113" doxytag="sigc::operator<<="></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<a class="el" href="structsigc_1_1leftshift.html">leftshift</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; operator&lt;&lt;= </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_arg2&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a112" doxytag="sigc::operator<<="></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<a class="el" href="structsigc_1_1leftshift.html">leftshift</a>&gt;, T_arg1, T_arg2&gt; &gt; operator&lt;&lt;= </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a87" doxytag="sigc::operator<="></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<a class="el" href="structsigc_1_1less__equal.html">less_equal</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; operator&lt;= </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_arg1&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a86" doxytag="sigc::operator<="></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<a class="el" href="structsigc_1_1less__equal.html">less_equal</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; operator&lt;= </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_arg2&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a85" doxytag="sigc::operator<="></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<a class="el" href="structsigc_1_1less__equal.html">less_equal</a>&gt;, T_arg1, T_arg2&gt; &gt; operator&lt;= </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a93" doxytag="sigc::operator=="></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<a class="el" href="structsigc_1_1equal__to.html">equal_to</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; operator== </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_arg1&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a92" doxytag="sigc::operator=="></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<a class="el" href="structsigc_1_1equal__to.html">equal_to</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; operator== </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_arg2&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a91" doxytag="sigc::operator=="></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<a class="el" href="structsigc_1_1equal__to.html">equal_to</a>&gt;, T_arg1, T_arg2&gt; &gt; operator== </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a84" doxytag="sigc::operator>"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<a class="el" href="structsigc_1_1greater.html">greater</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; operator&gt; </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_arg1&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a83" doxytag="sigc::operator>"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<a class="el" href="structsigc_1_1greater.html">greater</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; operator&gt; </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_arg2&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a82" doxytag="sigc::operator>"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<a class="el" href="structsigc_1_1greater.html">greater</a>&gt;, T_arg1, T_arg2&gt; &gt; operator&gt; </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a90" doxytag="sigc::operator>="></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<a class="el" href="structsigc_1_1greater__equal.html">greater_equal</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; operator&gt;= </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_arg1&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a89" doxytag="sigc::operator>="></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<a class="el" href="structsigc_1_1greater__equal.html">greater_equal</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; operator&gt;= </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_arg2&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a88" doxytag="sigc::operator>="></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<a class="el" href="structsigc_1_1greater__equal.html">greater_equal</a>&gt;, T_arg1, T_arg2&gt; &gt; operator&gt;= </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a63" doxytag="sigc::operator>>"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<a class="el" href="structsigc_1_1rightshift.html">rightshift</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; operator&gt;&gt; </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_arg1&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a62" doxytag="sigc::operator>>"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<a class="el" href="structsigc_1_1rightshift.html">rightshift</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; operator&gt;&gt; </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_arg2&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a61" doxytag="sigc::operator>>"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<a class="el" href="structsigc_1_1rightshift.html">rightshift</a>&gt;, T_arg1, T_arg2&gt; &gt; operator&gt;&gt; </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a117" doxytag="sigc::operator>>="></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<a class="el" href="structsigc_1_1rightshift.html">rightshift</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; operator&gt;&gt;= </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_arg1&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a116" doxytag="sigc::operator>>="></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<a class="el" href="structsigc_1_1rightshift.html">rightshift</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; operator&gt;&gt;= </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_arg2&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a115" doxytag="sigc::operator>>="></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<a class="el" href="structsigc_1_1rightshift.html">rightshift</a>&gt;, T_arg1, T_arg2&gt; &gt; operator&gt;&gt;= </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a72" doxytag="sigc::operator^"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<a class="el" href="structsigc_1_1xor__.html">xor_</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; operator^ </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_arg1&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a71" doxytag="sigc::operator^"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<a class="el" href="structsigc_1_1xor__.html">xor_</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; operator^ </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_arg2&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a70" doxytag="sigc::operator^"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<a class="el" href="structsigc_1_1xor__.html">xor_</a>&gt;, T_arg1, T_arg2&gt; &gt; operator^ </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a126" doxytag="sigc::operator^="></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<a class="el" href="structsigc_1_1xor__.html">xor_</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; operator^= </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_arg1&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a125" doxytag="sigc::operator^="></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<a class="el" href="structsigc_1_1xor__.html">xor_</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; operator^= </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_arg2&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a124" doxytag="sigc::operator^="></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<a class="el" href="structsigc_1_1xor__.html">xor_</a>&gt;, T_arg1, T_arg2&gt; &gt; operator^= </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a69" doxytag="sigc::operator|"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<a class="el" href="structsigc_1_1or__.html">or_</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; operator| </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_arg1&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a68" doxytag="sigc::operator|"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<a class="el" href="structsigc_1_1or__.html">or_</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; operator| </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_arg2&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a67" doxytag="sigc::operator|"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<a class="el" href="structsigc_1_1or__.html">or_</a>&gt;, T_arg1, T_arg2&gt; &gt; operator| </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a123" doxytag="sigc::operator|="></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<a class="el" href="structsigc_1_1or__.html">or_</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; operator|= </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_arg1&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a122" doxytag="sigc::operator|="></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<a class="el" href="structsigc_1_1or__.html">or_</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; operator|= </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_arg2&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a121" doxytag="sigc::operator|="></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<a class="el" href="structsigc_1_1or__.html">or_</a>&gt;, T_arg1, T_arg2&gt; &gt; operator|= </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a78" doxytag="sigc::operator||"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1logical.html">logical</a>&lt;<a class="el" href="structsigc_1_1or__.html">or_</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; operator|| </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_arg1&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a77" doxytag="sigc::operator||"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1logical.html">logical</a>&lt;<a class="el" href="structsigc_1_1or__.html">or_</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; operator|| </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_arg2&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a76" doxytag="sigc::operator||"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1logical.html">logical</a>&lt;<a class="el" href="structsigc_1_1or__.html">or_</a>&gt;, T_arg1, T_arg2&gt; &gt; operator|| </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda&lt;T_arg2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>a2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a130" doxytag="sigc::operator~"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_arg&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator__unary.html">lambda_operator_unary</a>&lt;<a class="el" href="structsigc_1_1unary__bitwise.html">unary_bitwise</a>&lt;<a class="el" href="structsigc_1_1not__.html">not_</a>&gt;, T_arg&gt; &gt; operator~ </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg&gt;&amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>a</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a391" doxytag="sigc::ref"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_type&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structsigc_1_1const__reference__wrapper.html">const_reference_wrapper</a>&lt;T_type&gt; ref </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_type&amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>v</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a const reference wrapper. 
<p>
Passing an object throught <a class="el" href="namespacesigc.html#a390">sigc::ref()</a> makes libsigc++ adaptors like, e.g., <a class="el" href="group__bind.html#a8">sigc::bind</a> store references to the object instead of copies. If the object type inherits from <a class="el" href="structsigc_1_1trackable.html">sigc::trackable</a> this will ensure automatic invalidation of the adaptors when the object is deleted or overwritten.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>v</em>&nbsp;</td><td>Reference to store. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A reference wrapper. </dd></dl>
    </td>
  </tr>
</table>
<a name="a390" doxytag="sigc::ref"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_type&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structsigc_1_1reference__wrapper.html">reference_wrapper</a>&lt;T_type&gt; ref </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_type&amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>v</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a reference wrapper. 
<p>
Passing an object throught <a class="el" href="namespacesigc.html#a390">sigc::ref()</a> makes libsigc++ adaptors like, e.g., <a class="el" href="group__bind.html#a8">sigc::bind</a> store references to the object instead of copies. If the object type inherits from <a class="el" href="structsigc_1_1trackable.html">sigc::trackable</a> this will ensure automatic invalidation of the adaptors when the object is deleted or overwritten.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>v</em>&nbsp;</td><td>Reference to store. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A reference wrapper. </dd></dl>
    </td>
  </tr>
</table>
<a name="a134" doxytag="sigc::reinterpret_cast_"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_type, class T_arg&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator__convert.html">lambda_operator_convert</a>&lt;<a class="el" href="structsigc_1_1cast__.html">cast_</a>&lt;<a class="el" href="structsigc_1_1reinterpret__.html">reinterpret_</a>&gt;, T_type, T_arg&gt; &gt; reinterpret_cast_ </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg&gt;&amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>a</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a135" doxytag="sigc::static_cast_"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_type, class T_arg&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> lambda&lt;<a class="el" href="structsigc_1_1lambda__operator__convert.html">lambda_operator_convert</a>&lt;<a class="el" href="structsigc_1_1cast__.html">cast_</a>&lt;<a class="el" href="structsigc_1_1static__.html">static_</a>&gt;, T_type, T_arg&gt; &gt; static_cast_ </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const lambda&lt;T_arg&gt;&amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>a</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a395" doxytag="sigc::unwrap"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_type&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> const T_type&amp; unwrap </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const const_reference_wrapper&lt;T_type&gt;&amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>v</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a394" doxytag="sigc::unwrap"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_type&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> T_type&amp; unwrap </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const reference_wrapper&lt;T_type&gt;&amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>v</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a393" doxytag="sigc::unwrap"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_type&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> const T_type&amp; unwrap </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_type&amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>v</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a392" doxytag="sigc::unwrap"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_type&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> T_type&amp; unwrap </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_type&amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>v</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a42" doxytag="sigc::visit_each"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_action, class T_lambda_action, class T_type, class T_arg&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void visit_each </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_action&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda_operator_convert&lt;T_lambda_action, T_type, T_arg&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_target</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a41" doxytag="sigc::visit_each"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_action, class T_lambda_action, class T_arg&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void visit_each </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_action&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda_operator_unary&lt;T_lambda_action, T_arg&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_target</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a40" doxytag="sigc::visit_each"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_action, class T_lambda_action, class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void visit_each </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_action&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda_operator&lt;T_lambda_action, T_arg1, T_arg2 &gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_target</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a36" doxytag="sigc::visit_each"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_action, class T_functor, class T_type1, class T_type2, class T_type3&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void visit_each </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_action&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda_group3&lt;T_functor, T_type1, T_type2, T_type3&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_target</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a35" doxytag="sigc::visit_each"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_action, class T_functor, class T_type1, class T_type2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void visit_each </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_action&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda_group2&lt;T_functor, T_type1, T_type2&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_target</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a34" doxytag="sigc::visit_each"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_action, class T_functor, class T_type1&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void visit_each </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_action&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const lambda_group1&lt;T_functor, T_type1&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_target</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a30" doxytag="sigc::visit_each"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_action, class T_functor, class T_catcher, class T_return&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void visit_each </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_action&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const exception_catch_functor&lt;T_functor, T_catcher, T_return&gt;&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_target</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr><h2>Variable Documentation</h2>
<a name="a0" doxytag="sigc::_1"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const lambda&lt;<a class="el" href="structsigc_1_1internal_1_1lambda__select1.html">internal::lambda_select1</a>&gt; <a class="el" href="namespacesigc.html#a0">sigc::_1</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a1" doxytag="sigc::_2"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const lambda&lt;<a class="el" href="structsigc_1_1internal_1_1lambda__select2.html">internal::lambda_select2</a>&gt; <a class="el" href="namespacesigc.html#a1">sigc::_2</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a2" doxytag="sigc::_3"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const lambda&lt;<a class="el" href="structsigc_1_1internal_1_1lambda__select3.html">internal::lambda_select3</a>&gt; <a class="el" href="namespacesigc.html#a2">sigc::_3</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a3" doxytag="sigc::_4"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const lambda&lt;<a class="el" href="structsigc_1_1internal_1_1lambda__select4.html">internal::lambda_select4</a>&gt; <a class="el" href="namespacesigc.html#a3">sigc::_4</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a4" doxytag="sigc::_5"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const lambda&lt;<a class="el" href="structsigc_1_1internal_1_1lambda__select5.html">internal::lambda_select5</a>&gt; <a class="el" href="namespacesigc.html#a4">sigc::_5</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a5" doxytag="sigc::_6"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const lambda&lt;<a class="el" href="structsigc_1_1internal_1_1lambda__select6.html">internal::lambda_select6</a>&gt; <a class="el" href="namespacesigc.html#a5">sigc::_6</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a6" doxytag="sigc::_7"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const lambda&lt;<a class="el" href="structsigc_1_1internal_1_1lambda__select7.html">internal::lambda_select7</a>&gt; <a class="el" href="namespacesigc.html#a6">sigc::_7</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr><address><small>
Generated for libsigc++ 2.0 by <a href="http://www.doxygen.org/index.html">
Doxygen</a> 1.3.3 &copy;&nbsp;1997-2001</small></address>
</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Compatibility module</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head>
<body bgcolor="#ffffff">
<table border="0" width="100%">
<tr>
    <td width="10%" height="40"><img src="../../images/libsigc_logo.gif" alt="logo" border="0" width="100%" height="100%"/></td>
    <td width="90%" height="40"><img src="../../images/top.gif" alt="top" width="100%" height="40"/></td>
</tr>
</table>
<center>
  <a class="qindex" href="../../index.html">Main Page</a> &nbsp;
  <a class="qindex" href="modules.html">Groups</a> &nbsp;
  <a class="qindex" href="namespaces.html"> Namespaces</a> &nbsp;
</center>
<hr width="100%"/>

<!-- Generated by Doxygen 1.3.3 -->
<h1>Compatibility module</h1>This set of types and functions provides an API that is compatible to libsigc++-1.2.  
<a href="#_details">More...</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Compounds</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSigC_1_1Signal0.html">Signal0</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal declaration. </em> <a href="classSigC_1_1Signal0.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSigC_1_1Signal1.html">Signal1</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal declaration. </em> <a href="classSigC_1_1Signal1.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSigC_1_1Signal2.html">Signal2</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal declaration. </em> <a href="classSigC_1_1Signal2.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSigC_1_1Signal3.html">Signal3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal declaration. </em> <a href="classSigC_1_1Signal3.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSigC_1_1Signal4.html">Signal4</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal declaration. </em> <a href="classSigC_1_1Signal4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSigC_1_1Signal5.html">Signal5</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal declaration. </em> <a href="classSigC_1_1Signal5.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSigC_1_1Signal6.html">Signal6</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal declaration. </em> <a href="classSigC_1_1Signal6.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSigC_1_1Signal7.html">Signal7</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal declaration. </em> <a href="classSigC_1_1Signal7.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSigC_1_1Slot0.html">Slot0</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque. </em> <a href="classSigC_1_1Slot0.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSigC_1_1Slot1.html">Slot1</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque. </em> <a href="classSigC_1_1Slot1.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSigC_1_1Slot2.html">Slot2</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque. </em> <a href="classSigC_1_1Slot2.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSigC_1_1Slot3.html">Slot3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque. </em> <a href="classSigC_1_1Slot3.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSigC_1_1Slot4.html">Slot4</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque. </em> <a href="classSigC_1_1Slot4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSigC_1_1Slot5.html">Slot5</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque. </em> <a href="classSigC_1_1Slot5.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSigC_1_1Slot6.html">Slot6</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque. </em> <a href="classSigC_1_1Slot6.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classSigC_1_1Slot7.html">Slot7</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque. </em> <a href="classSigC_1_1Slot7.html#_details">More...</a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef ::<a class="el" href="structsigc_1_1connection.html">sigc::connection</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a0">SigC::Connection</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convinience class for safe disconnection. </em> <a href="#a0"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj&gt; Slot0&lt;T_return&gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a1">SigC::slot_class</a> (T_obj&amp; _A_obj, T_return(T_obj::* _A_func)())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot0.html">SigC::Slot0</a> that encapsulates a method and an object instance. </em> <a href="#a1"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_arg1, class T_obj&gt; Slot1&lt;T_return, T_arg1&gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a2">SigC::slot_class</a> (T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot1.html">SigC::Slot1</a> that encapsulates a method and an object instance. </em> <a href="#a2"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_arg1, class T_arg2, class T_obj&gt; Slot2&lt;T_return, T_arg1, T_arg2&gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a3">SigC::slot_class</a> (T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1, T_arg2))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot2.html">SigC::Slot2</a> that encapsulates a method and an object instance. </em> <a href="#a3"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_obj&gt; Slot3&lt; T_return, T_arg1, T_arg2,<br>
 T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a4">SigC::slot_class</a> (T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot3.html">SigC::Slot3</a> that encapsulates a method and an object instance. </em> <a href="#a4"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_obj&gt; Slot4&lt; T_return, T_arg1, T_arg2,<br>
 T_arg3, T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a5">SigC::slot_class</a> (T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot4.html">SigC::Slot4</a> that encapsulates a method and an object instance. </em> <a href="#a5"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_obj&gt; Slot5&lt; T_return, T_arg1, T_arg2,<br>
 T_arg3, T_arg4, T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a6">SigC::slot_class</a> (T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot5.html">SigC::Slot5</a> that encapsulates a method and an object instance. </em> <a href="#a6"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_obj&gt; Slot6&lt; T_return, T_arg1, T_arg2,<br>
 T_arg3, T_arg4, T_arg5, T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a7">SigC::slot_class</a> (T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot6.html">SigC::Slot6</a> that encapsulates a method and an object instance. </em> <a href="#a7"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_obj&gt; Slot7&lt; T_return, T_arg1, T_arg2,<br>
 T_arg3, T_arg4, T_arg5, T_arg6,<br>
 T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a8">SigC::slot_class</a> (T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot7.html">SigC::Slot7</a> that encapsulates a method and an object instance. </em> <a href="#a8"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj&gt; Slot0&lt;T_return&gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a9">SigC::slot_class</a> (const T_obj&amp; _A_obj, T_return(T_obj::* _A_func)() const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot0.html">SigC::Slot0</a> that encapsulates a const method and an object instance. </em> <a href="#a9"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_arg1, class T_obj&gt; Slot1&lt;T_return, T_arg1&gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a10">SigC::slot_class</a> (const T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot1.html">SigC::Slot1</a> that encapsulates a const method and an object instance. </em> <a href="#a10"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_arg1, class T_arg2, class T_obj&gt; Slot2&lt;T_return, T_arg1, T_arg2&gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a11">SigC::slot_class</a> (const T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1, T_arg2) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot2.html">SigC::Slot2</a> that encapsulates a const method and an object instance. </em> <a href="#a11"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_obj&gt; Slot3&lt; T_return, T_arg1, T_arg2,<br>
 T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a12">SigC::slot_class</a> (const T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot3.html">SigC::Slot3</a> that encapsulates a const method and an object instance. </em> <a href="#a12"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_obj&gt; Slot4&lt; T_return, T_arg1, T_arg2,<br>
 T_arg3, T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a13">SigC::slot_class</a> (const T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot4.html">SigC::Slot4</a> that encapsulates a const method and an object instance. </em> <a href="#a13"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_obj&gt; Slot5&lt; T_return, T_arg1, T_arg2,<br>
 T_arg3, T_arg4, T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a14">SigC::slot_class</a> (const T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot5.html">SigC::Slot5</a> that encapsulates a const method and an object instance. </em> <a href="#a14"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_obj&gt; Slot6&lt; T_return, T_arg1, T_arg2,<br>
 T_arg3, T_arg4, T_arg5, T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a15">SigC::slot_class</a> (const T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot6.html">SigC::Slot6</a> that encapsulates a const method and an object instance. </em> <a href="#a15"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_obj&gt; Slot7&lt; T_return, T_arg1, T_arg2,<br>
 T_arg3, T_arg4, T_arg5, T_arg6,<br>
 T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a16">SigC::slot_class</a> (const T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot7.html">SigC::Slot7</a> that encapsulates a const method and an object instance. </em> <a href="#a16"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj&gt; Slot0&lt;T_return&gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a17">SigC::slot_class</a> (T_obj&amp; _A_obj, T_return(T_obj::* _A_func)() volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot0.html">SigC::Slot0</a> that encapsulates a volatile method and an object instance. </em> <a href="#a17"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_arg1, class T_obj&gt; Slot1&lt;T_return, T_arg1&gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a18">SigC::slot_class</a> (T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot1.html">SigC::Slot1</a> that encapsulates a volatile method and an object instance. </em> <a href="#a18"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_arg1, class T_arg2, class T_obj&gt; Slot2&lt;T_return, T_arg1, T_arg2&gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a19">SigC::slot_class</a> (T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1, T_arg2) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot2.html">SigC::Slot2</a> that encapsulates a volatile method and an object instance. </em> <a href="#a19"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_obj&gt; Slot3&lt; T_return, T_arg1, T_arg2,<br>
 T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a20">SigC::slot_class</a> (T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot3.html">SigC::Slot3</a> that encapsulates a volatile method and an object instance. </em> <a href="#a20"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_obj&gt; Slot4&lt; T_return, T_arg1, T_arg2,<br>
 T_arg3, T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a21">SigC::slot_class</a> (T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot4.html">SigC::Slot4</a> that encapsulates a volatile method and an object instance. </em> <a href="#a21"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_obj&gt; Slot5&lt; T_return, T_arg1, T_arg2,<br>
 T_arg3, T_arg4, T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a22">SigC::slot_class</a> (T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot5.html">SigC::Slot5</a> that encapsulates a volatile method and an object instance. </em> <a href="#a22"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_obj&gt; Slot6&lt; T_return, T_arg1, T_arg2,<br>
 T_arg3, T_arg4, T_arg5, T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a23">SigC::slot_class</a> (T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot6.html">SigC::Slot6</a> that encapsulates a volatile method and an object instance. </em> <a href="#a23"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_obj&gt; Slot7&lt; T_return, T_arg1, T_arg2,<br>
 T_arg3, T_arg4, T_arg5, T_arg6,<br>
 T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a24">SigC::slot_class</a> (T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot7.html">SigC::Slot7</a> that encapsulates a volatile method and an object instance. </em> <a href="#a24"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj&gt; Slot0&lt;T_return&gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a25">SigC::slot_class</a> (const T_obj&amp; _A_obj, T_return(T_obj::* _A_func)() const volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot0.html">SigC::Slot0</a> that encapsulates a const volatile method and an object instance. </em> <a href="#a25"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_arg1, class T_obj&gt; Slot1&lt;T_return, T_arg1&gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a26">SigC::slot_class</a> (const T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1) const volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot1.html">SigC::Slot1</a> that encapsulates a const volatile method and an object instance. </em> <a href="#a26"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_arg1, class T_arg2, class T_obj&gt; Slot2&lt;T_return, T_arg1, T_arg2&gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a27">SigC::slot_class</a> (const T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1, T_arg2) const volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot2.html">SigC::Slot2</a> that encapsulates a const volatile method and an object instance. </em> <a href="#a27"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_obj&gt; Slot3&lt; T_return, T_arg1, T_arg2,<br>
 T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a28">SigC::slot_class</a> (const T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3) const volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot3.html">SigC::Slot3</a> that encapsulates a const volatile method and an object instance. </em> <a href="#a28"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_obj&gt; Slot4&lt; T_return, T_arg1, T_arg2,<br>
 T_arg3, T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a29">SigC::slot_class</a> (const T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot4.html">SigC::Slot4</a> that encapsulates a const volatile method and an object instance. </em> <a href="#a29"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_obj&gt; Slot5&lt; T_return, T_arg1, T_arg2,<br>
 T_arg3, T_arg4, T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a30">SigC::slot_class</a> (const T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot5.html">SigC::Slot5</a> that encapsulates a const volatile method and an object instance. </em> <a href="#a30"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_obj&gt; Slot6&lt; T_return, T_arg1, T_arg2,<br>
 T_arg3, T_arg4, T_arg5, T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a31">SigC::slot_class</a> (const T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot6.html">SigC::Slot6</a> that encapsulates a const volatile method and an object instance. </em> <a href="#a31"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_obj&gt; Slot7&lt; T_return, T_arg1, T_arg2,<br>
 T_arg3, T_arg4, T_arg5, T_arg6,<br>
 T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a32">SigC::slot_class</a> (const T_obj&amp; _A_obj, T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot7.html">SigC::Slot7</a> that encapsulates a const volatile method and an object instance. </em> <a href="#a32"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj&gt; Slot1&lt;T_return, T_obj&amp;&gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a33">SigC::slot</a> (T_return(T_obj::* _A_func)())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type Sigc::Slot1 that wraps a method. </em> <a href="#a33"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_obj&gt; Slot2&lt; T_return, T_obj &amp;,<br>
 T_arg1 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a34">SigC::slot</a> (T_return(T_obj::* _A_func)(T_arg1))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type Sigc::Slot2 that wraps a method. </em> <a href="#a34"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_obj&gt; Slot3&lt; T_return, T_obj &amp;,<br>
 T_arg1, T_arg2 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a35">SigC::slot</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type Sigc::Slot3 that wraps a method. </em> <a href="#a35"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_obj&gt; Slot4&lt; T_return, T_obj &amp;,<br>
 T_arg1, T_arg2, T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a36">SigC::slot</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type Sigc::Slot4 that wraps a method. </em> <a href="#a36"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_obj&gt; Slot5&lt; T_return, T_obj &amp;,<br>
 T_arg1, T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a37">SigC::slot</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type Sigc::Slot5 that wraps a method. </em> <a href="#a37"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_obj&gt; Slot6&lt; T_return, T_obj &amp;,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a38">SigC::slot</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type Sigc::Slot6 that wraps a method. </em> <a href="#a38"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_obj&gt; Slot7&lt; T_return, T_obj &amp;,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5, T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a39">SigC::slot</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type Sigc::Slot7 that wraps a method. </em> <a href="#a39"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj&gt; Slot1&lt;T_return, T_obj&amp;&gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a40">SigC::slot</a> (T_return(T_obj::* _A_func)() const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type Sigc::Slot1 that wraps a const method. </em> <a href="#a40"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_obj&gt; Slot2&lt; T_return, T_obj &amp;,<br>
 T_arg1 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a41">SigC::slot</a> (T_return(T_obj::* _A_func)(T_arg1) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type Sigc::Slot2 that wraps a const method. </em> <a href="#a41"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_obj&gt; Slot3&lt; T_return, T_obj &amp;,<br>
 T_arg1, T_arg2 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a42">SigC::slot</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type Sigc::Slot3 that wraps a const method. </em> <a href="#a42"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_obj&gt; Slot4&lt; T_return, T_obj &amp;,<br>
 T_arg1, T_arg2, T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a43">SigC::slot</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type Sigc::Slot4 that wraps a const method. </em> <a href="#a43"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_obj&gt; Slot5&lt; T_return, T_obj &amp;,<br>
 T_arg1, T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a44">SigC::slot</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type Sigc::Slot5 that wraps a const method. </em> <a href="#a44"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_obj&gt; Slot6&lt; T_return, T_obj &amp;,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a45">SigC::slot</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type Sigc::Slot6 that wraps a const method. </em> <a href="#a45"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_obj&gt; Slot7&lt; T_return, T_obj &amp;,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5, T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a46">SigC::slot</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type Sigc::Slot7 that wraps a const method. </em> <a href="#a46"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj&gt; Slot1&lt;T_return, T_obj&amp;&gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a47">SigC::slot</a> (T_return(T_obj::* _A_func)() volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type Sigc::Slot1 that wraps a const volatile method. </em> <a href="#a47"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_obj&gt; Slot2&lt; T_return, T_obj &amp;,<br>
 T_arg1 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a48">SigC::slot</a> (T_return(T_obj::* _A_func)(T_arg1) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type Sigc::Slot2 that wraps a const volatile method. </em> <a href="#a48"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_obj&gt; Slot3&lt; T_return, T_obj &amp;,<br>
 T_arg1, T_arg2 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a49">SigC::slot</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type Sigc::Slot3 that wraps a const volatile method. </em> <a href="#a49"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_obj&gt; Slot4&lt; T_return, T_obj &amp;,<br>
 T_arg1, T_arg2, T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a50">SigC::slot</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type Sigc::Slot4 that wraps a const volatile method. </em> <a href="#a50"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_obj&gt; Slot5&lt; T_return, T_obj &amp;,<br>
 T_arg1, T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a51">SigC::slot</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type Sigc::Slot5 that wraps a const volatile method. </em> <a href="#a51"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_obj&gt; Slot6&lt; T_return, T_obj &amp;,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a52">SigC::slot</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type Sigc::Slot6 that wraps a const volatile method. </em> <a href="#a52"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_obj&gt; Slot7&lt; T_return, T_obj &amp;,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5, T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a53">SigC::slot</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type Sigc::Slot7 that wraps a const volatile method. </em> <a href="#a53"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj1, class T_obj2&gt; Slot0&lt;T_return&gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a54">SigC::slot</a> (T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot0.html">SigC::Slot0</a> that encapsulates a method and an object instance. </em> <a href="#a54"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_arg1, class T_obj1, class T_obj2&gt; Slot1&lt;T_return, T_arg1&gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a55">SigC::slot</a> (T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot1.html">SigC::Slot1</a> that encapsulates a method and an object instance. </em> <a href="#a55"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_arg1, class T_arg2, class T_obj1, class T_obj2&gt; Slot2&lt;T_return, T_arg1, T_arg2&gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a56">SigC::slot</a> (T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot2.html">SigC::Slot2</a> that encapsulates a method and an object instance. </em> <a href="#a56"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_obj1, class T_obj2&gt; Slot3&lt; T_return, T_arg1, T_arg2,<br>
 T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a57">SigC::slot</a> (T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot3.html">SigC::Slot3</a> that encapsulates a method and an object instance. </em> <a href="#a57"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_obj1, class T_obj2&gt; Slot4&lt; T_return, T_arg1, T_arg2,<br>
 T_arg3, T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a58">SigC::slot</a> (T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot4.html">SigC::Slot4</a> that encapsulates a method and an object instance. </em> <a href="#a58"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_obj1, class T_obj2&gt; Slot5&lt; T_return, T_arg1, T_arg2,<br>
 T_arg3, T_arg4, T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a59">SigC::slot</a> (T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot5.html">SigC::Slot5</a> that encapsulates a method and an object instance. </em> <a href="#a59"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_obj1, class T_obj2&gt; Slot6&lt; T_return, T_arg1, T_arg2,<br>
 T_arg3, T_arg4, T_arg5, T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a60">SigC::slot</a> (T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot6.html">SigC::Slot6</a> that encapsulates a method and an object instance. </em> <a href="#a60"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_obj1, class T_obj2&gt; Slot7&lt; T_return, T_arg1, T_arg2,<br>
 T_arg3, T_arg4, T_arg5, T_arg6,<br>
 T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a61">SigC::slot</a> (T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot7.html">SigC::Slot7</a> that encapsulates a method and an object instance. </em> <a href="#a61"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj1, class T_obj2&gt; Slot0&lt;T_return&gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a62">SigC::slot</a> (const T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)() const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot0.html">SigC::Slot0</a> that encapsulates a const method and an object instance. </em> <a href="#a62"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_arg1, class T_obj1, class T_obj2&gt; Slot1&lt;T_return, T_arg1&gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a63">SigC::slot</a> (const T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot1.html">SigC::Slot1</a> that encapsulates a const method and an object instance. </em> <a href="#a63"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_arg1, class T_arg2, class T_obj1, class T_obj2&gt; Slot2&lt;T_return, T_arg1, T_arg2&gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a64">SigC::slot</a> (const T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot2.html">SigC::Slot2</a> that encapsulates a const method and an object instance. </em> <a href="#a64"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_obj1, class T_obj2&gt; Slot3&lt; T_return, T_arg1, T_arg2,<br>
 T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a65">SigC::slot</a> (const T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot3.html">SigC::Slot3</a> that encapsulates a const method and an object instance. </em> <a href="#a65"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_obj1, class T_obj2&gt; Slot4&lt; T_return, T_arg1, T_arg2,<br>
 T_arg3, T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a66">SigC::slot</a> (const T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot4.html">SigC::Slot4</a> that encapsulates a const method and an object instance. </em> <a href="#a66"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_obj1, class T_obj2&gt; Slot5&lt; T_return, T_arg1, T_arg2,<br>
 T_arg3, T_arg4, T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a67">SigC::slot</a> (const T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot5.html">SigC::Slot5</a> that encapsulates a const method and an object instance. </em> <a href="#a67"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_obj1, class T_obj2&gt; Slot6&lt; T_return, T_arg1, T_arg2,<br>
 T_arg3, T_arg4, T_arg5, T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a68">SigC::slot</a> (const T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot6.html">SigC::Slot6</a> that encapsulates a const method and an object instance. </em> <a href="#a68"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_obj1, class T_obj2&gt; Slot7&lt; T_return, T_arg1, T_arg2,<br>
 T_arg3, T_arg4, T_arg5, T_arg6,<br>
 T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a69">SigC::slot</a> (const T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot7.html">SigC::Slot7</a> that encapsulates a const method and an object instance. </em> <a href="#a69"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj1, class T_obj2&gt; Slot0&lt;T_return&gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a70">SigC::slot</a> (T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)() volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot0.html">SigC::Slot0</a> that encapsulates a volatile method and an object instance. </em> <a href="#a70"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_arg1, class T_obj1, class T_obj2&gt; Slot1&lt;T_return, T_arg1&gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a71">SigC::slot</a> (T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot1.html">SigC::Slot1</a> that encapsulates a volatile method and an object instance. </em> <a href="#a71"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_arg1, class T_arg2, class T_obj1, class T_obj2&gt; Slot2&lt;T_return, T_arg1, T_arg2&gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a72">SigC::slot</a> (T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot2.html">SigC::Slot2</a> that encapsulates a volatile method and an object instance. </em> <a href="#a72"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_obj1, class T_obj2&gt; Slot3&lt; T_return, T_arg1, T_arg2,<br>
 T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a73">SigC::slot</a> (T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot3.html">SigC::Slot3</a> that encapsulates a volatile method and an object instance. </em> <a href="#a73"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_obj1, class T_obj2&gt; Slot4&lt; T_return, T_arg1, T_arg2,<br>
 T_arg3, T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a74">SigC::slot</a> (T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot4.html">SigC::Slot4</a> that encapsulates a volatile method and an object instance. </em> <a href="#a74"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_obj1, class T_obj2&gt; Slot5&lt; T_return, T_arg1, T_arg2,<br>
 T_arg3, T_arg4, T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a75">SigC::slot</a> (T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot5.html">SigC::Slot5</a> that encapsulates a volatile method and an object instance. </em> <a href="#a75"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_obj1, class T_obj2&gt; Slot6&lt; T_return, T_arg1, T_arg2,<br>
 T_arg3, T_arg4, T_arg5, T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a76">SigC::slot</a> (T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot6.html">SigC::Slot6</a> that encapsulates a volatile method and an object instance. </em> <a href="#a76"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_obj1, class T_obj2&gt; Slot7&lt; T_return, T_arg1, T_arg2,<br>
 T_arg3, T_arg4, T_arg5, T_arg6,<br>
 T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a77">SigC::slot</a> (T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot7.html">SigC::Slot7</a> that encapsulates a volatile method and an object instance. </em> <a href="#a77"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_obj1, class T_obj2&gt; Slot0&lt;T_return&gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a78">SigC::slot</a> (const T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)() const volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot0.html">SigC::Slot0</a> that encapsulates a const volatile method and an object instance. </em> <a href="#a78"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_arg1, class T_obj1, class T_obj2&gt; Slot1&lt;T_return, T_arg1&gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a79">SigC::slot</a> (const T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1) const volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot1.html">SigC::Slot1</a> that encapsulates a const volatile method and an object instance. </em> <a href="#a79"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_arg1, class T_arg2, class T_obj1, class T_obj2&gt; Slot2&lt;T_return, T_arg1, T_arg2&gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a80">SigC::slot</a> (const T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2) const volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot2.html">SigC::Slot2</a> that encapsulates a const volatile method and an object instance. </em> <a href="#a80"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_obj1, class T_obj2&gt; Slot3&lt; T_return, T_arg1, T_arg2,<br>
 T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a81">SigC::slot</a> (const T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3) const volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot3.html">SigC::Slot3</a> that encapsulates a const volatile method and an object instance. </em> <a href="#a81"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_obj1, class T_obj2&gt; Slot4&lt; T_return, T_arg1, T_arg2,<br>
 T_arg3, T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a82">SigC::slot</a> (const T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot4.html">SigC::Slot4</a> that encapsulates a const volatile method and an object instance. </em> <a href="#a82"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_obj1, class T_obj2&gt; Slot5&lt; T_return, T_arg1, T_arg2,<br>
 T_arg3, T_arg4, T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a83">SigC::slot</a> (const T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot5.html">SigC::Slot5</a> that encapsulates a const volatile method and an object instance. </em> <a href="#a83"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_obj1, class T_obj2&gt; Slot6&lt; T_return, T_arg1, T_arg2,<br>
 T_arg3, T_arg4, T_arg5, T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a84">SigC::slot</a> (const T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot6.html">SigC::Slot6</a> that encapsulates a const volatile method and an object instance. </em> <a href="#a84"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_obj1, class T_obj2&gt; Slot7&lt; T_return, T_arg1, T_arg2,<br>
 T_arg3, T_arg4, T_arg5, T_arg6,<br>
 T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a85">SigC::slot</a> (const T_obj1&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const volatile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot7.html">SigC::Slot7</a> that encapsulates a const volatile method and an object instance. </em> <a href="#a85"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return&gt; Slot0&lt;T_return&gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a86">SigC::slot</a> (T_return(* _A_func)())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot0.html">SigC::Slot0</a> that wraps an existing non-member function. </em> <a href="#a86"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_arg1&gt; Slot1&lt;T_return, T_arg1&gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a87">SigC::slot</a> (T_return(* _A_func)(T_arg1))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot1.html">SigC::Slot1</a> that wraps an existing non-member function. </em> <a href="#a87"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template &lt;class T_return, class T_arg1, class T_arg2&gt; Slot2&lt;T_return, T_arg1, T_arg2&gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a88">SigC::slot</a> (T_return(* _A_func)(T_arg1, T_arg2))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot2.html">SigC::Slot2</a> that wraps an existing non-member function. </em> <a href="#a88"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3&gt; Slot3&lt; T_return, T_arg1, T_arg2,<br>
 T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a89">SigC::slot</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot3.html">SigC::Slot3</a> that wraps an existing non-member function. </em> <a href="#a89"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; Slot4&lt; T_return, T_arg1, T_arg2,<br>
 T_arg3, T_arg4 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a90">SigC::slot</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot4.html">SigC::Slot4</a> that wraps an existing non-member function. </em> <a href="#a90"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; Slot5&lt; T_return, T_arg1, T_arg2,<br>
 T_arg3, T_arg4, T_arg5 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a91">SigC::slot</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot5.html">SigC::Slot5</a> that wraps an existing non-member function. </em> <a href="#a91"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; Slot6&lt; T_return, T_arg1, T_arg2,<br>
 T_arg3, T_arg4, T_arg5, T_arg6 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a92">SigC::slot</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot6.html">SigC::Slot6</a> that wraps an existing non-member function. </em> <a href="#a92"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; Slot7&lt; T_return, T_arg1, T_arg2,<br>
 T_arg3, T_arg4, T_arg5, T_arg6,<br>
 T_arg7 &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__compat.html#a93">SigC::slot</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classSigC_1_1Slot7.html">SigC::Slot7</a> that wraps an existing non-member function. </em> <a href="#a93"></a><em><br><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This set of types and functions provides an API that is compatible to libsigc++-1.2. 
<p>
Some internal structures of libsigc++-1.2 are not available.<p>
All types and functions that are defined in namespace <a class="el" href="namespaceSigC.html">SigC</a> are deprecated. Use the new libsigc++2 API that is defined in namespace sigc. <hr><h2>Typedef Documentation</h2>
<a name="a0" doxytag="SigC::Connection"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef ::<a class="el" href="structsigc_1_1connection.html">sigc::connection</a> <a class="el" href="group__compat.html#a0">SigC::Connection</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convinience class for safe disconnection. 
<p>
Iterators must not be used beyond the lifetime of the list they work on. A connection object can be created from a slot list iterator and may safely be used to disconnect the referred slot at any time (disconnect()). If the slot has already been destroyed, disconnect() does nothing. empty() or operator bool() can be used to test whether the connection is still active. The connection can be blocked (block(), unblock()).<p>
This is possible because the connection object gets notified when the referred slot dies (notify()).<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000033">Deprecated:</a></b></dt><dd>Use <a class="el" href="structsigc_1_1connection.html">sigc::connection</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a name="a93" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot7&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7)          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot7.html">SigC::Slot7</a> that wraps an existing non-member function. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to function that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000117">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__ptr__fun.html#a8">sigc::ptr_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a92" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot6&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6)          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot6.html">SigC::Slot6</a> that wraps an existing non-member function. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to function that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000116">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__ptr__fun.html#a8">sigc::ptr_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a91" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot5&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5)          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot5.html">SigC::Slot5</a> that wraps an existing non-member function. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to function that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000115">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__ptr__fun.html#a8">sigc::ptr_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a90" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot4&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4)          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot4.html">SigC::Slot4</a> that wraps an existing non-member function. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to function that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000114">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__ptr__fun.html#a8">sigc::ptr_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a89" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot3&lt;T_return, T_arg1,T_arg2,T_arg3&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3)          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot3.html">SigC::Slot3</a> that wraps an existing non-member function. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to function that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000113">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__ptr__fun.html#a8">sigc::ptr_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a88" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot2&lt;T_return, T_arg1,T_arg2&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2)          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot2.html">SigC::Slot2</a> that wraps an existing non-member function. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to function that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000112">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__ptr__fun.html#a8">sigc::ptr_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a87" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot1&lt;T_return, T_arg1&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1)          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot1.html">SigC::Slot1</a> that wraps an existing non-member function. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to function that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000111">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__ptr__fun.html#a8">sigc::ptr_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a86" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot0&lt;T_return&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)()          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot0.html">SigC::Slot0</a> that wraps an existing non-member function. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to function that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000110">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__ptr__fun.html#a8">sigc::ptr_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a85" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_obj1, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot7&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_obj1&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot7.html">SigC::Slot7</a> that encapsulates a const volatile method and an object instance. 
<p>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#a1">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000093">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a84" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_obj1, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot6&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_obj1&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot6.html">SigC::Slot6</a> that encapsulates a const volatile method and an object instance. 
<p>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#a1">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000092">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a83" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_obj1, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot5&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_obj1&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot5.html">SigC::Slot5</a> that encapsulates a const volatile method and an object instance. 
<p>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#a1">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000091">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a82" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_obj1, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot4&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_obj1&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4) const volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot4.html">SigC::Slot4</a> that encapsulates a const volatile method and an object instance. 
<p>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#a1">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000090">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a81" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_obj1, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot3&lt;T_return, T_arg1,T_arg2,T_arg3&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_obj1&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3) const volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot3.html">SigC::Slot3</a> that encapsulates a const volatile method and an object instance. 
<p>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#a1">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000089">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a80" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_obj1, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot2&lt;T_return, T_arg1,T_arg2&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_obj1&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2) const volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot2.html">SigC::Slot2</a> that encapsulates a const volatile method and an object instance. 
<p>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#a1">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000088">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a79" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_obj1, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot1&lt;T_return, T_arg1&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_obj1&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1) const volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot1.html">SigC::Slot1</a> that encapsulates a const volatile method and an object instance. 
<p>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#a1">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000087">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a78" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_obj1, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot0&lt;T_return&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_obj1&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)() const volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot0.html">SigC::Slot0</a> that encapsulates a const volatile method and an object instance. 
<p>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#a1">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000086">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a77" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_obj1, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot7&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj1&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot7.html">SigC::Slot7</a> that encapsulates a volatile method and an object instance. 
<p>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#a1">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000085">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a76" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_obj1, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot6&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj1&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot6.html">SigC::Slot6</a> that encapsulates a volatile method and an object instance. 
<p>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#a1">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000084">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a75" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_obj1, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot5&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj1&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot5.html">SigC::Slot5</a> that encapsulates a volatile method and an object instance. 
<p>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#a1">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000083">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a74" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_obj1, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot4&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj1&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4) volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot4.html">SigC::Slot4</a> that encapsulates a volatile method and an object instance. 
<p>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#a1">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000082">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a73" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_obj1, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot3&lt;T_return, T_arg1,T_arg2,T_arg3&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj1&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3) volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot3.html">SigC::Slot3</a> that encapsulates a volatile method and an object instance. 
<p>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#a1">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000081">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a72" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_obj1, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot2&lt;T_return, T_arg1,T_arg2&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj1&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2) volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot2.html">SigC::Slot2</a> that encapsulates a volatile method and an object instance. 
<p>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#a1">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000080">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a71" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_obj1, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot1&lt;T_return, T_arg1&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj1&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1) volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot1.html">SigC::Slot1</a> that encapsulates a volatile method and an object instance. 
<p>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#a1">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000079">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a70" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_obj1, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot0&lt;T_return&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj1&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)() volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot0.html">SigC::Slot0</a> that encapsulates a volatile method and an object instance. 
<p>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#a1">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000078">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a69" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_obj1, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot7&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_obj1&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot7.html">SigC::Slot7</a> that encapsulates a const method and an object instance. 
<p>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#a1">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000077">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a68" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_obj1, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot6&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_obj1&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot6.html">SigC::Slot6</a> that encapsulates a const method and an object instance. 
<p>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#a1">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000076">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a67" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_obj1, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot5&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_obj1&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot5.html">SigC::Slot5</a> that encapsulates a const method and an object instance. 
<p>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#a1">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000075">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a66" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_obj1, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot4&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_obj1&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4) const</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot4.html">SigC::Slot4</a> that encapsulates a const method and an object instance. 
<p>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#a1">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000074">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a65" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_obj1, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot3&lt;T_return, T_arg1,T_arg2,T_arg3&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_obj1&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3) const</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot3.html">SigC::Slot3</a> that encapsulates a const method and an object instance. 
<p>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#a1">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000073">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a64" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_obj1, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot2&lt;T_return, T_arg1,T_arg2&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_obj1&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2) const</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot2.html">SigC::Slot2</a> that encapsulates a const method and an object instance. 
<p>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#a1">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000072">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a63" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_obj1, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot1&lt;T_return, T_arg1&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_obj1&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1) const</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot1.html">SigC::Slot1</a> that encapsulates a const method and an object instance. 
<p>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#a1">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000071">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a62" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_obj1, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot0&lt;T_return&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_obj1&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)() const</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot0.html">SigC::Slot0</a> that encapsulates a const method and an object instance. 
<p>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#a1">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000070">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a61" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_obj1, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot7&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj1&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7)</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot7.html">SigC::Slot7</a> that encapsulates a method and an object instance. 
<p>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#a1">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000069">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a60" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_obj1, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot6&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj1&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6)</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot6.html">SigC::Slot6</a> that encapsulates a method and an object instance. 
<p>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#a1">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000068">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a59" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_obj1, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot5&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj1&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5)</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot5.html">SigC::Slot5</a> that encapsulates a method and an object instance. 
<p>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#a1">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000067">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a58" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_obj1, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot4&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj1&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4)</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot4.html">SigC::Slot4</a> that encapsulates a method and an object instance. 
<p>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#a1">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000066">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a57" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_obj1, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot3&lt;T_return, T_arg1,T_arg2,T_arg3&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj1&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3)</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot3.html">SigC::Slot3</a> that encapsulates a method and an object instance. 
<p>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#a1">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000065">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a56" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_obj1, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot2&lt;T_return, T_arg1,T_arg2&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj1&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2)</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot2.html">SigC::Slot2</a> that encapsulates a method and an object instance. 
<p>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#a1">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000064">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a55" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_obj1, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot1&lt;T_return, T_arg1&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj1&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1)</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot1.html">SigC::Slot1</a> that encapsulates a method and an object instance. 
<p>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#a1">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000063">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a54" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_obj1, class T_obj2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot0&lt;T_return&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj1&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj2::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)()</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot0.html">SigC::Slot0</a> that encapsulates a method and an object instance. 
<p>
<em>_A_obj</em> must be of a type that inherits from <a class="el" href="namespaceSigC.html#a1">SigC::Object</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000062">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a53" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot7&lt;T_return, T_obj &amp;, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt; SigC::slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) volatile          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type Sigc::Slot7 that wraps a const volatile method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000054">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a52" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot6&lt;T_return, T_obj &amp;, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt; SigC::slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) volatile          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type Sigc::Slot6 that wraps a const volatile method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000053">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a51" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot5&lt;T_return, T_obj &amp;, T_arg1, T_arg2, T_arg3, T_arg4&gt; SigC::slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4) volatile          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type Sigc::Slot5 that wraps a const volatile method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000052">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a50" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot4&lt;T_return, T_obj &amp;, T_arg1, T_arg2, T_arg3&gt; SigC::slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3) volatile          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type Sigc::Slot4 that wraps a const volatile method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000051">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a49" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot3&lt;T_return, T_obj &amp;, T_arg1, T_arg2&gt; SigC::slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2) volatile          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type Sigc::Slot3 that wraps a const volatile method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000050">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a48" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot2&lt;T_return, T_obj &amp;, T_arg1&gt; SigC::slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1) volatile          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type Sigc::Slot2 that wraps a const volatile method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000049">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a47" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot1&lt;T_return, T_obj&amp;&gt; SigC::slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)() volatile          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type Sigc::Slot1 that wraps a const volatile method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000048">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a46" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot7&lt;T_return, T_obj&amp;, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type Sigc::Slot7 that wraps a const method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000047">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a45" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot6&lt;T_return, T_obj&amp;, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type Sigc::Slot6 that wraps a const method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000046">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a44" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot5&lt;T_return, T_obj&amp;, T_arg1,T_arg2,T_arg3,T_arg4&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4) const          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type Sigc::Slot5 that wraps a const method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000045">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a43" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot4&lt;T_return, T_obj&amp;, T_arg1,T_arg2,T_arg3&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3) const          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type Sigc::Slot4 that wraps a const method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000044">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a42" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot3&lt;T_return, T_obj&amp;, T_arg1,T_arg2&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2) const          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type Sigc::Slot3 that wraps a const method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000043">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a41" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot2&lt;T_return, T_obj&amp;, T_arg1&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1) const          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type Sigc::Slot2 that wraps a const method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000042">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a40" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot1&lt;T_return, T_obj&amp;&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)() const          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type Sigc::Slot1 that wraps a const method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000041">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a39" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot7&lt;T_return, T_obj&amp;, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6)          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type Sigc::Slot7 that wraps a method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000040">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a38" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot6&lt;T_return, T_obj&amp;, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5)          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type Sigc::Slot6 that wraps a method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000039">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a37" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot5&lt;T_return, T_obj&amp;, T_arg1,T_arg2,T_arg3,T_arg4&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4)          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type Sigc::Slot5 that wraps a method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000038">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a36" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot4&lt;T_return, T_obj&amp;, T_arg1,T_arg2,T_arg3&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3)          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type Sigc::Slot4 that wraps a method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000037">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a35" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot3&lt;T_return, T_obj&amp;, T_arg1,T_arg2&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1, T_arg2)          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type Sigc::Slot3 that wraps a method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000036">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a34" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot2&lt;T_return, T_obj&amp;, T_arg1&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)(T_arg1)          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type Sigc::Slot2 that wraps a method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000035">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a33" doxytag="SigC::slot"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot1&lt;T_return, T_obj&amp;&gt; slot </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_return(T_obj::*&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>_A_func</em>)()          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type Sigc::Slot1 that wraps a method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000034">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a32" doxytag="SigC::slot_class"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot7&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7&gt; slot_class </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot7.html">SigC::Slot7</a> that encapsulates a const volatile method and an object instance. 
<p>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000032">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a31" doxytag="SigC::slot_class"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot6&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6&gt; slot_class </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot6.html">SigC::Slot6</a> that encapsulates a const volatile method and an object instance. 
<p>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000031">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a30" doxytag="SigC::slot_class"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot5&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5&gt; slot_class </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot5.html">SigC::Slot5</a> that encapsulates a const volatile method and an object instance. 
<p>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000030">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a29" doxytag="SigC::slot_class"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot4&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4&gt; slot_class </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4) const volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot4.html">SigC::Slot4</a> that encapsulates a const volatile method and an object instance. 
<p>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000029">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a28" doxytag="SigC::slot_class"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot3&lt;T_return, T_arg1,T_arg2,T_arg3&gt; slot_class </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3) const volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot3.html">SigC::Slot3</a> that encapsulates a const volatile method and an object instance. 
<p>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000028">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a27" doxytag="SigC::slot_class"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot2&lt;T_return, T_arg1,T_arg2&gt; slot_class </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2) const volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot2.html">SigC::Slot2</a> that encapsulates a const volatile method and an object instance. 
<p>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000027">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a26" doxytag="SigC::slot_class"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot1&lt;T_return, T_arg1&gt; slot_class </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1) const volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot1.html">SigC::Slot1</a> that encapsulates a const volatile method and an object instance. 
<p>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000026">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a25" doxytag="SigC::slot_class"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot0&lt;T_return&gt; slot_class </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)() const volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot0.html">SigC::Slot0</a> that encapsulates a const volatile method and an object instance. 
<p>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000025">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a24" doxytag="SigC::slot_class"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot7&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7&gt; slot_class </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot7.html">SigC::Slot7</a> that encapsulates a volatile method and an object instance. 
<p>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000024">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a23" doxytag="SigC::slot_class"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot6&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6&gt; slot_class </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot6.html">SigC::Slot6</a> that encapsulates a volatile method and an object instance. 
<p>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000023">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a22" doxytag="SigC::slot_class"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot5&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5&gt; slot_class </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot5.html">SigC::Slot5</a> that encapsulates a volatile method and an object instance. 
<p>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000022">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a21" doxytag="SigC::slot_class"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot4&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4&gt; slot_class </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4) volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot4.html">SigC::Slot4</a> that encapsulates a volatile method and an object instance. 
<p>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000021">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a20" doxytag="SigC::slot_class"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot3&lt;T_return, T_arg1,T_arg2,T_arg3&gt; slot_class </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3) volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot3.html">SigC::Slot3</a> that encapsulates a volatile method and an object instance. 
<p>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000020">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a19" doxytag="SigC::slot_class"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot2&lt;T_return, T_arg1,T_arg2&gt; slot_class </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2) volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot2.html">SigC::Slot2</a> that encapsulates a volatile method and an object instance. 
<p>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000019">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a18" doxytag="SigC::slot_class"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot1&lt;T_return, T_arg1&gt; slot_class </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1) volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot1.html">SigC::Slot1</a> that encapsulates a volatile method and an object instance. 
<p>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000018">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a17" doxytag="SigC::slot_class"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot0&lt;T_return&gt; slot_class </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)() volatile</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot0.html">SigC::Slot0</a> that encapsulates a volatile method and an object instance. 
<p>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000017">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a16" doxytag="SigC::slot_class"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot7&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7&gt; slot_class </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot7.html">SigC::Slot7</a> that encapsulates a const method and an object instance. 
<p>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000016">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a15" doxytag="SigC::slot_class"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot6&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6&gt; slot_class </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot6.html">SigC::Slot6</a> that encapsulates a const method and an object instance. 
<p>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000015">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a14" doxytag="SigC::slot_class"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot5&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5&gt; slot_class </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot5.html">SigC::Slot5</a> that encapsulates a const method and an object instance. 
<p>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000014">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a13" doxytag="SigC::slot_class"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot4&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4&gt; slot_class </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4) const</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot4.html">SigC::Slot4</a> that encapsulates a const method and an object instance. 
<p>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000013">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a12" doxytag="SigC::slot_class"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot3&lt;T_return, T_arg1,T_arg2,T_arg3&gt; slot_class </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3) const</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot3.html">SigC::Slot3</a> that encapsulates a const method and an object instance. 
<p>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000012">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a11" doxytag="SigC::slot_class"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot2&lt;T_return, T_arg1,T_arg2&gt; slot_class </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2) const</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot2.html">SigC::Slot2</a> that encapsulates a const method and an object instance. 
<p>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000011">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a10" doxytag="SigC::slot_class"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot1&lt;T_return, T_arg1&gt; slot_class </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1) const</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot1.html">SigC::Slot1</a> that encapsulates a const method and an object instance. 
<p>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000010">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a9" doxytag="SigC::slot_class"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot0&lt;T_return&gt; slot_class </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">const T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)() const</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot0.html">SigC::Slot0</a> that encapsulates a const method and an object instance. 
<p>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000009">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a8" doxytag="SigC::slot_class"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot7&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6,T_arg7&gt; slot_class </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7)</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot7.html">SigC::Slot7</a> that encapsulates a method and an object instance. 
<p>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000008">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a7" doxytag="SigC::slot_class"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot6&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5,T_arg6&gt; slot_class </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6)</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot6.html">SigC::Slot6</a> that encapsulates a method and an object instance. 
<p>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000007">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a6" doxytag="SigC::slot_class"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot5&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4,T_arg5&gt; slot_class </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5)</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot5.html">SigC::Slot5</a> that encapsulates a method and an object instance. 
<p>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000006">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a5" doxytag="SigC::slot_class"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot4&lt;T_return, T_arg1,T_arg2,T_arg3,T_arg4&gt; slot_class </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3, T_arg4)</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot4.html">SigC::Slot4</a> that encapsulates a method and an object instance. 
<p>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000005">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a4" doxytag="SigC::slot_class"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot3&lt;T_return, T_arg1,T_arg2,T_arg3&gt; slot_class </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2, T_arg3)</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot3.html">SigC::Slot3</a> that encapsulates a method and an object instance. 
<p>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a3" doxytag="SigC::slot_class"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_arg2, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot2&lt;T_return, T_arg1,T_arg2&gt; slot_class </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1, T_arg2)</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot2.html">SigC::Slot2</a> that encapsulates a method and an object instance. 
<p>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a2" doxytag="SigC::slot_class"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_arg1, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot1&lt;T_return, T_arg1&gt; slot_class </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)(T_arg1)</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot1.html">SigC::Slot1</a> that encapsulates a method and an object instance. 
<p>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<a name="a1" doxytag="SigC::slot_class"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template &lt;class T_return, class T_obj&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Slot0&lt;T_return&gt; slot_class </td>
          <td class="md" valign="top">(</td>
          <td class="md" nowrap valign="top">T_obj&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_return(T_obj::*&nbsp;</td>
          <td class="mdname" nowrap> <em>_A_func</em>)()</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a functor of type <a class="el" href="classSigC_1_1Slot0.html">SigC::Slot0</a> that encapsulates a method and an object instance. 
<p>
This function is part of the compatibility module and therefore deprecated. Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>_A_obj</em>&nbsp;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign=top><em>_A_func</em>&nbsp;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation.</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__mem__fun.html#a96">sigc::mem_fun()</a> instead.</dd></dl>
    </td>
  </tr>
</table>
<hr><address><small>
Generated for libsigc++ 2.0 by <a href="http://www.doxygen.org/index.html">
Doxygen</a> 1.3.3 &copy;&nbsp;1997-2001</small></address>
</body>
</html>

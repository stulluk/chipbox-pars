#include "linuxos.h"

#include "tuner_reg.h"
#include "tuner_drv.h"

#define I2C_TIMEOUT                (2)

#define I2C_SET _IOW('I', 0, unsigned long)

static CSOS_Semaphore_t*  sem_RegAccess = NULL;

int i2c_fd = 0;


tReg_Info_t 					*Reg_List = NULL;
U16							Reg_Count = 0;

void tuner_delay_us(unsigned int count)
{
	usleep(count*1000);
}

static int _gpio_write(char *devname, char* buf, int len )
{
	int gpio_fd;
	int retval;
	char cmd='O';
    puts(devname);
	gpio_fd = open(devname,O_RDWR);
	if (gpio_fd <= 0)
	{
		printf("Error: Open %s.\n",devname);
		return -1;
	}
	
	retval = write(gpio_fd, &cmd , 1);
	if (retval != 1)
	{
		printf("Error: Read %s. \n",devname);
		return -1;
	}

	retval = write(gpio_fd, buf , len);
	if (retval != len)
	{
		printf("Error: Read %s. \n",devname);
		return -1;
	}
/*
	cmd= 'o';
	retval = write(gpio_fd, &cmd , 1);
	if (retval != 1)
	{
		printf("Error: Read %s. \n",devname);
		return -1;
	}
*/

    retval = close(gpio_fd);

	return len;
    
}


int	tuner_i2c_init(void)
{	
	//printf("into tuner_i2c_init function called. \n");
	//sem_Demod_ic_access = CSOS_CreateMutexFifo();
		
	i2c_fd = open("/dev/misc/orion_i2c", O_RDWR);
	if(i2c_fd < 0) 
	{
		printf("Error: /dev/misc/orion_i2c.\n");
		return i2c_fd;
	}
	//printf("out tuner_i2c_init function called. \n");
	
	return 0;
}


/*This read time mode*/
/* Start | ACK | SubAddr | Ack | Data[0] |Ack .... Data[N] |Ack | Stop*/
int tuner_i2c_read(unsigned int address, int subaddr, unsigned char *buffer, unsigned int num)
{
    int subaddr_num = 0x01;
    int icount = 0;
    int retval = 0;
    unsigned char buf_val[245];

    memset(&buf_val, 0, 245);

    //if(subaddr < 0)
     //subaddr = 0;
    //CSOS_WaitSemaphore(sem_Demod_ic_access);
    retval = ioctl(i2c_fd, I2C_SET, address);	 /* Chip: 0x50, 2 Byte Address */
    if(retval < 0) 
    {
         printf("22 I2C_SET failed! ret=%d\n", retval);
         //CSOS_SignalSemaphore(sem_Demod_ic_access);
         return -1;
    }

    if(subaddr >=0)
 	{
        retval = write( i2c_fd , &subaddr , 1 );
        if(retval < 0)
        {
             printf("read  write reg ret=%d\n", retval);
             //CSOS_SignalSemaphore(sem_Demod_ic_access);
             return -1;
        }
 	}

    retval = read(i2c_fd, buf_val, num);
    if(retval < 0)
    {
         printf("read ret=%d\n", retval);
         //CSOS_SignalSemaphore(sem_Demod_ic_access);
         return -1;
    }
    //CSOS_SignalSemaphore(sem_Demod_ic_access);
    tuner_delay_us(80);

    for(icount = 0; icount < num; icount++)
    buffer[icount] = buf_val[icount];

    return 0;

	 
}

int tuner_i2c_write(unsigned int address, int subaddr, unsigned char *buffer, unsigned int num)
{
    int icount = 0;
    int  retval = 0;
    unsigned char buf_val[245];

    //CSOS_WaitSemaphore(sem_Demod_ic_access);	 
     retval = ioctl(i2c_fd, I2C_SET, address);  /* Chip: 0x50, 2 Byte Address */
    if(retval < 0) 
    {
         printf("I2C_SET failed! ret=%d\n", retval);
         //CSOS_SignalSemaphore(sem_Demod_ic_access);
         return retval;
    }

    buf_val[0]=subaddr;
    for(icount = 0; icount < num; icount++)
     buf_val[icount+1] = buffer[icount];

    /*retval = lseek(i2c_fd, subaddr, 0);
    if(retval < 0)
    {
     printf("lseek ret=%d\n", retval);
     return -1;
    }*/
     
    num+=1;
    //printf("subaddr=0x%x,data=0x%x,num=%d\n",buf_val[0],buf_val[1],num);
    retval = write(i2c_fd, buf_val, num);
    if(retval < 0)
    {
         printf("write failed1 ret=%d,buf0=%x\n", buf_val[1],subaddr);
         //CSOS_SignalSemaphore(sem_Demod_ic_access);
         return -1;
    }
    fflush(stdout);
    //CSOS_SignalSemaphore(sem_Demod_ic_access);
    tuner_delay_us(80); 

    return 0;

}


int tuner_gpio_reset(void)
{
	int  retval = 0;
	char value = '0';
	retval = _gpio_write("/dev/gpio/6",&value,1);
	printf("write gpio 6 to 0\n");
	usleep(400000);
	value = '1';
	retval = _gpio_write("/dev/gpio/6", &value,1);
	//usleep(400000);
	printf("write gpio 6 to 1\n");
	return 0;	
}



int Reg_Init(tReg_OpenParams_t * params)
{
	int	error = CS_NO_ERROR;
            CSI2C_Attr      param;

	if(params == NULL)
		return(CS_ERROR_BAD_PARAMETER);

        tuner_gpio_reset();

	Reg_List = (tReg_Info_t *)CSOS_AllocateMemory(NULL, sizeof(tReg_Info_t)*params->Reg_Count);
	if(Reg_List == NULL)
		return(CS_ERROR_NO_MEMORY);

	Reg_Count = params->Reg_Count;

        sem_RegAccess = CSOS_CreateSemaphoreFifo (NULL, 1);

	tuner_i2c_init();

	//printf("demod i2c open error = %d\n", error);

	return(error);

}

int Reg_AddDemodReg(U32 Id, U8 address, U8 def_value)
{
	tReg_Info_t *pReg;

	if(Id >= Reg_Count)
		return(CS_ERROR_BAD_PARAMETER);
	
	pReg=&Reg_List[Id];
	
	pReg->Address = address;
	pReg->Default_Value = def_value;

	return(CS_NO_ERROR);
	
}

int Reg_ApplyDefault(void)
{
	U32 reg;

	for ( reg = 0 ; reg < Reg_Count; reg++ )
		Reg_SetOneDemodReg(reg, Reg_List[reg].Default_Value);

	return(CS_NO_ERROR);
}


int Reg_SetOneDemodReg(U32 reg_id, U8 Data)   
{ 
	int 	error = 0;
	U8		data_buffer;
	U32       	actlen;

	if(reg_id >= Reg_Count)
		return(CS_ERROR_BAD_PARAMETER);

	CSOS_WaitSemaphore (sem_RegAccess);
	//data_buffer[0] = Reg_List[reg_id].Address;
	data_buffer = Data; 	
	
	//error = CSI2C_Write(Demod_IOHandle, Reg_List[reg_id].Address, &data_buffer, 1);
         error = tuner_i2c_write(ZL10353_I2C_ADDRESS, Reg_List[reg_id].Address, &data_buffer, 1);
	if ( error == 0)
	{
		Reg_List[reg_id].Current_Value = Data;  
	}

        CSOS_SignalSemaphore (sem_RegAccess);	

	if(error!=0)  printf("=>>Reg_SetOneDemodReg   %x\n",error);

	return(error);
		
}

int Reg_GetOneDemodReg(U32 reg_id, U8 * Data)
{
	U32       actlen;	
	int error = CS_NO_ERROR;
	U8	data_buffer;

	if(reg_id >= Reg_Count)
		return(CS_ERROR_BAD_PARAMETER);
	
	CSOS_WaitSemaphore (sem_RegAccess);
#if 0		
	error = I2C_WriteNoStop(Demod_IOHandle, &reg_addr, 1, &actlen, I2C_TIMEOUT);
	if ( error == CS_NO_ERROR)
	{
		error = I2C_Read(Demod_IOHandle, &(Reg_List[reg_id].Current_Value), 1, &actlen, I2C_TIMEOUT);
		* Data = Reg_List[reg_id].Current_Value;
	}
#else
	data_buffer = Reg_List[reg_id].Address;
	//error = CSI2C_Read(Demod_IOHandle, Reg_List[reg_id].Address, &data_buffer, 1 );
        error = tuner_i2c_read(ZL10353_I2C_ADDRESS, Reg_List[reg_id].Address, &data_buffer, 1);
	* Data = data_buffer;
	Reg_List[reg_id].Current_Value = data_buffer;
#endif
	CSOS_SignalSemaphore (sem_RegAccess);	

	if(error!=CSAPI_SUCCEED)  printf("=>>Reg_GetOneDemodReg   %x\n",error);
	
	return(error);
}


